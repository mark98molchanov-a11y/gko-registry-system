<!DOCTYPE html>
<html lang="ru" class="dark">
<head>
    <meta charset="UTF-8">
    <title>Интерактивное дерево с JSON импортом/экспортом</title>
<meta http-equiv="Content-Security-Policy" content="default-src 'self' data: blob:; script-src 'self' 'unsafe-inline' https://cdn.jsdelivr.net; style-src 'self' 'unsafe-inline'; img-src 'self' data: blob:;">
    <script src="https://cdn.jsdelivr.net/npm/lz-string@1.4.4/libs/lz-string.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/sortablejs@latest/Sortable.min.js"></script>
    <style>
:root {
    --primary-color: #5D8AA8;
    --secondary-color: #87CEEB;
    --accent-color: #FFA07A;
    --background: #F0F8FF;
    --text-color: #2F4F4F;
    --node-bg: linear-gradient(145deg, #FFFFFF, #F8F9FF);
    --controls-bg: rgba(255, 255, 255, 0.98);
}
.dark {
    --primary-color: #7BA7CC;
    --secondary-color: #5D8AA8;
    --accent-color: #FF8C66;
    --background: #1A2A3A;
    --text-color: #E0E8F0;
    --node-bg: linear-gradient(145deg, #2A3B4C, #1E2B38);
    --controls-bg: rgba(30, 40, 50, 0.98);
}
body {
    margin: 0;
    font-family: 'Segoe UI', Arial, sans-serif;
    background: var(--background);
    color: var(--text-color);
    transition: background 0.5s ease, color 0.3s ease;
    position: relative;
    height: 100vh;
    width: 100vw;
    padding: 0;
    overflow: auto;
overflow-y: scroll; 
}
#selectedCount {
    margin-left: 10px;
    font-size: 0.9em;
    color: var(--accent-color);
    font-weight: bold;
    transition: all 0.3s ease;
    display: none; 
}
#selectedCount.visible {
    display: inline-block !important; 
    z-index: 1001; 
}
.dark body::before {
    content: '';
    position: fixed;
    top: 0;
    left: 0;
    right: 0;
    bottom: 0;
    background: radial-gradient(circle at 50% 50%, rgba(93, 138, 168, 0.05) 0%, transparent 80%);
    pointer-events: none;
    z-index: -1;
    animation: subtleGlow 15s infinite alternate;
}
@keyframes subtleGlow {
    0% { opacity: 0.3; transform: scale(1); }
    100% { opacity: 0.7; transform: scale(1.5); }
}
.tree {
    min-height: 100%;
    min-width: max-content; 
    display: flex;
    justify-content: flex-start; 
    padding: 40px;
    position: relative;
    transform-origin: 0 0;
    transition: transform 0.2s ease-out;
    margin: 0 auto;
}
.children {
    display: flex;
    flex-direction: row; 
    flex-wrap: wrap; 
    align-items: flex-start; 
    gap: 20px; 
    padding: 0;
    margin-left: 20px; 
    transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
    position: relative;
    z-index: 1;
}
.node.horizontal {
    display: flex;
    flex-direction: row;
    align-items: flex-start;
    margin: 0;
}
.children-count {
    position: absolute;
    bottom: 8px;
    right: 8px;
    background: var(--primary-color);
    color: white;
    border-radius: 50%;
    width: 45px;
    height: 45px;
    display: flex;
    align-items: center;
    justify-content: center;
    font-size: 2.5em;
    box-shadow: 0 2px 4px rgba(0,0,0,0.2);
}
.children.collapsed {
    opacity: 0;
    max-height: 0;
    padding-top: 0;
    pointer-events: none;
    transform: translateY(-20px);
}
.node-content.subordinate {
    border-style: dashed;
    border-width: 2px;
    background: linear-gradient(145deg, rgba(135, 206, 235, 0.05), var(--node-bg));
    box-shadow: 0 0 10px rgba(135, 206, 235, 0.1);
padding: 20px 20px 20px 60px !important;
}
.node-content.subordinate::before {
    content: '⤷';
    position: absolute;
    left: 10px;
    top: 10px;
    color: var(--secondary-color);
    opacity: 0.5;
}
.connector {
    top: -35px;
    height: 35px;
    width: 3px;
    background: var(--primary-color) !important;
    transform: translateX(-50%) translateY(5px);
}
.connector::after {
    content: '';
    position: absolute;
    bottom: -8px;
    left: 50%;
    transform: translateX(-50%);
    border: 8px solid transparent;
    border-top-color: inherit;
    border-bottom: 0;
}
.node {
    display: flex;
    flex-direction: column;
    align-items: center;
    margin: 0 15px;
    position: relative;
    transition: transform 0.2s ease-out, opacity 0.2s ease-out;
overflow: visible !important;
}
.node-content.absent-269::after,
.node-content.power-269::after,
.node-content.for-all-node::after,
.node-content.subordinate-node::after,
.node-content.authority-node::after {
    content: attr(data-label);
    position: absolute;
    bottom: -22px;
    right: 10px;
    font-size: 1.4em;
    padding: 4px 8px;
    border-radius: 6px;
    font-weight: 500;
    letter-spacing: 0.5px;
    box-shadow: 0 2px 4px rgba(0, 0, 0, 0.2);
    white-space: nowrap;
     z-index: 1000;
transform: translateY(100%); 
    text-transform: uppercase;
    font-family: 'Segoe UI', Arial, sans-serif;
}
.node-content.no-children {
    background: linear-gradient(145deg, rgba(255, 68, 68, 0.15), var(--node-bg)) !important;
    border-color: #ff4444 !important;
}
.node-content.no-children.absent-269::after,
.node-content.no-children.power-269::after,
.node-content.no-children.for-all-node::after,
.node-content.no-children.subordinate-node::after,
.node-content.no-children.authority-node::after,
.node-content.no-children.okr-node::after,
.node-content.no-children.indicator-node::after {
    display: block !important;
    z-index: 1000 !important;
}
.tree-container {
    width: 100%;
    height: 100%;
    padding: 80px 30px 30px;
    box-sizing: border-box;
    overscroll-behavior: contain;
    overflow: auto !important; /* Изменено с scroll на auto */
    scrollbar-width: thin;
    scrollbar-color: var(--primary-color) var(--bg-color);
    min-width: 100vw; /* Добавлено */
    min-height: 100vh; /* Добавлено */
}
::-webkit-scrollbar {
    width: 15px;
    height: 15px;
}
.children.grid-3-col::-webkit-scrollbar {
    width: 35px;
    height: 35px;
}
::-webkit-scrollbar-track {
    background: rgba(93, 138, 168, 0.1);
    border-radius: 35px;
}
::-webkit-scrollbar-thumb {
    background-color: var(--primary-color);
    border-radius: 35px;
    border: 20px solid var(--bg-color);
}
::-webkit-scrollbar-thumb:hover {
    background-color: var(--secondary-color);
}
.tree-container::-webkit-scrollbar-corner {
    background: transparent;
}

/* Для Firefox */
.tree-container {
    scrollbar-width: thin;
    scrollbar-color: var(--primary-color) rgba(93, 138, 168, 0.1);
}
    .background-text {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            display: flex;
            justify-content: center;
            align-items: center;
            pointer-events: none;
            z-index: -10;
            overflow: hidden;
        }
        .background-text h1 {
            font-size: 5vw;
            font-weight: 900;
            text-transform: uppercase;
            text-align: center;
            line-height: 1.2;
            color: rgba(93, 138, 168, 0.05);
            transition: color 0.5s ease, transform 0.5s ease;
            transform: rotate(-5deg);
            max-width: 90%;
            letter-spacing: 0.05em;
            white-space: pre-wrap;
            user-select: none;
        }
        .dark .background-text h1 {
            color: rgba(93, 138, 168, 0.08);
        }  
        .background-text h1:hover {
            transform: rotate(0deg) scale(1.02);
            color: rgba(93, 138, 168, 0.12);
            transition: color 0.3s ease, transform 0.3s ease;
        } 
        .dark .background-text h1:hover {
            color: rgba(93, 138, 168, 0.15);
        }  
        @media (max-width: 768px) {
            .background-text h1 {
                font-size: 8vw;
            }
        }
        @keyframes float {
            0% { transform: rotate(-5deg) translateY(0px); }
            50% { transform: rotate(-4deg) translateY(-10px); }
            100% { transform: rotate(-5deg) translateY(0px); }
        }  
        .background-text h1 {
            animation: float 10s ease-in-out infinite;
        }

.node-content {
    border: 6px solid var(--primary-color); /* Более толстая граница */
    border-radius: 18px; /* Увеличенное скругление углов */
    padding: 20px 20px 20px 55px !important; 
    background: var(--node-bg);
    cursor: pointer;
    transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
    min-width: 500px;
    max-width: 700px;
    text-align: center;
    position: relative;
    /* Обновленные тени */
    margin: 18px; /* Чуть больше внешнего отступа */
}
.node-content.horizontal {
    padding: 22px !important;
    display: flex;
    flex-direction: row;
    align-items: flex-start;
    text-align: left;
    min-width: 420px;
    max-width: 800px;
    border-radius: 18px; 
border: 6px solid var(--primary-color);
}

.node-content:hover {
    transform: translateY(-5px);
    box-shadow: 0 10px 20px rgba(0, 0, 0, 0.15);
    border-color: var(--secondary-color);
    box-shadow: inset 0 0 15px rgba(93, 138, 168, 0.2), 0 10px 20px rgba(0, 0, 0, 0.15), 0 0 15px rgba(135, 206, 235, 0.3);
}
.multi-selected {
    position: relative;
    z-index: 10000 !important;
    border-color: #FFD700 !important;
    box-shadow: 0 0 20px rgba(255, 215, 0, 0.8) !important;
    background: linear-gradient(145deg, rgba(255, 215, 0, 0.15), var(--node-bg)) !important;
}

.multi-selected::after {
    content: '';
    position: absolute;
    top: -4px;
    left: -4px;
    right: -4px;
    bottom: -4px;
    border: 3px solid #FFD700 !important;
    border-radius: 14px;
    pointer-events: none;
    animation: goldPulse 2s infinite;
    z-index: 10001 !important;
}
.multi-selected.absent-269::after,
.multi-selected.power-269::after,
.multi-selected.for-all-node::after,
.multi-selected.subordinate-node::after,
.multi-selected.authority-node::after,
.multi-selected.okr-node::after,
.multi-selected.indicator-node::after {
    display: none !important;
}
.node-title:hover {
    animation: titlePulse 1.5s ease-in-out infinite;
    box-shadow: 0 2px 8px rgba(255,160,122,0.2);
}
.connector {
    position: absolute;
    height: 40px;
    width: 4px;
    background: linear-gradient(to bottom, 
        var(--accent-color) 20%,
        var(--primary-color) 80%);
    top: -40px;
    left: 50%;
    transform: translateX(-50%);
    transition: all 0.3s;
    box-shadow: 0 0 15px rgba(255,160,122,0.3);
    border-radius: 2px;
    animation: connectorFlow 2s infinite;
}
.horizontal-connector {
    left: -35px;
    width: 35px;
    height: 3px;
    transform: translateY(-50%) translateX(5px);
}
.horizontal-connector::before {
    content: '';
    position: absolute;
    right: -8px;
    top: 50%;
    transform: translateY(-50%);
    border: 8px solid transparent;
    border-left-color: inherit;
    border-right: 0;
}
.connector.level-1 {
    top: -45px;
    height: 45px;
}
.connector.level-1::after {
    border-top-color: var(--level-1);
}
.horizontal-connector.level-1 {
    left: -55px;
    width: 55px;
}
.horizontal-connector.level-1::before {
    border-left-color: var(--level-1);
}
.connector.level-2 { 
    background: var(--level-2) !important;
    box-shadow: 0 0 15px rgba(255,107,107,0.3);
}
.connector.level-2::after {
    border-top-color: var(--level-2);
}

.horizontal-connector.level-2 {
    background: var(--level-2) !important;
    box-shadow: 0 0 15px rgba(255,107,107,0.3);
}
.horizontal-connector.level-2::before {
    border-left-color: var(--level-2);
}
.connector.level-3 { 
    background: var(--level-3) !important;
    box-shadow: 0 0 15px rgba(255,107,107,0.3);
}
.connector.level-3::after {
    border-top-color: var(--level-3);
}
.horizontal-connector.level-3 {
    background: var(--level-3) !important;
    box-shadow: 0 0 15px rgba(255,107,107,0.3);
}
.horizontal-connector.level-3::before {
    border-left-color: var(--level-3);
}
.node-content {
    position: relative;
    margin: 15px;
    transition: all 0.3s;
    overflow: visible;
padding-bottom: 30px;
margin-bottom: 50px; /* Добавляем чтобы скрыть выходящие за границы элементы */
}
.node-content::before {
  content: none;
    position: absolute;
    top: -8px;
    left: 50%;
    width: 16px;
    height: 16px;
    background: var(--primary-color);
    border-radius: 50%;
    transform: translateX(-50%);
    z-index: 1;
}
.connector.subordinate {
    background: var(--accent-color) !important;
    height: 20px !important;
    top: -20px !important;
}
.horizontal-connector.subordinate {
    background: var(--accent-color) !important;
    width: 20px !important;
    left: -20px !important;
}
/* Специальные стили для стрелок подчиненных узлов */
.connector.subordinate::after {
    border-top-color: var(--accent-color) !important;
    bottom: -6px !important;
    border-width: 6px !important;
}

.horizontal-connector.subordinate::before {
    border-left-color: var(--accent-color) !important;
    right: -6px !important;
    border-width: 6px !important;
}
.node-content.horizontal::before {
    top: 50%;
    left: -8px;
    transform: translateY(-50%);
}
.node-img {
    width: 220px !important;  
    height: 220px !important;
    border-radius: 12px;
    object-fit: cover;
    margin-bottom: 15px;
    cursor: pointer;
    border: 3px solid var(--primary-color);
    transition: all 0.3s;
    box-shadow: 0 5px 10px rgba(93, 138, 168, 0.3);
    background: var(--node-bg);
    /* Add subtle glow to images */
    filter: drop-shadow(0 0 5px rgba(93, 138, 168, 0.2));
}
.node-img.horizontal {
    margin-bottom: 0;
    margin-right: 15px;
   width: 220px !important;
     height: 220px !important; 
}

.node-actions {
    position: absolute;
    top: 100%; 
    left: 0;
    display: flex;
    gap: 5px;
    margin-top: 5px; 
    z-index: 10;
}

.node-action-btn {
    width: 50px;
    height: 50px;
    border-radius: 50%;
    background: var(--primary-color);
    color: white;
    border: none;
    cursor: pointer;
    display: flex;
    align-items: center;
    justify-content: center;
    font-size: 14px;
    transition: all 0.2s;
}
.tree-selection-node {
    cursor: pointer;
    user-select: none;
}

.tree-selection-node:hover {
    background: rgba(93, 138, 168, 0.1);
}

.tree-selection-children {
    margin-left: 20px;
}
.node-action-btn:hover {
    background: var(--secondary-color);
    transform: scale(1.1);
}
.node-action-btn.add-btn{
 font-size: 40px;
background: linear-gradient(145deg, #388E3C, #4CAF50);
}
.node-action-btn.delete-btn {
 font-size: 40px;
background: linear-gradient(145deg, #d32f2f, #ff4444);
}
.node-img:hover {
    transform: scale(1.08);
    box-shadow: 0 0 25px rgba(93, 138, 168, 0.4);
    border-color: var(--secondary-color);
    /* Enhanced glow on hover */
    filter: drop-shadow(0 0 8px rgba(93, 138, 168, 0.4));
}
.file-block {
    background: linear-gradient(145deg, rgba(93, 138, 168, 0.15), rgba(93, 138, 168, 0.05)) !important;
    border: 2px solid var(--secondary-color) !important;
    position: relative;
    overflow: hidden;
    transition: all 0.3s ease;
padding: 10px 15px !important;
font-size: 1.3rem !important;
}
.file-block::after {
    content: '';
    position: absolute;
    top: 0;
    left: 0;
    right: 0;
    bottom: 0;
    background: linear-gradient(135deg, rgba(255, 255, 255, 0.1) 0%, rgba(255, 255, 255, 0) 50%);
    pointer-events: none;
}
.dark .file-block::after {
    background: linear-gradient(135deg, rgba(93, 138, 168, 0.1) 0%, rgba(93, 138, 168, 0) 50%);
}

.file-block:hover {
    transform: translateY(-3px) !important;
    box-shadow: 0 8px 15px rgba(93, 138, 168, 0.25) !important;
    background: linear-gradient(145deg, rgba(93, 138, 168, 0.2), rgba(93, 138, 168, 0.1)) !important;
}

.file-block span[role="img"] {
    font-size: 1.1em;
    margin-right: 8px;
    display: inline-block;
    color: var(--accent-color);
    text-shadow: 0 0 5px rgba(255, 160, 122, 0.3);
    transform: translateY(1px);
    transition: all 0.3s ease;
}
.file-block:hover span[role="img"] {
    transform: scale(1.2) translateY(1px);
    text-shadow: 0 0 8px rgba(255, 160, 122, 0.5);
}
.file-block.document::before {
    content: '';
    position: absolute;
    top: 0;
    right: 0;
    width: 0;
    height: 0;
    border-style: solid;
    border-width: 0 20px 20px 0;
    border-color: transparent var(--accent-color) transparent transparent;
    opacity: 0.7;
}
.file-block.image::before {
    content: '';
    position: absolute;
    top: 0;
    right: 0;
    width: 0;
    height: 0;
    border-style: solid;
    border-width: 0 20px 20px 0;
    border-color: transparent #4ECDC4 transparent transparent;
    opacity: 0.7;
}

.file-block.archive::before {
    content: '';
    position: absolute;
    top: 0;
    right: 0;
    width: 0;
    height: 0;
    border-style: solid;
    border-width: 0 20px 20px 0;
    border-color: transparent #45B7D1 transparent transparent;
    opacity: 0.7;
}

.file-block .file-name {
   font-size: 1.4rem !important;
    white-space: nowrap;
    overflow: hidden;
    text-overflow: ellipsis;
     max-width: 240px  !important;
    display: inline-block;
    vertical-align: middle;
}

.file-block .file-size {
    font-size: 0.75em;
    background: rgba(93, 138, 168, 0.2);
    padding: 2px 6px;
    border-radius: 10px;
    margin-left: 5px;
    opacity: 0.8;
}

/* Animation for new files */
@keyframes fileAppear {
    0% { 
        transform: scale(0.8); 
        opacity: 0; 
    }
    50% { 
        transform: scale(1.05); 
    }
    100% { 
        transform: scale(1); 
        opacity: 1; 
    }
}
.file-block.new-file {
    animation: fileAppear 0.5s ease-out forwards;
}
.file-block .download-btn {
    opacity: 0;
    transition: all 0.3s ease;
    background: var(--primary-color);
    color: white;
    border: none;
    border-radius: 4px;
    padding: 2px 6px;
    font-size: 0.8em;
    cursor: pointer;
    margin-left: 5px;
}
.file-block:hover .download-btn {
    opacity: 1;
}
.file-block .download-btn:hover {
    background: var(--secondary-color);
    transform: scale(1.1);
}
.image-actions {
    position: relative;
    display: flex;
    flex-direction: column;
    align-items: center;
    gap: 5px;
}
.node-title, .node-text, .sub-block, .file-block, .metric-title, .quarter-value {
  -webkit-font-smoothing: antialiased;
  -moz-osx-font-smoothing: grayscale;
  text-rendering: optimizeLegibility;
  font-weight: 500; /* Средняя жирность для лучшей читаемости */
  min-font-size: 12px !important; /* Минимальный размер */
/* Адаптивный размер */
}
.hide-image-btn, .delete-image-btn {
    position: relative;
    width: 24px;
    height: 24px;
    border-radius: 50%;
    background: var(--accent-color);
    color: white;
    border: none;
    cursor: pointer;
    display: flex;
    align-items: center;
    justify-content: center;
    font-size: 12px;
    transition: all 0.2s;
}
.hide-image-btn:hover, .delete-image-btn:hover {
    transform: scale(1.1);
}
.upload-image-options {
    display: flex;
    flex-direction: column;
    align-items: center;
    gap: 5px;
}
.text-only-option {
    padding: 4px 8px;
    background: rgba(93, 138, 168, 0.1);
    border-radius: 4px;
    cursor: pointer;
    font-size: 0.8em;
    transition: all 0.2s;
}
.text-only-option:hover {
    background: rgba(93, 138, 168, 0.2);
}
.controls {
    position: fixed;
    top: 10px;
    left: 10px;
    right: 10px;
    background: var(--controls-bg);
    padding: 10px;
    border-radius: 12px;
    box-shadow: 0 4px 10px rgba(0, 0, 0, 0.15);
    backdrop-filter: blur(8px);
    display: flex;
    flex-wrap: wrap;
    gap: 6px;
    z-index: 1000;
    transition: all 0.3s ease;
    width: auto;
    max-width: none;
    max-height: none;
    justify-content: flex-start;
    align-items: center;
}

/* Адаптивные кнопки */
.controls button {
    padding: 10px 14px !important;
    border-radius: 8px !important;
background: linear-gradient(145deg, var(--primary-color), #6B9EBF);
 color: white;
    min-width: 40px !important; 
    display: flex;
    align-items: center;
    justify-content: center;
    white-space: nowrap;
    height: 30px !important; 
    box-sizing: border-box;
    margin: 0 2px; 
    line-height: 1 !important;
min-width: 60px;
cursor: pointer;
 gap: 10px; 
}
.remove-from-cluster-btn:hover:not(:disabled) {
    transform: scale(1.05);
    box-shadow: 0 0 10px rgba(255, 0, 0, 0.3);
}
.remove-from-cluster-btn:disabled {
    cursor: not-allowed;
    background: #cccccc !important;
}

@media (max-width: 1600px) {
    .controls {
        gap: 4px;
        padding: 8px;
    }
    .controls button {
        padding: 6px 10px;
        font-size: 0.8em;
        height: 32px;
    }
    #zoomInBtn, #zoomOutBtn, #zoomResetBtn, #addToClusterBtn {
        min-width: 32px;
        width: 32px;
        height: 32px;
    }
}
/* Еще более компактный вариант для очень узких экранов */
@media (max-width: 1200px) {
    .controls button {
        padding: 5px 8px;
        font-size: 0.75em;
        height: 30px;
    }
    #zoomInBtn, #zoomOutBtn, #zoomResetBtn, #addToClusterBtn {
        min-width: 30px;
        width: 30px;
        height: 30px;
        font-size: 1em;
    }
}
#mark269Btn, #power269Btn, #subordinateBtn, #forAllBtn, 
#authorityBtn, #okrBtn, #indicatorBtn,
#jsonExportBtn, #jsonImportBtn, #addBtn, #deleteBtn, 
#saveBtn, #collapseAllBtn, #collapseParentBtn,
#addSuperordinateAboveBtn, #uploadFileBtn {
    min-width: 110px !important;
    max-width: 160px !important;
    height: 36px !important;
    font-size: 0.7em !important;
    padding: 8px 12px !important;
    line-height: 1.2 !important;
    margin: 0 2px !important;
}

#addToClusterBtn {
    min-width: 36px !important;
    width: 36px !important;
    height: 36px !important;
    padding: 0 !important;
    font-size: 1.1em !important;
    display: flex;
    align-items: center;
    justify-content: center;
    margin: 0 2px !important;
}
#reorderClustersBtn,
#remove-from-cluster-btn {
    font-size: 0.7em !important;
    padding: 8px 12px !important;
}
#mark269Btn {
    background: linear-gradient(145deg, #9370D8,  #9370D8) !important;
    box-shadow: 0 0 10px rgba(255, 68, 68, 0.3) !important;
}
#power269Btn {
    background: linear-gradient(145deg, #9E9E9E, #757575) !important;
    box-shadow: 0 0 10px rgba(158, 158, 158, 0.3) !important;
}
#subordinateBtn {
    background: linear-gradient(145deg, #191970, #000080) !important;
    box-shadow: 0 0 10px rgba(25, 25, 112, 0.3) !important;
}
#forAllBtn {
    background: linear-gradient(145deg, #4CAF50, #388E3C) !important;
    box-shadow: 0 0 10px rgba(76, 175, 80, 0.3) !important;
}
#authorityBtn {
    background: linear-gradient(145deg, #D2B48C, #CD853F) !important;
    box-shadow: 0 0 10px rgba(210, 180, 140, 0.3) !important;
}
#okrBtn {
    background: linear-gradient(145deg, #FFA500, #FF8C00) !important;
    box-shadow: 0 0 10px rgba(255, 165, 0, 0.3) !important;
}
#indicatorBtn {
    background: linear-gradient(145deg, #00BFFF, #1E90FF) !important;
    box-shadow: 0 0 10px rgba(0, 191, 255, 0.3) !important;
}
.controls.hidden {
    transform: translateY(-100px);
    opacity: 0;
    pointer-events: none;
}

.toggle-controls {
    position: fixed;
    bottom: 20px;
    right: 20px;
    background: var(--controls-bg);
    padding: 10px;
    border-radius: 50%;
    box-shadow: 0 2px 5px rgba(0,0,0,0.2);
    cursor: pointer;
    z-index: 1001;
    transition: all 0.3s;
    width: 40px;
    height: 40px;
    display: flex;
    align-items: center;
    justify-content: center;
}
.selected {
    border-color: var(--secondary-color) !important;
    box-shadow: 0 0 25px rgba(135, 206, 235, 0.3);
    background: linear-gradient(145deg, rgba(135, 206, 235, 0.2), var(--node-bg));
}

button:hover {
    transform: translateY(-2px);
    box-shadow: 0 6px 12px rgba(93, 138, 168, 0.3);
    background: linear-gradient(145deg, #6B9EBF, var(--primary-color));
    /* Enhanced glow on hover */
    box-shadow: 0 6px 12px rgba(93, 138, 168, 0.3), 0 0 15px rgba(135, 206, 235, 0.4);
}
.image-preview-container {
    position: fixed;
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
    background: rgba(0,0,0,0.85);
    display: none;
    justify-content: center;
    align-items: center;
    z-index: 1000;
    cursor: zoom-out;
}
.image-preview {
    max-width: 90%;
    max-height: 90%;
    border-radius: 20px;
    box-shadow: 0 0 50px rgba(255,255,255,0.3);
    transform: scale(0);
    transition: transform 0.4s cubic-bezier(0.68, -0.55, 0.265, 1.55);
}
.preview-visible .image-preview {
    transform: scale(1);
}
@keyframes nodeEnter {
    from { 
        transform: scale(0); 
        opacity: 0; 
        filter: blur(5px);
    }
    to { 
        transform: scale(1); 
        opacity: 1; 
        filter: blur(0);
    }
}
.node-enter {
    animation: nodeEnter 0.6s cubic-bezier(0.34, 1.56, 0.64, 1);
}
.glow {
    filter: drop-shadow(0 0 20px rgba(93, 138, 168, 0.6));
    animation: glowPulse 1.5s ease-in-out;
}
.drop-zone {
    position: fixed;
    top: 50%;
    left: 50%;
    transform: translate(-50%, -50%);
    padding: 2rem 3rem;
    border: 3px dashed var(--accent-color);
    border-radius: 25px;
    background: rgba(255, 160, 122, 0.1);
    color: var(--accent-color);
    font-weight: bold;
    font-size: 1.2rem;
    display: none;
    z-index: 999;
    backdrop-filter: blur(3px);
}
.drop-zone.active {
    display: block;
    animation: pulse 1.5s infinite;
}
.image-container {
    position: relative;
    display: inline-block;
    margin-bottom: 15px;
}

.image-container.horizontal {
    display: flex;
    align-items: center;
    margin-bottom: 0;
    margin-right: 15px;
}
.show-image-btn, .allow-image-btn {
    padding: 4px 8px;
    background: rgba(93, 138, 168, 0.1);
    border-radius: 4px;
    cursor: pointer;
    font-size: 0.8em;
    transition: all 0.2s;
    margin-top: 5px;
    text-align: center;
}
.show-image-btn:hover, .allow-image-btn:hover {
    background: rgba(93, 138, 168, 0.2);
}
.text-only-mode {
    display: flex;
    flex-direction: column;
    align-items: center;
    gap: 5px;
}
.delete-image-btn {
    position: absolute;
    top: -10px;
    right: -10px;
    background: var(--accent-color);
    border: none;
    border-radius: 50%;
    width: 30px;
    height: 30px;
    color: white;
    cursor: pointer;
    font-size: 20px;
    line-height: 30px;
    padding: 0;
    display: flex;
    align-items: center;
    justify-content: center;
    box-shadow: 0 3px 6px rgba(0,0,0,0.3);
    transition: all 0.2s;
    z-index: 100;
}
.delete-image-btn.horizontal {
    top: -5px;
    right: -5px;
    width: 25px;
    height: 25px;
    font-size: 18px;
    line-height: 25px;
}
.delete-image-btn:hover {
    background: #ff7f50;
    transform: scale(1.15);
}
.watermark {
    position: fixed;
    bottom: 20px;
    right: 20px;
    color: rgba(93, 138, 168, 0.3);
    font-size: 0.9rem;
}
.theme-switch {
    position: relative;
    width: 70px; 
     height: 35px;
    border-radius: 20px;
    background: var(--primary-color);
    cursor: pointer;
    overflow: hidden;
    box-shadow: 0 0 10px rgba(0,0,0,0.1);
    /* Add subtle glow */
    box-shadow: 0 0 10px rgba(0,0,0,0.1), 0 0 8px rgba(93, 138, 168, 0.3);
}
.theme-switch-handle {
    position: absolute;
    top: 2px;
    left: 2px;
    width: 31px; 
    height: 31px;
    background: white;
    border-radius: 50%;
    transition: transform 0.3s ease;
    display: flex;
    align-items: center;
    justify-content: center;
     font-size: 16px; 
}
.dark .theme-switch-handle {
    transform: translateX(30px);
}
.theme-icon {
    position: absolute;
    top: 50%;
    transform: translateY(-50%);
    font-size: 16px;
    color: white;
}
.sun-icon {
    left: 8px;
}
.moon-icon {
    right: 8px;
}
.fade-in {
    animation: fadeIn 0.5s ease-in-out;
}
.node-text {
    max-width: 100%;
    font-size: 2rem !important;
    margin: 0 auto;
    cursor: text;
}
.node-heading {
    font-weight: bold;
    font-size: 2.4em !important;
    margin-bottom: 8px;
    text-align: center;
    color: var(--primary-color);
    border-bottom: 1px solid var(--secondary-color);
    padding-bottom: 5px;
    cursor: text;
}
.sub-blocks {
    margin-top: 20px;
    padding-left: 15px;
    border-left: 2px solid var(--primary-color);
    width: calc(100% - 25px);
    text-align: left;
    display: flex;
    flex-direction: column;
    font-size: 1.3rem !important; /* Увеличиваем размер шрифта */
    padding: 14px 18px !important; /* Увеличиваем отступы */
    line-height: 1.7 !important; /* Увеличиваем межстрочный интервал */
    min-width: 180px;
}
.sub-block a {
    color: var(--accent-color);
    text-decoration: none;
    border-bottom: 2px solid var(--accent-color);
    transition: all 0.2s ease;
    word-break: break-all;
    font-weight: 600;
    padding: 2px 4px;
    border-radius: 4px;
    background: rgba(255, 160, 122, 0.1);
    display: inline-block;
    margin: 2px 0;
}
.sub-block a::before {
    content: none !important;
}

.sub-block a:hover {
    color: white;
    background-color: var(--accent-color);
    border-bottom-color: var(--accent-color);
    transform: translateY(-1px);
    box-shadow: 0 2px 8px rgba(255, 160, 122, 0.3);
}
.sub-block a:active {
    transform: translateY(0);
    box-shadow: none;
}
.dark .sub-block a {
    color: var(--secondary-color);
    border-bottom-color: var(--secondary-color);
    background: rgba(93, 138, 168, 0.2);
}
.dark .sub-block a:hover {
    color: white;
    background-color: var(--secondary-color);
    border-bottom-color: var(--secondary-color);
    box-shadow: 0 2px 8px rgba(93, 138, 168, 0.4);
}
.sub-block a[href^="mailto:"],
.sub-block a[href*="email"],
.sub-block a[href*="mail"] {
    color: #D44638; /* Красный цвет Gmail */
    border-bottom-color: #D44638;
    background: rgba(212, 70, 56, 0.1);
    padding: 2px 4px 2px 22px; /* Добавляем место для иконки */
    position: relative;
}
.sub-block a[href^="mailto:"]::before,
.sub-block a[href*="email"]::before,
.sub-block a[href*="mail"]::before {
    content: "✉️";
    position: absolute;
    left: 4px;
    top: 50%;
    transform: translateY(-50%);
    font-size: 0.9em;
}
.sub-block a[href^="mailto:"]:hover,
.sub-block a[href*="email"]:hover,
.sub-block a[href*="mail"]:hover {
    background-color: #D44638;
    color: white;
}
.dark .sub-block a[href^="mailto:"],
.dark .sub-block a[href*="email"],
.dark .sub-block a[href*="mail"] {
    color: #EA4335; 
    border-bottom-color: #EA4335;
    background: rgba(234, 67, 53, 0.2);
}
.dark .sub-block a[href^="mailto:"]:hover,
.dark .sub-block a[href*="email"]:hover,
.dark .sub-block a[href*="mail"]:hover {
    background-color: #EA4335;
}
.sub-block a[href^="http"] {
    color: #1a73e8;
    border-bottom-color: #1a73e8;
    background: rgba(26, 115, 232, 0.1);
    padding: 2px 4px 2px 22px;
    position: relative;
}
.sub-block a[href^="http"]:hover {
    background-color: #1a73e8;
    color: white;
}
.dark .sub-block a[href^="http"] {
    color: #8ab4f8; /* Светло-синий для темной темы */
    border-bottom-color: #8ab4f8;
    background: rgba(138, 180, 248, 0.2);
}
.dark .sub-block a[href^="http"]:hover {
    background-color: #8ab4f8;
    color: #202124;
}
.sub-block a:not([href^="http"]):not([href^="mailto"]) {
    color: #0b8043; /* Зеленый цвет */
    border-bottom-color: #0b8043;
    background: rgba(11, 128, 67, 0.1);
    padding: 2px 4px 2px 22px;
    position: relative;
}
.sub-block a:not([href^="http"]):not([href^="mailto"]):hover {
    background-color: #0b8043;
    color: white;
}
.dark .sub-block a:not([href^="http"]):not([href^="mailto"]) {
    color: #81c995; /* Светло-зеленый для темной темы */
    border-bottom-color: #81c995;
    background: rgba(129, 201, 149, 0.2);
}
.dark .sub-block a:not([href^="http"]):not([href^="mailto"]):hover {
    background-color: #81c995;
    color: #202124;
}
.sub-blocks.horizontal {
    margin-top: 0;
    margin-left: 15px;
    padding-left: 0;
    padding-top: 12px;
    border-left: none;
    border-top: 2px solid var(--primary-color);
    display: flex;
    flex-wrap: wrap;
    gap: 12px;
    max-width: 450px;
min-width: 160px !important; 
font-size: 1.3rem !important;
min-width: 160px;
}

.sub-block {
    position: relative;
    background: rgba(255, 160, 122, 0.08);
    border: 1px solid var(--primary-color);
    border-radius: 8px;
    padding: 16px 20px !important;
    margin: 8px 0;
    font-size: 2rem  !important; 
    transition: all 0.3s;
    display: flex;
    justify-content: space-between;
    align-items: center;
    box-shadow: 0 2px 4px rgba(0, 0, 0, 0.05);
   min-width: 200px;  
    max-width: 100%;
    line-height: 1.7 !important; 
    /* Add subtle glow */
  box-shadow: 0 2px 4px rgba(0, 0, 0, 0.05), 0 0 5px rgba(93, 138, 168, 0.1);
}
.compact-children {
    margin: 0 !important;
    padding: 0 !important;
}
.compact-children .node {
    margin: 5px !important;
}
.sub-block.horizontal {
    flex-direction: column;
    min-width: 220px !important;
    max-width: 250px !important; 
    margin: 0;
    padding: 14px !important;
    text-align: left;
    line-height: 1.4;
font-size: 1.7rem !important;
}
.sub-block span {
    flex: 1;
    hyphens: auto;
    text-align: left;
    padding-right: 8px;
}
.sub-block.horizontal span {
    text-align: left;
    padding-right: 0;
    padding-bottom: 8px;
}
.sub-block:hover {
    transform: translateX(8px);
    background: rgba(255, 160, 122, 0.12);
    border-color: var(--secondary-color);
    /* Enhanced glow on hover */
    box-shadow: 0 0 10px rgba(255, 160, 122, 0.2);
}
.sub-block.horizontal:hover {
    transform: translateY(5px);
}
.sub-block::before {
    content: '';
    position: absolute;
    left: -12px;
    top: 50%;
    transform: translateY(-50%);
    width: 6px;
    height: 6px;
    background: var(--accent-color);
    border-radius: 50%;
}
.sub-block.horizontal::before {
    left: 50%;
    top: -12px;
    transform: translateX(-50%);
}
.sub-block-actions {
    display: flex;
    gap: 8px;
    opacity: 0.7;
}
.sub-block-actions span {
font-size: 1.3rem !important;
    cursor: pointer;
    padding: 4px !important;
    transition: all 0.2s;
}
.sub-block-actions span:hover {
    opacity: 1;
    transform: scale(1.1);
}
.add-sub-block {
    margin-top: 10px;
    padding: 6px;
    border: 1px dashed var(--primary-color);
    border-radius: 6px;
    text-align: center;
    cursor: pointer;
    transition: all 0.3s;
}
.add-sub-block.horizontal {
    margin-top: 5px;
    margin-left: 15px;
}
.node-content.subordinate + .children .node {
    margin: 0 8px; /* Меньший отступ для подчиненных */
}
.node.horizontal .node-content.subordinate + .children .node {
    margin: 8px 0;
}
.node-content.subordinate + .children {
    gap: 15px;
padding-top: 25px;
}
.node.horizontal .node-content.subordinate + .children {
    gap: 10px;
}
.add-sub-block:hover {
    border-style: solid;
    background: rgba(255, 160, 122, 0.05);
}
.notification {
    position: fixed;
    bottom: 20px;
    right: 20px;
    background: var(--controls-bg);
    padding: 15px 25px;
    border-radius: 12px;
    box-shadow: 0 4px 15px rgba(0,0,0,0.2);
    color: var(--text-color);
    font-size: 14px;
    z-index: 2000;
    animation: slideIn 0.3s ease-out;
}
.node-textarea {
    width: 100%;
    min-height: 80px;
    text-align: center;
    border: none;
    background: transparent;
    font: inherit;
    color: var(--text-color);
   outline: 2px solid var(--secondary-color);
padding: 8px;
border-radius: 5px;
resize: vertical;
box-sizing: border-box;
}
.node-type-selector {
position: absolute;
top: 5px;
right: 5px;
display: flex;
gap: 5px;
}
.node-type-btn {
width: 24px;
height: 24px;
border-radius: 4px;
background: var(--primary-color);
color: white;
display: flex;
align-items: center;
justify-content: center;
cursor: pointer;
font-size: 12px;
transition: all 0.2s;
}
.node-type-btn:hover {
background: var(--secondary-color);
transform: scale(1.1);
}
.node-type-btn.active {
background: var(--accent-color);
box-shadow: 0 0 5px rgba(255, 160, 122, 0.8);
}
.horizontal-connector {
position: absolute;
width: 30px;
height: 2px;
background: linear-gradient(to right, var(--primary-color), #7BA7CC);
left: -30px;
top: 50%;
transform: translateY(-50%);
transition: all 0.3s;
}
.node-title {
    min-height: 32px;
    padding: 4px 8px;
font-weight: bold;
margin-bottom: 5px;
cursor: text;
text-align: center;
color: var(--primary-color);
font-size: 1.8rem !important; 
  line-height: 1.6 !important;
    white-space: normal;
    max-width: 100%;
}
.node-title.horizontal {
    text-align: left;
    margin-bottom: 0;
    margin-right: 10px;
    white-space: normal;
    max-width: 350px;
    font-size: 1.8rem !important;
    line-height: 1.4 !important;
}
.node-title-input {
    width: 100%;
    border: 2px solid var(--secondary-color) !important;
    border-radius: 8px;
    padding: 8px 12px;
    font: inherit;
    color: var(--text-color);
    background: rgba(255, 255, 255, 0.1);
    box-shadow: inset 0 1px 3px rgba(0, 0, 0, 0.1);
    resize: vertical;
    overflow-y: auto;
    white-space: pre-wrap;
    outline: none;
    transition: all 0.3s ease;
}
.node-title-input:focus {
    border-color: var(--accent-color) !important;
    box-shadow: 0 0 10px rgba(255, 160, 122, 0.5);
    background: rgba(255, 255, 255, 0.2);
}
.node-content.subordinate .node-title-input {
    border-style: dashed !important;
    background: rgba(135, 206, 235, 0.1) !important;
}
.node-title-input.horizontal {
    text-align: left;
    margin-right: 10px;
}
.node-content.power-269 {
  border: 3px dashed #9E9E9E;
  background: linear-gradient(145deg, rgba(158, 158, 158, 0.05), var(--node-bg)) !important;
  position: relative;
  animation: none;
   border-width: 4px !important;
    border-style: solid !important;
}
.node-content.power-269::after {
    content: "Полномочие из 269-П";
    position: absolute;
    bottom: -22px;
    right: 10px;
     font-size: 1.4em;
    background: #9E9E9E;  /* Серый фон */
    color: white;
    padding: 4px 8px;
    border-radius: 6px;
    font-weight: 600;
    letter-spacing: 0.5px;
    box-shadow: 0 2px 4px rgba(0, 0, 0, 0.2);
    white-space: nowrap;
    z-index: 10;
    text-transform: uppercase;
    font-family: 'Segoe UI', Arial, sans-serif;
border: 1px solid rgba(255,255,255,0.3); 
}
.node-header {
    display: flex;
    align-items: center;
    margin-bottom: 10px;
    width: 100%; /* Ensure it takes full width */
    flex-wrap: wrap; /* Allow wrapping for long content */
}
.node-header.horizontal {
    flex-direction: row;
    margin-bottom: 0;
    flex-wrap: nowrap; /* Keep it in one line */
    max-width: 100%; /* Ensure it doesn't overflow */
}
.firework {
  position: fixed;
  top: 0;
  left: 0;
  width: 100%;
  height: 100%;
  pointer-events: none;
  z-index: 9999;
}
.firework-particle {
  position: absolute;
  width: 5px;
  height: 5px;
  border-radius: 50%;
  box-shadow: 0 0 6px 2px currentColor;
  animation: firework-explode 1s ease-out forwards;
}
@keyframes firework-explode {
  0% {
    transform: translate(0, 0);
    opacity: 1;
  }
  100% {
    transform: translate(var(--tx), var(--ty));
    opacity: 0;
  }
}
.theme-transition-overlay {
  position: fixed;
  top: 0;
  left: 0;
  width: 100%;
  height: 100%;
  background: radial-gradient(circle at var(--x) var(--y), 
              rgba(255, 255, 255, 0.8) 0%, 
              rgba(255, 255, 255, 0) 70%);
  opacity: 0;
  pointer-events: none;
  z-index: 9998;
  transition: opacity 0.5s ease-out;
}
.dark .theme-transition-overlay {
  background: radial-gradient(circle at var(--x) var(--y), 
              rgba(93, 138, 168, 0.8) 0%, 
              rgba(93, 138, 168, 0) 70%);
}
.theme-transition-overlay.active {
  animation: flash 0.8s ease-out forwards;
}
        .search-container {
            position: relative;
            display: inline-block;
 }     
        .autocomplete-suggestions {
            position: absolute;
            top: 100%;
            left: 0;
            right: 0;
            z-index: 1000;
            max-height: 200px;
            overflow-y: auto;
            background: var(--controls-bg);
            border: 1px solid var(--primary-color);
            border-radius: 0 0 8px 8px;
            box-shadow: 0 4px 8px rgba(0,0,0,0.2);
            display: none;
        }
        .autocomplete-suggestion {
            padding: 8px 12px;
            cursor: pointer;
            transition: background 0.2s;
        } 
        .autocomplete-suggestion:hover {
            background: rgba(93, 138, 168, 0.1);
        }   
        .autocomplete-suggestion strong {
            color: var(--accent-color);
            font-weight: bold;
        }
        .search-match-highlight {
            background-color: rgba(255, 160, 122, 0.3);
            border-radius: 3px;
            padding: 0 2px;
        }
.node-content.absent-269 {
  border: 3px dashed #9370D8;
  background: linear-gradient(145deg, rgba(255,68,68,0.05), var(--node-bg)) !important;
  position: relative;
  animation: none; 
    border-width: 4px !important;
    border-style: solid !important;
}
.node-content.absent-269::after {
    content: "Нет в 269-П";
    position: absolute;
    bottom: -22px;
    right: 10px;
    font-size: 1.4em;
    background: #9370D8;  
    color: white;
    padding: 4px 8px;
    border-radius: 6px;
    font-weight: 500;
    letter-spacing: 0.5px;
    box-shadow: 0 2px 4px rgba(0, 0, 0, 0.2);
    white-space: nowrap;
    z-index: 10;
    text-transform: uppercase;
    font-family: 'Segoe UI', Arial, sans-serif;
}
.node-content.for-all-node {
  border: 3px dashed #4CAF50;
  background: linear-gradient(145deg, rgba(76,175,80,0.05), var(--node-bg)) !important;
  animation: none;
 border-width: 4px !important;
    border-style: solid !important;
}
.node-content.for-all-node::after {
content: "Для всех сотрудников";
    position: absolute;
    bottom: -22px;
    right: 10px;
    font-size: 1.4em;
    background: #4CAF50;  
    color: white;
    padding: 4px 8px;
    border-radius: 6px;
    font-weight: 500;
    letter-spacing: 0.5px;
    box-shadow: 0 2px 4px rgba(0, 0, 0, 0.2);
    white-space: nowrap;
    z-index: 10;
    text-transform: uppercase;
    font-family: 'Segoe UI', Arial, sans-serif;
}
.node-content.dragging {
    opacity: 0.5;
    transform: rotate(2deg);
    box-shadow: 0 5px 15px rgba(0,0,0,0.3);
}
.node-content.subordinate-node {
  border: 3px dashed #191970 !important;
  background: linear-gradient(145deg, rgba(123,167,204,0.05), var(--node-bg)) !important;
  animation: none;
    border-width: 4px !important;
    border-style: solid !important;
}
.node-content.subordinate-node::after {
    content: "Должностные регламенты";
    position: absolute;
    bottom: -22px;
    right: 10px;
    font-size: 1.4em;
    background: #191970;
    color: white;
    padding: 4px 8px;
    border-radius: 6px;
    font-weight: 600;
    letter-spacing: 0.5px;
    box-shadow: 0 3px 6px rgba(0,0,0,0.2);
    white-space: nowrap;
    z-index: 1000;
    text-transform: uppercase;
    font-family: 'Segoe UI', Arial, sans-serif;
    transform: translateY(100%); 
    min-width: 200px; 
    text-align: center;
}
.node-content.authority-node {
  border: 3px dashed #D2B48C;
  background: linear-gradient(145deg, rgba(210, 180, 140, 0.1), var(--node-bg)) !important;
  position: relative;
  animation: none;
  border-width: 4px !important;
  border-style: solid !important;
}
.node-content.authority-node::after {
  content: "Идентичное полномочие";
  position: absolute;
  bottom: -22px;
  right: 10px;
  font-size: 1.4em;
  background: #D2B48C;
  color: white;
  padding: 4px 8px;
  border-radius: 6px;
  font-weight: 500;
  letter-spacing: 0.5px;
  box-shadow: 0 2px 4px rgba(0, 0, 0, 0.2);
  white-space: nowrap;
  z-index: 10;
  text-transform: uppercase;
  font-family: 'Segoe UI', Arial, sans-serif;
transform: translateY(100%);
}
.node-content.okr-node {
  border: 3px dashed #FFA500 !important;
  background: linear-gradient(145deg, rgba(255, 165, 0, 0.1), var(--node-bg)) !important;
  position: relative;
  animation: none;
  border-width: 4px !important;
  border-style: solid !important;
}
.node-content.okr-node::after {
  content: "OKR (Цели и ключевые результаты)";
  position: absolute;
  bottom: -22px;
  right: 10px;
  font-size: 1.4em;
  background: #FFA500;
  color: white;
  padding: 4px 8px;
  border-radius: 6px;
  font-weight: 500;
  letter-spacing: 0.5px;
  box-shadow: 0 2px 4px rgba(0, 0, 0, 0.2);
  white-space: nowrap;
  z-index: 10;
  text-transform: uppercase;
  font-family: 'Segoe UI', Arial, sans-serif;
  transform: translateY(100%);
}
.dark .node-content.okr-node::after {
  background: #FF8C00;
}
.node-content.indicator-node {
  border: 3px dashed #00BFFF;
  background: linear-gradient(145deg, rgba(0, 191, 255, 0.1), var(--node-bg)) !important;
  position: relative;
  animation: none;
  border-width: 12px !important;
  border-style: solid !important;
    min-width: 3000px !important;
    max-width: 3500px !important;
    padding: 35px 45px !important;
}
.node-content.indicator-node::after {
  content: "Государственная программа";
  position: absolute;
  bottom: -22px;
  right: 10px;
  font-size: 2rem !important;
  background: #00BFFF !important;
  color: white;
  padding: 8px 15px !important;
  border-radius: 6px;
  font-weight: 500;
  letter-spacing: 0.5px;
  box-shadow: 0 2px 4px rgba(0, 0, 0, 0.2);
  white-space: nowrap;
  z-index: 10;
  text-transform: uppercase;
  font-family: 'Segoe UI', Arial, sans-serif;
  transform: translateY(100%);
}

.node-content.horizontal.indicator-node::after {
  right: auto;
  left: 10px;
}
.drop-indicator {
    height: 3px;
    background: var(--primary-color);
    border-radius: 2px;
    position: absolute;
    z-index: 1000;
    box-shadow: 0 0 5px rgba(0, 123, 255, 0.5);
}
.drop-indicator.child-indicator {
    background: var(--secondary-color);
    height: 2px;
    border: 1px dashed var(--secondary-color);
    background: rgba(135, 206, 235, 0.3);
}
.node-content[draggable="true"] {
    cursor: grab;
}
.node-content[draggable="true"]:hover {
    cursor: grab;
}
.node-content.dragging {
    cursor: grabbing !important;
    opacity: 0.7;
}
.node-content:active {
    cursor: grabbing;
}
.node.grid-layout .children.grid-children {
    display: grid;
    grid-template-columns: repeat(5, 1fr);
    gap: 20px;
    margin-top: 30px;
    padding: 20px;
    background: rgba(var(--primary-color-rgb), 0.05);
    border-radius: 15px;
    border: 2px dashed rgba(var(--primary-color-rgb), 0.3);
}
.node.grid-layout .children.grid-children.collapsed {
    display: none;
}
.grid-connector {
    position: relative;
    height: 20px;
    margin-bottom: 10px;
}
.grid-connector::before {
    content: '';
    position: absolute;
    top: 0;
    left: 50%;
    width: 2px;
    height: 20px;
    background: var(--primary-color);
    transform: translateX(-50%);
}
.grid-connector.grid-row-0::after {
    content: '';
    position: absolute;
    top: -30px;
    left: 50%;
    width: 2px;
    height: 30px;
    background: var(--primary-color);
    transform: translateX(-50%);
}
/* Горизонтальная линия для соединения узлов в первом ряду */
.node.grid-layout .children.grid-children::before {
    content: '';
    position: absolute;
    top: -10px;
    left: 16.66%;
    right: 16.66%;
    height: 2px;
    background: var(--primary-color);
    z-index: 1;
}
.node.grid-layout .children.grid-children::after {
    content: '';
    position: absolute;
    top: -40px;
    left: 50%;
    width: 2px;
    height: 30px;
    background: var(--primary-color);
    transform: translateX(-50%);
    z-index: 1;
}
.node {
  will-change: transform, opacity; /* Оптимизация для браузера */
  contain: content; /* Улучшает производительность */
  transform: translateZ(0);
}
.children.vertical-scroll {
    display: flex;
    flex-direction: column;
    gap: 15px;
    padding: 10px;
    height: 700px; /* Увеличили высоту */
    overflow-y: auto;
    border: 1px solid var(--primary-color);
    border-radius: 8px;
    background: rgba(var(--primary-color-rgb), 0.05);
}

.tree-container {
  overflow-anchor: none;
  backface-visibility: hidden;
}


.cluster-controls select {
    padding: 6px 8px !important;
    font-size: 0.9em !important;
    min-width: 120px !important;
}


.cluster-controls button:hover {
    background: var(--secondary-color);
    transform: scale(1.05);
}

.dragging {
    opacity: 0.5;
    background: var(--accent-color) !important;
    color: white !important;
}

.select-option span[title="Редактировать название"] {
    color: var(--primary-color) !important;
    opacity: 0.7;
    transition: all 0.2s;
}

.select-option span[title="Редактировать название"]:hover {
    opacity: 1;
    transform: scale(1.1);
}
.select-option-btn {
  color: var(--accent-color);
  cursor: pointer;
  font-size: 0.9em;
  border: none;
  background: transparent;
  padding: 2px 6px;
  transition: color 0.2s ease;
}

.select-option-btn:hover {
  color: var(--primary-color);
}
.select-dropdown .select-option {
  font-size: 0.85em;
  padding: 6px 8px;
  cursor: pointer;
  display: flex;
  justify-content: space-between;
  align-items: center;
}
#clusterOrderList li {
    transition: transform 0.2s, background 0.2s;
}

#clusterOrderList li:hover {
    background: rgba(93, 138, 168, 0.2) !important;
}

.children.grid-3-col {
    display: grid;
    grid-template-columns: repeat(3, 1fr);
    gap: 20px;
    padding: 10px;
}
.metric-container {
    border: 2px solid var(--primary-color);
    border-radius: 8px;
    padding: 10px !important; /* Уменьшили padding */
    margin: 10px 0 !important; /* Уменьшили отступы */
    background: rgba(93, 138, 168, 0.1);
    width: 100%;
    box-sizing: border-box;
    overflow: hidden;
}
.node-content.horizontal .metric-container {
    max-width: 100% !important;
    margin: 5px 0 !important; /* Уменьшили отступы */
    padding: 8px !important; /* Уменьшили padding */
}
.node-content:not(.horizontal) .metric-container {
    width: calc(100% - 20px);
}
.quarters-container {
    display: flex;
    gap: 5px;
    margin-top: 10px;
    flex-wrap: wrap;
    justify-content: space-between;
}

.quarter-block {
    flex: 1;
    min-width: 120px;
    display: flex;
    flex-direction: column;
    align-items: center;
    padding: 5px;
    border: 1px solid var(--secondary-color);
    border-radius: 6px;
    position: relative;
}

.quarter-value {
    font-size: 2.4rem !important; /* Увеличен с 1.2rem */
    padding: 12px !important; /* Увеличен padding */
    width: 120px; /* Увеличенная ширина для больших цифр */
    text-align: center;
    margin: 5px 0;
    border: 1px solid var(--primary-color);
    border-radius: 4px;
    background: var(--controls-bg);
    color: var(--text-color);
}

.files-list {
    margin-top: 5px;
    max-height: 100px;
    overflow-y: auto;
}

.file-item {
    cursor: pointer;
    padding: 2px 5px;
    margin: 2px 0;
    border-radius: 3px;
    background: rgba(93, 138, 168, 0.1);
}

.file-item:hover {
    background: rgba(93, 138, 168, 0.2);
}

.add-file-btn {
    background: none;
    border: none;
    cursor: pointer;
    font-size: 1.2em;
    margin-top: 5px;
}

.metric-title {
    width: 100%;
    padding: 10px 12px !important;
    border: 1px solid var(--primary-color);
    border-radius: 4px;
    margin-bottom: 5px;
    font-weight: bold;
    font-size: 1.8rem !important;
}
.quarter-label {
     font-size: 2.2rem !important; /* Увеличен с 1.2rem */
    margin-bottom: 12px; /* Добавлен отступ */
}

.quarter-diff {
    font-size: 2.2rem !important;  /* Увеличен с 1.1rem */
    margin: 8px 0; /* Увеличен отступ */
    font-weight: bold;
}
.delete-metric-btn {
    font-size: 1rem !important;
    padding: 6px 10px !important;
}
.delete-metric-btn {
    background: linear-gradient(145deg, #ff4444, #d32f2f);
    color: white;
    border: none;
    border-radius: 6px;
    padding: 6px 12px;
    cursor: pointer;
    transition: all 0.3s;
    font-size: 0.9em;
    margin-top: 10px;
    display: block;
    width: 100%;
    text-align: center;
}

.delete-metric-btn:hover {
    background: linear-gradient(145deg, #d32f2f, #ff4444);
    transform: translateY(-2px);
   }
.metric-type-select {
    padding: 5px;
    border-radius: 4px;
    border: 1px solid var(--primary-color);
    background: var(--controls-bg);
    color: var(--text-color);
    margin-right: 10px;
    cursor: pointer;
}


.quarter-diff {
    font-size: 0.9em;
    margin: 5px 0;
    font-weight: bold;
}
.result-block {
    margin-top: 20px;
    padding: 15px;
    background: rgba(76, 175, 80, 0.1);
    border: 2px solid #4CAF50;
    border-radius: 8px;
    position: relative;
}

.result-block::before {
    content: "✓";
    position: absolute;
    left: -12px;
    top: -12px;
    width: 40px;  /* Увеличено с 24px */
    height: 40px;  /* Увеличено с 24px */
    background: #4CAF50;
    color: white;
    border-radius: 50%;
    display: flex;
    align-items: center;
    justify-content: center;
    font-size: 20px;  /* Увеличено с 16px */
}

.result-title {
    font-weight: bold;
    margin-bottom: 8px;
    color: #2E7D32;
    font-size: 3rem !important;  /* Добавлено увеличение размера */
}

.result-text {
    white-space: pre-wrap;
    line-height: 1.5;
    font-size: 3rem  !important;  /* Добавлено увеличение размера */
    min-height: 50px;
    cursor: pointer;
}

.quarters-container {
    display: flex;
    gap: 10px;
    margin-top: 10px;
}

.quarter-block {
    flex: 1;
    display: flex;
    flex-direction: column;
    align-items: center;
    padding: 10px;
    border: 1px solid var(--secondary-color);
    border-radius: 6px;
    position: relative;
}
.files-list {
    margin-top: 5px;
    max-height: 100px;
    overflow-y: auto;
}

.file-item {
    cursor: pointer;
    padding: 2px 5px;
    margin: 2px 0;
    border-radius: 3px;
    background: rgba(93, 138, 168, 0.1);
}

.file-item:hover {
    background: rgba(93, 138, 168, 0.2);
}

.add-file-btn {
    background: none;
    border: none;
    cursor: pointer;
    font-size: 1.2em;
    margin-top: 5px;
}

.delete-metric-btn {
    background: linear-gradient(145deg, #ff4444, #d32f2f);
    color: white;
    border: none;
    border-radius: 6px;
    padding: 6px 12px;
    cursor: pointer;
    transition: all 0.3s;
    font-size: 0.9em;
    margin-top: 10px;
    display: block;
    width: 100%;
    text-align: center;
}
.delete-metric-btn:hover {
    background: linear-gradient(145deg, #d32f2f, #ff4444);
    transform: translateY(-2px);
   }
.metric-type-select {
    padding: 5px;
    border-radius: 4px;
    border: 1px solid var(--primary-color);
    background: var(--controls-bg);
    color: var(--text-color);
    margin-right: 10px;
    cursor: pointer;
}

.plan-value {
    border-color: #4CAF50;
}
.fact-value {
    border-color: #2196F3;
}
.quarter-diff {
    font-size: 0.9em;
    margin: 5px 0;
    font-weight: bold;
}
.gantt-chart {
    width: 100%;
    margin-top: 5px;
    height: 10px;
}
.gantt-container {
    height: 30px; 
    background: rgba(93, 138, 168, 0.1);
    border-radius: 10px;
     margin-top: 16px;
    overflow: hidden;
    position: relative;
    width: 100%;
}

.gantt-bar {
    height: 100%;
    width: 100%;
    background: rgba(93, 138, 168, 0.2);
        position: relative;
    border-radius: 10px;
}
.gantt-progress {
    height: 100%;
    background: var(--primary-color);
    position: absolute;
    left: 0;
    top: 0;
    transition: width 0.3s ease;
}
.plan-bar {
    background: rgba(76, 175, 80, 0.3); /* Зеленый для плана */
}

.fact-bar {
    background: var(--primary-color); /* Основной цвет для факта */
}
/* Для темной темы */
.dark .gantt-bar {
    background: rgba(255, 255, 255, 0.1);
}

.dark .gantt-progress {
    background: var(--secondary-color);
}
.indicators-container {
    padding: 10px 12px !important;
    margin-top: 8px;
    background: rgba(93, 138, 168, 0.05);
    border-radius: 8px;
    border: 1px solid var(--primary-color);
    width: 100%;
    overflow-x: auto;
}

/* Очень крупный шрифт для названия таблицы */
.indicators-title {
    font-size: 3rem !important;
    margin-bottom: 15px !important;
    font-weight: 800;
    letter-spacing: 0.5px;
}

.indicators-table {
    width: auto;
    min-width: 100%;
    border-collapse: separate;
    border-spacing: 6px;
    margin: 0;
    table-layout: auto;
}

/* Очень крупный шрифт для названий показателей */
.indicators-table td:first-child {
    font-size: 2.8rem !important;
    font-weight: 700;
    padding: 12px 16px !important;
    text-align: left;
    white-space: nowrap;
    background: rgba(93, 138, 168, 0.15);
}

/* Максимально крупные числовые значения */
.indicators-table td {
    font-size: 2.6rem !important;
    padding: 12px 16px !important;
    text-align: center;
    border: 1px solid var(--secondary-color);
    min-width: 70px;
    max-width: 140px;
    line-height: 1.4;
    font-weight: 600;
}

/* Крупные заголовки столбцов */
.indicators-table th {
    position: sticky;
    top: 0;
    background: var(--primary-color);
    color: white;
    font-size: 2.4rem !important;
    padding: 12px !important;
    white-space: nowrap;
    font-weight: 700;
}

/* Очень крупные значения в инпутах */
.indicator-value {
    width: 100% !important;
    height: 40px !important;
    padding: 6px 8px !important;
    font-size: 2.6rem !important;
    margin: 0;
    box-sizing: border-box;
    font-weight: 600;
}

/* Стили для метрик - максимально крупные */
.indicator-metrics {
    margin-top: 16px;
    padding: 16px !important;
}

.metrics-title {
    font-size: 3rem !important;
    margin-bottom: 12px !important;
    font-weight: 800;
}

.metric-item {
    font-size: 2.8rem !important;
    padding: 18px 24px !important;
    margin: 8px 0 !important;
    background: rgba(93, 138, 168, 0.1);
    border-radius: 8px;
    display: flex;
    justify-content: space-between;
    align-items: center;
    font-weight: 600;
}
.add-metric-btn {
    padding: 12px 16px !important;
    font-size: 2.4rem !important;
    margin-top: 12px !important;
    font-weight: 700;
}
.metric-item button {
    transition: transform 0.2s;
}

.metric-item button:hover {
    transform: scale(1.2);
}
.department-management {
    position: fixed;
    top: 50%;
    left: 50%;
    transform: translate(-50%, -50%);
    width: 80vw;
    height: 80vh;
    background: var(--controls-bg);
    border-radius: 15px;
    box-shadow: 0 0 30px rgba(0,0,0,0.3);
    z-index: 2000;
    display: none;
    flex-direction: column;
    padding: 20px;
}
.deputies-list {
  display: flex;
  gap: 12px;
  margin-top: 12px;
  flex-wrap: wrap;          
  align-items: flex-start;  
}
.deputy-card {
  cursor: pointer;
  padding: 10px 15px;
  border: 2px solid var(--primary-color);
  border-radius: 10px;
  width: 300px;
max-width: 300px;             
  flex: 0 0 auto;           
  white-space: nowrap;      
  overflow: visible;        
  text-overflow: ellipsis;  
  text-align: clip;
  user-select: none;
  transition: background-color 0.2s ease;
  box-sizing: border-box;   /* Чтобы padding входил в ширину */
}
.deputy-card:hover {
  background-color: var(--primary-color-light);
}
.department-header {
    display: flex;
    justify-content: space-between;
    align-items: center;
    margin-bottom: 15px;
    flex-direction: row; /* Изменено с column на row */
}

.department-container {
    display: flex;
    flex: 1;
    gap: 20px;
}

.department-column {
    flex: 1;
    border: 2px solid var(--primary-color);
    border-radius: 10px;
    padding: 15px;
    overflow-y: auto;
}

.department-group {
    margin-bottom: 15px;
    padding: 10px;
    background: rgba(93, 138, 168, 0.1);
    border-radius: 8px;
    cursor: move;
}

.department-item {
    padding: 8px;
    margin: 5px 0;
    background: rgba(255,255,255,0.1);
    border-radius: 5px;
    cursor: move;
}

.department-item:hover {
    background: rgba(255,255,255,0.2);
}
.department-management {
  width: 95vw;
  height: 95vh;
  overflow: auto;
}

.department-column {
    min-width: 300px; /* Увеличено с 250px */
    padding: 15px; /* Увеличено с 8px */
}


.department-group {
    padding: 10px; /* Увеличено с 5px */
    margin-bottom: 10px; /* Увеличено с 5px */
    min-width: 280px; /* Добавлено */
}
.department-item {
    padding: 5px 8px; /* Увеличено с 3px 5px */
    font-size: 0.95em; /* Увеличено с 0.9em */
    white-space: nowrap;
    overflow: hidden;
    text-overflow: ellipsis;
    max-width: 280px; /* Добавлено */
}

/* Кнопки управления */
.management-controls {
  position: static;
  top: 10px;
  right: 10px;
  display: flex;
  gap: 5px;
}

.compact-toggle {
  padding: 5px 10px;
  background: var(--primary-color);
  color: white;
  border: none;
  border-radius: 4px;
  cursor: pointer;
}

.node-content.horizontal .indicators-container {
    padding: 10px 12px !important;
    max-width: 100%;
}

.node-content.horizontal .indicators-table {
    min-width: auto !important;
}

.node-content.horizontal .indicator-value {
    height: 36px !important;
    font-size: 2.4rem !important;
    padding: 4px 6px !important;
}

/* Темная тема */
.dark .indicators-table th {
    background: var(--secondary-color);
}

.dark .indicators-table td {
    background: rgba(30, 40, 50, 0.7);
}

/* Полоса прокрутки */
.indicators-container::-webkit-scrollbar {
    height: 8px;
}

.indicators-container::-webkit-scrollbar-thumb {
    background: var(--primary-color);
    border-radius: 4px;
}

/* Заголовки годов */
.indicators-table th:not(:first-child) {
    font-size: 2rem !important;
    padding: 8px 6px !important;
}
@media (max-width: 768px) {
    .node.grid-layout .children.grid-children {
        grid-template-columns: repeat(2, 1fr);
        gap: 15px;
        padding: 15px;
    }
    
    .node.grid-layout .children.grid-children::before {
        left: 25%;
        right: 25%;
    }
}

@media (max-width: 480px) {
    .node.grid-layout .children.grid-children {
        grid-template-columns: 1fr;
        gap: 10px;
        padding: 10px;
    }
    
    .node.grid-layout .children.grid-children::before {
        display: none;
    }
}

/* Темная тема для сеточного расположения */
.dark .node.grid-layout .children.grid-children {
    background: rgba(255, 255, 255, 0.05);
    border-color: rgba(255, 255, 255, 0.2);
}

/* Анимации для сеточного расположения */
.node.grid-layout .children.grid-children > .node {
    animation: gridFadeIn 0.5s ease-out forwards;
    opacity: 0;
    transform: translateY(20px);
}
.node.grid-layout .children.grid-children > .node:nth-child(1) { animation-delay: 0.1s; }
.node.grid-layout .children.grid-children > .node:nth-child(2) { animation-delay: 0.2s; }
.node.grid-layout .children.grid-children > .node:nth-child(3) { animation-delay: 0.3s; }
.node.grid-layout .children.grid-children > .node:nth-child(4) { animation-delay: 0.4s; }
.node.grid-layout .children.grid-children > .node:nth-child(5) { animation-delay: 0.5s; }
.node.grid-layout .children.grid-children > .node:nth-child(6) { animation-delay: 0.6s; }

@keyframes gridFadeIn {
    to {
        opacity: 1;
        transform: translateY(0);
    }
}
.tooltip {
  opacity: 0;
  transition: opacity 0.15s ease-in-out;
  pointer-events: none;
  position: absolute;
  background: var(--controls-bg);
  border: 1px solid var(--primary-color);
  padding: 5px 10px;
  border-radius: 4px;
  z-index: 10000;
  max-width: 400px;
  word-wrap: break-word;
  display: block; /* Чтобы элемент занимал место, но был прозрачным */
}

.tooltip.visible {
  opacity: 1;
  pointer-events: auto;
}
.node-content.organizational-event-node {
    border-color: var(--primary-color) !important; /* Возвращаем стандартную рамку */
    background: var(--node-bg) !important; /* Возвращаем стандартный фон */
}

/* Убираем старую текстовую метку внизу, она нам больше не нужна */
.node-content.organizational-event-node::after {
    content: none !important;
}

.node-content.organizational-event-node::before {
    content: '✧'; /* Изящная бесцветная звёздочка (Unicode: U+2727) */
    position: absolute;
    top: 10px;
    left: 15px;
    font-size: 2.5em; /* Делаем её заметной */
    color: var(--text-color); /* Используем основной цвет текста, чтобы она вписывалась в тему */
    opacity: 0.6; /* Немного прозрачности для элегантности */
    z-index: 1;
   }
.node-action-btn.promote-delete-btn {
    font-size: 40px;
    background: linear-gradient(145deg, #FFA500, #FF8C00); /* Оранжевый градиент */
}
</style>
<script src="https://cdn.jsdelivr.net/npm/three@0.132.2/build/three.min.js"></script>
<script>
class NodeEffects {
  constructor() {
    this.activeNodes = new Map();
    this.renderer = null;
    this.scene = null;
    this.camera = null;
    this.initThreeJS();
  }

  initThreeJS() {
    this.renderer = new THREE.WebGLRenderer({ alpha: true });
    this.renderer.setSize(1, 1); // Минимальный размер
    this.renderer.domElement.style.position = 'fixed';
    this.renderer.domElement.style.top = '0';
    this.renderer.domElement.style.pointerEvents = 'none';
    this.renderer.domElement.style.zIndex = '9999';
    document.body.appendChild(this.renderer.domElement);

    this.scene = new THREE.Scene();
    this.camera = new THREE.PerspectiveCamera(75, 1, 0.1, 1000);
    this.camera.position.z = 5;

    this.animate();
  }

  animate() {
    requestAnimationFrame(() => this.animate());
    
    // Обновляем только активные эффекты
    this.activeNodes.forEach(effect => {
      effect.uniforms.time.value += 0.01;
    });
    
    this.renderer.render(this.scene, this.camera);
  }

  addEffect(element, type) {
    if (this.activeNodes.has(element)) return;

    const rect = element.getBoundingClientRect();
    const effect = {
      type,
      mesh: this.createEffectMesh(type),
      uniforms: {
        time: { value: 0 },
        color: { value: new THREE.Color() }
      }
    };

    // Устанавливаем цвет в зависимости от типа
    switch(type) {
      case 'absent269':
        effect.uniforms.color.value.setHex(0xff4444);
        break;
      case 'forAll':
        effect.uniforms.color.value.setHex(0x4CAF50);
        break;
      case 'subordinate':
        effect.uniforms.color.value.setHex(0x191970);
        break;
case 'power269':
    effect.uniforms.color.value.setHex(0x9E9E9E);
    break;
    }

    effect.mesh.position.set(
      (rect.left + rect.width/2) / 50 - window.innerWidth/100,
      -(rect.top + rect.height/2) / 50 + window.innerHeight/100,
      0
    );

    this.scene.add(effect.mesh);
    this.activeNodes.set(element, effect);
  }

  removeEffect(element) {
    if (!this.activeNodes.has(element)) return;
    
    const effect = this.activeNodes.get(element);
    this.scene.remove(effect.mesh);
    this.activeNodes.delete(element);
  }

  createEffectMesh(type) {
    const geometry = new THREE.PlaneGeometry(2, 2);
    const material = new THREE.ShaderMaterial({
      uniforms: this.uniforms,
      vertexShader: `
        varying vec2 vUv;
        void main() {
          vUv = uv;
          gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
        }
      `,
      fragmentShader: `
        uniform float time;
        uniform vec3 color;
        varying vec2 vUv;
        
        void main() {
          float pulse = sin(time * 3.0) * 0.1 + 0.9;
          float dist = distance(vUv, vec2(0.5));
          float glow = smoothstep(0.5, 0.2, dist) * pulse;
          
          gl_FragColor = vec4(color * glow, glow * 0.3);
        }
      `,
      transparent: true,
      blending: THREE.AdditiveBlending
    });

    return new THREE.Mesh(geometry, material);
  }
}

// Инициализируем после загрузки
document.addEventListener('DOMContentLoaded', () => {
  window.nodeEffects = new NodeEffects();
});
</script>
</head>
<body class="transition-colors duration-300">
<div class="toggle-controls" id="toggleControls">≡</div>
 <div class="background-text">
 <h1>Департамент имущественных отношений Ямало-Ненецкого автономного округа</h1>
    </div>
<div class="controls" id="controls">
  <input type="text" id="searchInput" placeholder="Поиск..." style="padding: 8px; border-radius: 8px; border: 1px solid var(--primary-color);">
<span id="selectedCount" style="margin-left: 10px; font-size: 0.9em; color: var(--accent-color); display: none;">Выделено: 0</span>
  <div class="autocomplete-suggestions" id="searchSuggestions"></div>
  <button type="button" id="jsonExportBtn">JSON Экспорт</button>
  <button type="button" id="jsonImportBtn">JSON Импорт</button>
  <button type="button" id="saveBtn">Сохранить</button>
 <button type="button" id="collapseAllBtn">Свернуть все</button>
   <button type="button" id="collapseParentBtn" class="collapse-parent-btn">Свернуть родителя</button>
<button type="button" id="addSuperordinateAboveBtn">Добавить сверху</button>
<button type="button" id="uploadFileBtn">Загрузить файл</button>
<button type="button" id="mark269Btn">Отсутствует в 269-П</button>
<button type="button" id="power269Btn">Полномочие из 269-П</button>
<button type="button" id="subordinateBtn">Должностные регламенты</button>
 <button type="button" id="forAllBtn">Все сотрудники</button>
<button type="button" id="authorityBtn">Идентичное полномочие</button>
<button type="button" id="okrBtn">OKR</button>
<button type="button" id="indicatorBtn">Гос. программа</button>
<div class="cluster-controls" style="display: flex; gap: 5px; align-items: center;">
    <select id="clusterSelect" style="padding: 8px; border-radius: 8px; border: 1px solid var(--primary-color); background: var(--controls-bg); color: var(--text-color);">
        <option value="">Вся структура</option>
    </select>
    <button id="addToClusterBtn" title="Добавить в кластер"></button>
</div>
    <button type="button" id="zoomInBtn">+</button>
   <button type="button" id="zoomResetBtn" class="reset-zoom-btn" title="Сбросить масштаб и центрировать на родительском узле">⭕</button>
    <button type="button" id="zoomOutBtn">-</button>

  <div class="theme-switch" id="themeSwitch">
    <span class="theme-icon sun-icon">☀️</span>
    <span class="theme-icon moon-icon"></span>
    <div class="theme-switch-handle"></div>
<div class="theme-transition-overlay" id="themeTransitionOverlay"></div>
  </div>
</div>
<div class="drop-zone" id="dropZone">Перетащите файл сюда</div>
<div id="tree" class="tree"></div>
</div>
<div class="image-preview-container" id="previewContainer">
  <img src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAQAAAC1HAwCAAAAC0lEQVR42mNkYAAAAAYAAjCB0C8AAAAASUVORK5CYII=" class="image-preview" id="fullPreview">
</div>
<div class="watermark">Interactive Tree v9.2</div>
<div class="history-log-icon" id="historyLogIcon" title="История изменений">🕒</div>

<div class="history-dialog-backdrop" id="historyDialogBackdrop">
    <div class="history-dialog">
        <h3>История последних изменений</h3>
        <ul class="history-list" id="historyList">
            <!-- Записи будут добавляться сюда динамически -->
        </ul>
        <button class="history-dialog-close" id="historyDialogClose">Закрыть</button>
    </div>
</div>
<div class="department-management" id="departmentManagement">
    <div class="department-header">
        <h2>Управление отделами</h2>
         <button id="closeDepartmentManagement">× Закрыть</button>
    </div>
    <div class="department-container" id="departmentContainer">
        <!-- Колонки будут заполняться динамически -->
    </div>
</div>
<script>
const isChrome = !!window.chrome && (!!window.chrome.webstore || !!window.chrome.runtime);
if (isChrome && parseInt(navigator.userAgent.match(/Chrome\/(\d+)/)?.[1] || 0) < 50) {
    alert('Пожалуйста, обновите браузер до последней версии');
}

// Добавить полифиллы (перед всеми классами)
if (!window.Promise) {
    document.write('<script src="https://cdn.jsdelivr.net/npm/promise-polyfill@8/dist/polyfill.min.js"><\/script>');
}
if (!window.fetch) {
    document.write('<script src="https://cdn.jsdelivr.net/npm/whatwg-fetch@3.6.2/dist/fetch.umd.min.js"><\/script>');
}
class IndexedDBManager {
    constructor(dbName = 'TreeAppDB', version = 3) {
        this.dbName = dbName;
        this.version = version;
        this.db = null;
    }

    async open() {
        return new Promise((resolve, reject) => {
            const request = indexedDB.open(this.dbName, this.version);
            
            request.onupgradeneeded = (event) => {
                const db = event.target.result;
                
                if (!db.objectStoreNames.contains('treeData')) {
                    db.createObjectStore('treeData', { keyPath: 'id' });
                }
                
                if (!db.objectStoreNames.contains('files')) {
                    db.createObjectStore('files', { keyPath: 'id' });
                }
                
                if (!db.objectStoreNames.contains('images')) {
                    db.createObjectStore('images', { keyPath: 'id' });
                }
            };
            
            request.onsuccess = (event) => {
                this.db = event.target.result;
                resolve(this.db);
            };
            
            request.onerror = (event) => {
                reject(`IndexedDB error: ${event.target.error}`);
            };
        });
    }

    async getStore(storeName, mode = 'readonly') {
        if (!this.db) await this.open();
        return this.db.transaction(storeName, mode).objectStore(storeName);
    }

    async saveData(key, data) {
        try {
            const store = await this.getStore('treeData', 'readwrite');
            return new Promise((resolve, reject) => {
                const request = store.put({ id: key, data });
                request.onsuccess = () => resolve();
                request.onerror = (e) => reject(e.target.error);
            });
        } catch (error) {
            console.error('Save error:', error);
            throw error;
        }
    }

    async loadData(key) {
        try {
            const store = await this.getStore('treeData');
            return new Promise((resolve, reject) => {
                const request = store.get(key);
                request.onsuccess = () => resolve(request.result?.data || null);
                request.onerror = (e) => reject(e.target.error);
            });
        } catch (error) {
            console.error('Load error:', error);
            throw error;
        }
    }

    async saveFile(fileId, fileData) {
        try {
            const store = await this.getStore('files', 'readwrite');
            return new Promise((resolve, reject) => {
                const request = store.put({ id: fileId, ...fileData });
                request.onsuccess = () => resolve();
                request.onerror = (e) => reject(e.target.error);
            });
        } catch (error) {
            console.error('File save error:', error);
            throw error;
        }
    }

    async getFile(fileId) {
        try {
            const store = await this.getStore('files');
            return new Promise((resolve, reject) => {
                const request = store.get(fileId);
                request.onsuccess = () => resolve(request.result || null);
                request.onerror = (e) => reject(e.target.error);
            });
        } catch (error) {
            console.error('File load error:', error);
            throw error;
        }
    }

    async deleteFile(fileId) {
        try {
            const store = await this.getStore('files', 'readwrite');
            return new Promise((resolve, reject) => {
                const request = store.delete(fileId);
                request.onsuccess = () => resolve();
                request.onerror = (e) => reject(e.target.error);
            });
        } catch (error) {
            console.error('File delete error:', error);
            throw error;
        }
    }

    async getAllFiles() {
        try {
            const store = await this.getStore('files');
            return new Promise((resolve, reject) => {
                const request = store.getAll();
                request.onsuccess = () => resolve(request.result);
                request.onerror = (e) => reject(e.target.error);
            });
        } catch (error) {
            console.error('Get all files error:', error);
            throw error;
        }
    }
}
class TreeManager {
constructor() {
this.actionLog = [];
        this.maxLogEntries = 15;
        // Инициализация свойств
        this.selectedNode = null;
        this.selectedNodeId = null;
        this.nodeCounter = 1;
        this.treeData = null;
        this.imagesData = {};
        this.darkMode = false;
        this.controlsVisible = true;
        this.multiSelectMode = false;
        this.selectedNodes = new Set();
        this.ctrlPressed = false;
        this.draggedNode = null;
        this.draggedElement = null;
this.clipboard = null; 
        this.dropIndicator = null;
        this.zoomTimeout = null;
        this.searchQuery = '';
        this.filesData = {};
this.clusters = new Map(); // Хранит соответствие nodeId -> clusterName
this.availableClusters = new Set(); // Все существующие кластеры
this.activeCluster = null;
this.skipScrollRestore = false;
        this.scale = 0.7;
        this.visibleNodes = new Set();
        this.viewport = {
            top: 0,
            bottom: window.innerHeight,
            left: 0,
            right: window.innerWidth
        };
        this.nodeHeight = 180;
        this.nodeWidth = 280;
        this.debounceTimer = null;
        this.initialized = false;
        this.operationQueue = [];
        this.scrollState = { scrollLeft: 0, scrollTop: 0 };
        this.shouldRestoreScroll = false;
        this.focusNodeId = null;
        this.restoreToParent = null;
this.editingMode = false; 
this.history = []; 
this.historyIndex = -1;
this.maxHistoryLength = 50;
 this.uiSettings = {
            showNewNodesOnly: false 
        };
        this.departmentManagement = {
            active: false,
            draggedItem: null,
            draggedType: null,
            sourceCluster: null,
            history: [],
            maxHistory: 20,
            showNewNodesOnly: false,
 selectedNodesInDialog: new Set() 
        };
        this.db = new IndexedDBManager();

        // Запуск инициализации
        this.initialize();
    }

    async initialize() {
        try {
            // 1. Базовая синхронная инициализация
            this.bindElements();
            
            // 2. Асинхронная часть инициализации
            await this.asyncInit();
            
            // 3. Финальная настройка
            this.initialized = true;
            this.processOperationQueue();
            this.saveToHistory(true); 
        } catch (error) {
            console.error('Initialization failed:', error);
            this.showNotification('Ошибка инициализации приложения');
            // Fallback на localStorage если IndexedDB недоступен
            await this.loadFromLocalStorageFallback();
        }
    }
async asyncInit() {
    await this.db.open();
    await this.loadFilesData();
    this.loadThemePreference();
    await this.loadFromLocalStorage();
    this.loadActionLog();
    this.setupHistoryLogUI();

    // --- ✨ НАЧАЛО ИЗМЕНЕНИЙ ✨ ---
    // Создаем и добавляем кнопку круговой замены, если ее еще нет
    if (!document.getElementById('circular-replacement-btn-main')) {
        const circularReplaceBtn = document.createElement('button');
        circularReplaceBtn.id = 'circular-replacement-btn-main';
        

        // Убрали title, так как теперь будет кастомная подсказка
        circularReplaceBtn.style.cssText = `
            position: fixed;
            bottom: 20px;
            left: 20px;
            width: 40px;
            height: 40px;
            background: var(--controls-bg); /* Сделали фон менее кричащим */
            color: var(--primary-color); /* Цвет иконки в тон темы */
            border: 1px solid var(--primary-color); /* Добавили рамку */
            border-radius: 50%;
            box-shadow: 0 2px 5px rgba(0,0,0,0.15);
            cursor: pointer;
            z-index: 1001;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 22px;
            transition: all 0.2s ease-out; /* Упростили анимацию */
        `;

        document.body.appendChild(circularReplaceBtn);

        circularReplaceBtn.addEventListener('click', () => this.showCircularReplacementDialog());

        // Создаем контейнер для подсказки
        const tooltip = document.createElement('div');
        tooltip.textContent = 'Круговая замена узлов';
        tooltip.style.cssText = `
            position: fixed;
            bottom: 25px;
            left: 70px; /* Располагаем правее кнопки */
            background: var(--controls-bg);
            color: var(--text-color);
            padding: 5px 10px;
            border-radius: 6px;
            box-shadow: 0 2px 5px rgba(0,0,0,0.15);
            font-size: 12px;
            font-weight: 500;
            z-index: 1002;
            opacity: 0; /* Начально скрыта */
            transform: translateX(-10px); /* Начальное смещение для анимации */
            transition: opacity 0.2s ease-out, transform 0.2s ease-out;
            pointer-events: none; /* Чтобы не мешала кликам */
            white-space: nowrap;
        `;
        document.body.appendChild(tooltip);

        // Упрощенные и более профессиональные визуальные эффекты
        circularReplaceBtn.onmouseover = () => {
            // При наведении кнопка чуть приподнимается, а подсказка плавно появляется.
            // Это стандартный и интуитивно понятный пользовательский опыт. [2, 4]
            circularReplaceBtn.style.transform = 'translateY(-2px)';
            circularReplaceBtn.style.boxShadow = '0 4px 8px rgba(0,0,0,0.2)';
            tooltip.style.opacity = '1';
            tooltip.style.transform = 'translateX(0)';
        };
        circularReplaceBtn.onmouseout = () => {
            // При убирании курсора все возвращается в исходное состояние.
            circularReplaceBtn.style.transform = 'translateY(0)';
            circularReplaceBtn.style.boxShadow = '0 2px 5px rgba(0,0,0,0.15)';
            tooltip.style.opacity = '0';
            tooltip.style.transform = 'translateX(-10px)';
        };
    }
    // --- ✨ КОНЕЦ ИЗМЕНЕНИЙ ✨ ---

    this.setupEventListeners();
    this.setupClusterControls();
    this.setupZoom();
    this.setupSearch();
    this.updateTree();
    this.updateSelectionCounter();
    setTimeout(() => {
        this.scrollToRoot();
    }, 300);
}
setupSearch() {
    this.searchInput = document.getElementById('searchInput');
    this.searchSuggestions = document.getElementById('searchSuggestions');

    // ✨ ИЗМЕНЕНИЕ: Вызываем новый метод для минималистичных стилей
    this.injectMinimalistSearchClearButtonStyles(); 

    const searchContainer = document.createElement('div');
    searchContainer.className = 'search-container';

    // Оборачиваем поле поиска в новый контейнер
    this.searchInput.parentNode.insertBefore(searchContainer, this.searchInput);
    searchContainer.appendChild(this.searchInput);

    const clearButton = document.createElement('button');
    clearButton.id = 'search-clear-btn';
    clearButton.textContent = '×';
    clearButton.setAttribute('aria-label', 'Очистить поиск'); // Для доступности
    searchContainer.appendChild(clearButton);

    this.searchInput.addEventListener('input', (e) => {
        this.searchQuery = e.target.value.toLowerCase().trim();
        // Показываем или скрываем кнопку в зависимости от наличия текста
        clearButton.style.display = this.searchQuery ? 'block' : 'none';
        this.updateTree();
    });

    // Обработчик для кнопки очистки
    clearButton.addEventListener('click', () => {
        this.searchInput.value = '';
        this.searchQuery = '';
        clearButton.style.display = 'none'; // Сразу скрываем кнопку
        this.updateTree();
        this.searchInput.focus(); // Возвращаем фокус в поле поиска
    });
}
injectMinimalistSearchClearButtonStyles() {
    if (document.getElementById('search-clear-styles')) return;

    const style = document.createElement('style');
    style.id = 'search-clear-styles';
    style.textContent = `
        .search-container {
            position: relative;
            display: inline-flex;
            align-items: center;
        }
        #searchInput {
            padding-right: 28px;
        }
        #search-clear-btn {
            position: absolute;
            right: 8px;
            top: 50%;
            transform: translateY(-50%);
            background: transparent;
            border: none;
            color: #ff4444;
            font-size: 20px;
            font-weight: bold;
            line-height: 1;
            cursor: pointer;
            display: none;
            padding: 0;
            opacity: 0.7;
            transition: opacity 0.2s;
        }
        #search-clear-btn:hover {
            opacity: 1;
        }
        .mode-selection-dialog-btn {
            flex-basis: 45%;
            padding: 8px 12px !important;
            font-size: 0.9em !important;
            cursor: pointer;
            border-radius: 8px !important;
            border: none;
            background: linear-gradient(145deg, var(--primary-color), #6B9EBF);
            color: white;
            font-weight: 500;
            transition: all 0.2s ease;
            min-width: 110px !important;
            max-width: 220px !important;
            height: 36px !important;
            line-height: 1.2 !important;
            box-sizing: border-box;
            display: flex;
            align-items: center;
            justify-content: center;
        }
        .mode-selection-dialog-btn:hover {
            transform: translateY(-2px);
            box-shadow: 0 6px 12px rgba(93, 138, 168, 0.3);
        }
    `;
    document.head.appendChild(style);
}
handleSearchInput(query) {
    // Сохраняем текущую позицию прокрутки перед обновлением
    this.saveScrollPosition();
    
    this.searchQuery = query.toLowerCase().trim();
    
    if (this.searchQuery.length > 0) {
        this.showSuggestions(this.searchQuery);
    } else {
        this.searchSuggestions.style.display = 'none';
        this.updateTree(); // Обновляем дерево при пустом запросе
    }
    
    clearTimeout(this.searchTimeout);
    this.searchTimeout = setTimeout(() => {
        this.updateTree();
        // Восстанавливаем позицию после обновления
        this.restoreScrollPosition();
        
        // Показываем уведомление о контексте поиска
        if (this.activeCluster) {
            this.showNotification(`Поиск в кластере "${this.activeCluster}"`);
        }
    }, 300);
}
    
    // Собираем все слова из дерева для автодополнения
    getAllWords() {
        const words = new Set();
        
        const collectWords = (node) => {
            // Добавляем слова из заголовка
            node.content.text.toLowerCase().split(/\s+/).forEach(word => {
                if (word.length > 2) words.add(word);
            });
            
            // Добавляем слова из подблоков
            (node.content.subBlocks || []).forEach(block => {
                block.toLowerCase().split(/\s+/).forEach(word => {
                    if (word.length > 2) words.add(word);
                });
            });
            
            // Добавляем слова из названий файлов
            (node.content.files || []).forEach(fileId => {
                const file = this.filesData[fileId];
                if (file) {
                    file.name.toLowerCase().split(/\s+/).forEach(word => {
                        if (word.length > 2) words.add(word);
                    });
                }
            });
            
            // Рекурсивно обрабатываем детей
            node.children.forEach(collectWords);
        };
        
        collectWords(this.treeData);
        return Array.from(words).sort();
    }
    
    // Показываем подсказки для автодополнения
    showSuggestions(query) {
        const words = this.getAllWords();
        const suggestions = words.filter(word => 
            word.includes(query.toLowerCase())
        ).slice(0, 10);
        
        if (suggestions.length > 0) {
            this.searchSuggestions.innerHTML = '';
            suggestions.forEach(word => {
                const suggestion = document.createElement('div');
                suggestion.className = 'autocomplete-suggestion';
                
                // Подсвечиваем совпадающую часть
                const index = word.indexOf(query.toLowerCase());
                if (index >= 0) {
                    const before = word.substring(0, index);
                    const match = word.substring(index, index + query.length);
                    const after = word.substring(index + query.length);
                    
                    suggestion.innerHTML = `${before}<strong>${match}</strong>${after}`;
                } else {
                    suggestion.textContent = word;
                }
                
                suggestion.addEventListener('click', () => {
                    this.searchInput.value = word;
                    this.handleSearchInput(word);
                    this.searchInput.focus();
                });
                
                this.searchSuggestions.appendChild(suggestion);
            });
            
            this.searchSuggestions.style.display = 'block';
        } else {
            this.searchSuggestions.style.display = 'none';
        }
    }
      getVisibleNodes() {
    const visibleNodes = new Set();
    const walkTree = (node, depth = 0) => {
      if (!this.isNodeVisible(node, depth)) return;
      
      visibleNodes.add(node.id);
      if (node.isExpanded) {
        node.children.forEach(child => walkTree(child, depth + 1));
      }
    };
    
    walkTree(this.treeData);
    return visibleNodes;
  }

  // Проверка видимости узла
  isNodeVisible(node, depth) {
    const yPos = depth * this.nodeHeight;
    const xPos = depth * this.nodeWidth;
    
    return yPos >= this.viewport.top - this.nodeHeight * 2 && 
           yPos <= this.viewport.bottom + this.nodeHeight * 2 &&
           xPos >= this.viewport.left - this.nodeWidth * 2 &&
           xPos <= this.viewport.right + this.nodeWidth * 2;
  }

  // Обновленный updateTree

// Синхронная версия для случаев без Web Worker
getVisibleNodesSync() {
    const visibleNodes = new Set();
    const walkTree = (node, depth = 0) => {
        if (!this.isNodeVisible(node, depth)) return;
        
        visibleNodes.add(node.id);
        if (node.isExpanded) {
            node.children.forEach(child => walkTree(child, depth + 1));
        }
    };
    
    walkTree(this.treeData);
    return visibleNodes;
}

// Новый метод для рендеринга видимых узлов
renderVisibleNodes() {
    const treeContainer = this.elements.treeContainer;
    treeContainer.innerHTML = '';
    treeContainer.appendChild(this.createNodeElement(this.treeData));
}
bindElements() {
    this.elements = {
        jsonExportBtn: document.getElementById('jsonExportBtn'),
        searchInput: document.getElementById('searchInput'),
        jsonImportBtn: document.getElementById('jsonImportBtn'),
        collapseAllBtn: document.getElementById('collapseAllBtn'),
        saveBtn: document.getElementById('saveBtn'),
        themeSwitch: document.getElementById('themeSwitch'),
        dropZone: document.getElementById('dropZone'),
        treeContainer: document.getElementById('tree'),
        previewContainer: document.getElementById('previewContainer'),
        fullPreview: document.getElementById('fullPreview'),
        toggleControls: document.getElementById('toggleControls'),
        zoomResetBtn: document.getElementById('zoomResetBtn'),
        zoomInBtn: document.getElementById('zoomInBtn'),
        zoomOutBtn: document.getElementById('zoomOutBtn'),
        controls: document.getElementById('controls'),
        clusterSelect: document.getElementById('clusterSelect'),
        addToClusterBtn: document.getElementById('addToClusterBtn')
    };

    // ⭐ НОВОЕ: Добавляем подсказку для основной панели
    this.setupHelpTooltips(this.elements.controls, 'main');
}

setupEventListeners() {
    this.elements.searchInput.addEventListener('input', (e) => {
        this.searchQuery = e.target.value.toLowerCase().trim();
        this.updateTree();
    });

    // Флаг для отслеживания был ли Ctrl отпущен после первого нажатия
    this.ctrlWasReleased = false;

document.addEventListener('keydown', (e) => {
    // Проверяем, находимся ли мы в режиме редактирования текста
    const isEditing = document.activeElement.tagName === 'TEXTAREA' || 
                     document.activeElement.tagName === 'INPUT' ||
                     document.activeElement.contentEditable === 'true';
    
    if (isEditing) {
        this.editingMode = true;
        return; // Пропускаем нашу обработку для полей ввода
    }
    
    this.editingMode = false;
    
    // Обработка Esc для любых раскладок
    if (e.key === 'Escape' || e.key === 'Esc' || e.keyCode === 27) {
        this.clipboard = null;
        this.showNotification('Буфер обмена очищен');
        this.clearMultiSelection();
        return;
    }
    
    // Обработка Ctrl+C/Cmd+C для любых раскладок
    if ((e.ctrlKey || e.metaKey) && (e.key === 'c' || e.key === 'с' || e.key === 'C' || e.key === 'С')) {
        e.preventDefault();
        this.copySelectedNode();
        return;
    }

    // Обработка Ctrl+V/Cmd+V для любых раскладок
    if ((e.ctrlKey || e.metaKey) && (e.key === 'v' || e.key === 'м' || e.key === 'V' || e.key === 'М')) {
        e.preventDefault();
        this.pasteNode();
        return;
    }
  if ((e.ctrlKey || e.metaKey) && (e.key === 'f' || e.key === 'а' || e.key === 'F' || e.key === 'А')) {
    e.preventDefault();
    this.pasteNodeAsChild();
    return;
}
if ((e.ctrlKey || e.metaKey) && (e.key === 'g' || e.key === 'п' || e.key === 'G' || e.key === 'П')) {
    e.preventDefault();
    this.pasteAsParent(); // Используем новый метод
    return;
}

if ((e.ctrlKey || e.metaKey) && (e.key === 'r' || e.key === 'к' || e.key === 'R' || e.key === 'К')) {
    e.preventDefault();
    this.replaceNode(); // Используем новый метод
    return;
}

    if ((e.ctrlKey || e.metaKey) && !e.shiftKey && 
        (e.key === 'z' || e.key === 'я' || e.key === 'Z' || e.key === 'Я')) {
        e.preventDefault();
        this.undo();
        return;
    }
    
    // Обработка Ctrl для множественного выбора
    if (e.key === 'Control' || e.key === 'Meta') {
        this.ctrlPressed = true;
    }
});

document.addEventListener('keyup', (e) => {
    if (e.key === 'Control' || e.key === 'Meta') {
        this.ctrlPressed = false;
    }
});
let scrollTimeout;
this.elements.treeContainer.addEventListener('scroll', () => {
  clearTimeout(scrollTimeout);
  scrollTimeout = setTimeout(() => {
    this.updateNodeEffects();
  }, 100);
}, { passive: true });
    this.elements.jsonExportBtn.addEventListener('click', () => this.exportToJSON());
    this.elements.jsonImportBtn.addEventListener('click', () => this.importFromJSON());
  this.elements.collapseAllBtn.addEventListener('click', () => this.collapseAllNodes());
    this.elements.saveBtn.addEventListener('click', () => this.saveData());
    this.elements.themeSwitch.addEventListener('click', () => this.toggleTheme());

    document.getElementById('closeDepartmentManagement').addEventListener('click', () => {
        this.hideDepartmentManagement();
        this.promptReplacementMode();
    });

    document.addEventListener('dragover', (e) => {
        if (e.target.closest('.department-column')) {
            e.preventDefault();
            e.dataTransfer.dropEffect = 'move';
        }
    });
const departmentManagementEl = document.getElementById('departmentManagement');

if (departmentManagementEl) {
  let dragPos = { x: 0, y: 0 };
  let isDragging = false;

  // Обновляем позицию мыши при dragover
  departmentManagementEl.addEventListener('dragover', (e) => {
    e.preventDefault();
    dragPos.x = e.clientX;
    dragPos.y = e.clientY;

    if (!isDragging) {
      isDragging = true;
      requestAnimationFrame(autoScroll);
    }
  }, { passive: false });

  // Функция плавного автоскролла
  function autoScroll() {
    if (!isDragging) return;

    const rect = departmentManagementEl.getBoundingClientRect();
    const scrollMargin = 60; // зона начала скролла
    const maxScrollSpeed = 30; // макс скорость скролла

    let dx = 0;
    let dy = 0;

    // Горизонталь
    if (dragPos.x < rect.left + scrollMargin) {
      dx = -calcSpeed(rect.left + scrollMargin - dragPos.x, scrollMargin, maxScrollSpeed);
    } else if (dragPos.x > rect.right - scrollMargin) {
      dx = calcSpeed(dragPos.x - (rect.right - scrollMargin), scrollMargin, maxScrollSpeed);
    }

    // Вертикаль
    if (dragPos.y < rect.top + scrollMargin) {
      dy = -calcSpeed(rect.top + scrollMargin - dragPos.y, scrollMargin, maxScrollSpeed);
    } else if (dragPos.y > rect.bottom - scrollMargin) {
      dy = calcSpeed(dragPos.y - (rect.bottom - scrollMargin), scrollMargin, maxScrollSpeed);
    }

    if (dx !== 0 || dy !== 0) {
      departmentManagementEl.scrollLeft += dx;
      departmentManagementEl.scrollTop += dy;
      requestAnimationFrame(autoScroll);
    } else {
      // Если мышь в центре, останавливаем автоскролл
      isDragging = false;
    }
  }

  // Функция расчёта скорости скролла пропорционально расстоянию до края
  function calcSpeed(distance, margin, maxSpeed) {
    // Чем ближе к краю — тем больше скорость (линейно)
    return Math.min(maxSpeed, (distance / margin) * maxSpeed);
  }
}
    document.addEventListener('drop', (e) => {
        if (!this.departmentManagement.active || !this.departmentManagement.draggedItem) return;
        
        const column = e.target.closest('.department-column');
        if (column) {
            e.preventDefault();
            const targetCluster = column.dataset.cluster;
            
            if (this.departmentManagement.draggedType === 'group') {
                this.moveGroupToCluster(
                    this.departmentManagement.draggedItem,
                    this.departmentManagement.sourceCluster,
                    targetCluster
                );
            } else {
                // Создаем новую группу в целевом кластере
                const itemNode = this.findNode(this.treeData, this.departmentManagement.draggedItem);
                if (itemNode) {
                    this.clusters.set(itemNode.id, targetCluster);
                    this.availableClusters.add(targetCluster);
                }
            }
            
            this.renderDepartmentManagement();
            this.updateTree();
            this.saveData();
        }
    });
    this.elements.clusterSelect.addEventListener('change', (e) => {
        this.activeCluster = e.target.value || null;
        this.updateTree();
        this.saveData();
});
this.elements.addToClusterBtn.addEventListener('click', () => {
  if (this.selectedNodes.size > 1) {
    this.showMultiClusterDialog();
  } else {
    this.showClusterDialog();
  }
});
    this.elements.toggleControls.addEventListener('click', () => this.toggleControlsVisibility());
    document.addEventListener('dragover', this.handleDragOver.bind(this));
    document.addEventListener('drop', this.handleFileDrop.bind(this));
    this.elements.previewContainer.addEventListener('click', () => this.hidePreview());
this.elements.addSubordinateBtn = document.getElementById('addSubordinateBtn');
this.elements.authorityBtn = document.getElementById('authorityBtn');
this.elements.authorityBtn.addEventListener('click', () => this.toggleAuthorityMark());
this.elements.zoomResetBtn.addEventListener('click', () => this.resetZoom());
this.elements.zoomInBtn.addEventListener('click', () => this.changeZoom(0.1));
this.elements.zoomOutBtn.addEventListener('click', () => this.changeZoom(-0.1));
this.elements.expandAllBtn = document.getElementById('expandAllBtn');
this.elements.uploadFileBtn = document.getElementById('uploadFileBtn');
this.elements.uploadFileBtn.addEventListener('click', () => this.uploadFile());
 this.elements.addSuperordinateAboveBtn = document.getElementById('addSuperordinateAboveBtn');
    this.elements.addSuperordinateAboveBtn.addEventListener('click', () => this.addSuperordinateAbove());
this.elements.mark269Btn = document.getElementById('mark269Btn');
this.elements.mark269Btn.addEventListener('click', () => this.toggle269Mark());
this.elements.power269Btn = document.getElementById('power269Btn');
this.elements.power269Btn.addEventListener('click', () => this.togglePower269Mark());
  this.elements.forAllBtn = document.getElementById('forAllBtn');
        this.elements.forAllBtn.addEventListener('click', () => this.toggleForAll());
this.elements.collapseParentBtn = document.getElementById('collapseParentBtn');
this.elements.collapseParentBtn.addEventListener('click', () => this.collapseParentNode());
this.elements.subordinateBtn = document.getElementById('subordinateBtn');
this.elements.subordinateBtn.addEventListener('click', () => this.toggleSubordinateMark());
this.elements.okrBtn = document.getElementById('okrBtn');
this.elements.okrBtn.addEventListener('click', () => this.toggleOKRMark());
this.elements.indicatorBtn = document.getElementById('indicatorBtn');
this.elements.indicatorBtn.addEventListener('click', () => this.toggleIndicatorMark());
  }
getFileIcon(fileType) {
    // Просто возвращаем пустую строку вместо любых иконок.
    // Это самый чистый способ убрать их, не ломая код, который вызывает эту функцию.
    return '';
}

  toggleControlsVisibility() {
    this.controlsVisible = !this.controlsVisible;
    this.elements.controls.classList.toggle('hidden', !this.controlsVisible);
    this.elements.toggleControls.textContent = this.controlsVisible ? '×' : '≡';
  }
  resetTreeState() {
    const resetRecursive = (node) => {
      node.isExpanded = false;
      if (node.children && node.children.length) {
        node.children.forEach(resetRecursive);
      }
    };
    this.treeData.isExpanded = true; // корень раскрыт
    this.treeData.children.forEach(resetRecursive);
  }
collapseAllNodes() {
    const treeContainer = this.elements.treeContainer;
    const savedState = {
        scrollLeft: treeContainer.scrollLeft,
        scrollTop: treeContainer.scrollTop,
        transform: treeContainer.style.transform
    };

    // Сбрасываем раскрытие всех узлов кроме корня
    this.resetTreeState();

    // Обновляем дерево без автоматического восстановления позиции
    this.skipScrollRestore = true;
    this.updateTree();
    this.skipScrollRestore = false;

    // Восстанавливаем позицию и трансформацию
    requestAnimationFrame(() => {
        treeContainer.style.transform = savedState.transform;
        treeContainer.scrollLeft = Math.min(savedState.scrollLeft, treeContainer.scrollWidth - treeContainer.clientWidth);
        treeContainer.scrollTop = Math.min(savedState.scrollTop, treeContainer.scrollHeight - treeContainer.clientHeight);

        if (window.panZoomVars) {
            const transformMatch = savedState.transform.match(/translate\(([^,]+),\s*([^)]+)\)/);
            if (transformMatch) {
                window.panZoomVars.translateX = parseFloat(transformMatch[1]);
                window.panZoomVars.translateY = parseFloat(transformMatch[2]);
            }
            window.panZoomVars.scale = this.scale;
        }
    });

    this.saveData();
    this.showNotification('Все узлы свернуты');
}

scrollToRoot() {
    const rootElement = document.querySelector(`[data-node-id="${this.treeData.id}"]`);
    if (rootElement) {
        rootElement.scrollIntoView({
            behavior: 'auto',
            block: 'center',
            inline: 'center'
        });
    }
}

resetZoom(centerOnParent = false) {
    const treeContainer = this.elements.treeContainer || document.querySelector('.tree-container');
    treeContainer.style.transform = 'scale(0.7)'; // Изменено с scale(1) на scale(0.7)
    this.scale = 0.7; // Изменено с 1 на 0.7
    
    // Остальной код остается без изменений...
    if (centerOnParent && this.selectedNode) {
        const parentNode = this.findParent(this.treeData, this.selectedNode.node.id);
        if (parentNode) {
            setTimeout(() => {
                const parentElement = document.querySelector(`[data-node-id="${parentNode.id}"]`);
                if (parentElement) {
                    const containerRect = treeContainer.getBoundingClientRect();
                    const elementRect = parentElement.getBoundingClientRect();
                    
                    const targetX = (window.innerWidth / 2) - (elementRect.width / 2);
                    const targetY = (window.innerHeight / 2) - (elementRect.height / 2);
                    
                    const currentX = elementRect.left - containerRect.left;
                    const currentY = elementRect.top - containerRect.top;
                    
                    const scrollX = targetX - currentX;
                    const scrollY = targetY - currentY;
                    
                    treeContainer.scrollBy({
                        left: scrollX,
                        top: scrollY,
                        behavior: 'smooth'
                    });
                    
                    parentElement.classList.add('highlight-parent');
                    setTimeout(() => {
                        parentElement.classList.remove('highlight-parent');
                    }, 2000);
                }
            }, 50);
        }
    } else if (this.resetPosition) {
        this.resetPosition();
    }
    
    this.showNotification(centerOnParent ? 
        'Масштаб сброшен и центрирован на родительском узле' : 
        'Масштаб сброшен');
}
  updateNodeEffects() {
    document.querySelectorAll('.node-content').forEach(content => {
      const node = this.findNode(this.treeData, content.closest('.node').dataset.nodeId);
      
      if (node.content.absent269) {
        nodeEffects.addEffect(content, 'absent269');
      } else if (node.content.isForAll) {
        nodeEffects.addEffect(content, 'forAll');
      } else if (node.content.isSubordinate) {
        nodeEffects.addEffect(content, 'subordinate');
      }
    });
  }

async copySelectedNode() {
    if (!this.selectedNode && this.selectedNodes.size === 0) {
        this.showNotification('Выберите узел(ы) для копирования');
        return;
    }
    const createDialog = () => {
        return new Promise((resolve) => {
            const style = document.createElement('style');
            style.id = 'copy-dialog-styles';
            style.innerHTML = `
                .copy-dialog-backdrop { position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: rgba(0, 0, 0, 0.5); display: flex; justify-content: center; align-items: center; z-index: 10001; backdrop-filter: blur(4px); }
                .copy-dialog { background: var(--controls-bg); padding: 25px; border-radius: 12px; box-shadow: 0 5px 20px rgba(0,0,0,0.25); width: 400px; text-align: center; border: 1px solid var(--primary-color); animation: dialog-appear 0.3s ease-out; }
                @keyframes dialog-appear { from { opacity: 0; transform: scale(0.9); } to { opacity: 1; transform: scale(1); } }
                .copy-dialog h3 { margin-top: 0; color: var(--primary-color); font-size: 1.4em; }
                .copy-dialog .options { display: flex; flex-direction: column; gap: 12px; margin: 20px 0; }
                .copy-dialog button { padding: 12px; border-radius: 8px; border: 1px solid transparent; cursor: pointer; font-size: 1em; transition: all 0.2s ease; background: var(--node-bg); color: var(--text-color); border: 1px solid var(--primary-color); text-align: left; }
                .copy-dialog button:hover { background: var(--secondary-color); color: white; border-color: var(--secondary-color); transform: translateY(-2px); }
                .copy-dialog .cancel-btn { margin-top: 10px; background: transparent; color: var(--accent-color); border: none; }
            `;
            document.head.appendChild(style);
            const backdrop = document.createElement('div');
            backdrop.className = 'copy-dialog-backdrop';
            const dialog = document.createElement('div');
            dialog.className = 'copy-dialog';
            const nodeCount = this.selectedNodes.size > 0 ? this.selectedNodes.size : 1;
            const nodeText = nodeCount > 1 ? `${nodeCount} узлов` : `узел "${this.selectedNode.node.content.text}"`;
            dialog.innerHTML = `<h3>Копирование</h3><p>Что сделать с ${nodeText}?</p><div class="options"><button data-action="cut">Вырезать (переместить)</button><button data-action="copy-deep">Копировать с дочерними узлами</button><button data-action="copy-shallow">Копировать только этот узел</button></div><button class="cancel-btn" data-action="cancel">Отмена</button>`;
            backdrop.appendChild(dialog);
            document.body.appendChild(backdrop);
            const closeDialog = (action) => {
                document.body.removeChild(backdrop);
                document.head.removeChild(style);
                resolve(action);
            };
            dialog.addEventListener('click', (e) => { if (e.target.tagName === 'BUTTON') { closeDialog(e.target.dataset.action); } });
            backdrop.addEventListener('click', (e) => { if (e.target === backdrop) { closeDialog('cancel'); } });
        });
    };
    const action = await createDialog();
    if (action === 'cancel') {
        this.showNotification('Копирование отменено');
        return;
    }

  
    const nodeNames = [];
   
    if (this.selectedNodes.size > 0) {
        this.selectedNodes.forEach(id => {
            const node = this.findNode(this.treeData, id);
            if (node) nodeNames.push(`"${node.content.text}"`);
        });
    } else if (this.selectedNode) {
        nodeNames.push(`"${this.selectedNode.node.content.text}"`);
    }

    const logText = action === 'cut' ? 'Вырезан узел(ы):' : 'Скопирован узел(ы):';
 
    this.logAction(`${logText} ${nodeNames.join(', ')}`);


    this.saveToHistory(false, true);
    const isCut = action === 'cut';
    const copyChildren = action !== 'copy-shallow';
    const copyData = { timestamp: Date.now(), version: '2.8', isCutOperation: isCut };
    const processNode = (node) => { return copyChildren ? this.serializeNodeWithChildren(node) : this.serializeNode(node); };
    if (this.selectedNodes.size > 0) {
        copyData.nodes = [];
        this.selectedNodes.forEach(id => { const node = this.findNode(this.treeData, id); if (node) copyData.nodes.push(processNode(node)); });
        copyData.isMultiCopy = true;
    } else if (this.selectedNode) {
        copyData.node = processNode(this.selectedNode.node);
        copyData.isMultiCopy = false;
    }
    this.clipboard = copyData;
    let notificationMessage = 'Узел(ы) скопированы в буфер обмена.';
    if (isCut) {
        const nodesToRemove = this.selectedNodes.size > 0 ? new Set(this.selectedNodes) : new Set([this.selectedNode.node.id]);
        const removeRecursive = (parent, ids) => {
            parent.children = parent.children.filter(child => !ids.has(child.id));
            parent.children.forEach(child => removeRecursive(child, ids));
        };
        removeRecursive(this.treeData, nodesToRemove);
        this.clearMultiSelection();
        this.selectedNode = null;
        this.selectedNodeId = null;
        this.updateTree();
        notificationMessage = 'Узел(ы) вырезаны и готовы к вставке.';
    }
    this.showNotification(`${notificationMessage} Нажмите Ctrl+V для вставки.`);
    this.saveData();
}
async copyWithLevels() {
    this.saveToHistory();
    if (!this.selectedNode) {
        this.showNotification('Сначала выберите корневой узел для операции.');
        return;
    }

    const originalNode = this.selectedNode.node;
    const parentOfOriginal = this.findParent(this.treeData, originalNode.id);
    if (!parentOfOriginal) {
        this.showNotification('Нельзя выполнить эту операцию для корневого узла.', 'error');
        return;
    }

    // 1. Показываем диалог и получаем ID узлов, которые пользователь выбрал.
    const selectedIds = await this.showTreeSelectionDialog(originalNode);
    if (!selectedIds || !selectedIds.size) {
        this.showNotification('Копирование отменено.');
        return;
    }

    // 2. Строим новую, чистую иерархию ТОЛЬКО из выбранных узлов для буфера обмена.
    const newHierarchyRoot = this.buildNewHierarchy(originalNode, selectedIds);
    if (!newHierarchyRoot) {
        this.showNotification('Не удалось построить новую иерархию.', 'error');
        return;
    }

    // 3. Кладём новую структуру в буфер обмена.
    this.clipboard = {
        timestamp: Date.now(),
        version: '3.1',
        isCutOperation: true,
        node: newHierarchyRoot
    };


    const promotedOrphans = this.restructureAndPruneTree(originalNode, selectedIds);

   
    const originalNodeIndex = parentOfOriginal.children.findIndex(child => child.id === originalNode.id);


    if (originalNodeIndex !== -1) {
        parentOfOriginal.children.splice(originalNodeIndex, 1, ...promotedOrphans);
    }

    this.updateTree();
    this.saveData();
    this.showNotification(`Структура скопирована. Вставьте (Ctrl+V) в нужное место.`);
}

getOrphanPromotionMap(startNode, selectedIds) {
    const promotionMap = new Map();

    const findOrphansRecursive = (currentNode) => {
        // Если текущий узел был выбран для копирования...
        if (selectedIds.has(currentNode.id)) {
            // ...находим его дочерние узлы, которые НЕ были выбраны.
            // Метод filter создает новый массив, не изменяя исходный. [2]
            const orphans = currentNode.children.filter(child => !selectedIds.has(child.id));
            if (orphans.length > 0) {
                // Запоминаем, что у этого родителя есть "сироты".
                promotionMap.set(currentNode.id, orphans);
            }
        }
        // Рекурсивно продолжаем поиск вглубь дерева для каждого дочернего узла. [3]
        currentNode.children.forEach(findOrphansRecursive);
    };

    findOrphansRecursive(startNode);
    return promotionMap;
}
removeNodesByIds(currentNode, idsToRemove) {
    // Фильтруем дочерние элементы, удаляя те, что есть в списке на удаление.
    currentNode.children = currentNode.children.filter(child => !idsToRemove.has(child.id));

    // Рекурсивно вызываем этот же метод для всех оставшихся детей.
    currentNode.children.forEach(child => this.removeNodesByIds(child, idsToRemove));
}
buildNewHierarchyForRestructure(startNode, nodesToMoveIds) {
    // Внутренняя рекурсивная функция для построения копии
    const buildRecursive = (currentNode) => {
        // Клонируем узел, чтобы не изменять оригинал.
        const newNode = JSON.parse(JSON.stringify(currentNode));
        newNode.children = []; // Очищаем детей, будем добавлять только выбранных.

        if (currentNode.children && currentNode.children.length > 0) {
            for (const child of currentNode.children) {
                // Если дочерний узел выбран для переноса, рекурсивно строим его ветку.
                if (nodesToMoveIds.has(child.id)) {
                    const newChild = buildRecursive(child);
                    if (newChild) {
                        newNode.children.push(newChild);
                    }
                }
            }
        }
        return newNode;
    };

    const newHierarchyRoots = [];
    // Находим "точки входа" - самые верхние узлы в иерархии переноса,
    // чьи родители не были выбраны.
    nodesToMoveIds.forEach(id => {
        const parent = this.findParent(this.treeData, id);
        if (!parent || !nodesToMoveIds.has(parent.id)) {
            const node = this.findNode(this.treeData, id);
            if (node) {
                newHierarchyRoots.push(buildRecursive(node));
            }
        }
    });

    return newHierarchyRoots;
}
getMaxDepth(node, depth = 1) {
    try {
        if (!node || !node.children || node.children.length === 0) {
            return depth;
        }
        let maxChildDepth = depth;
        node.children.forEach(child => {
            const childDepth = this.getMaxDepth(child, depth + 1);
            if (childDepth > maxChildDepth) {
                maxChildDepth = childDepth;
            }
        });
        return maxChildDepth;
    } catch (error) {
        console.error('Ошибка в getMaxDepth:', error);
        return 1;
    }
}
getRemainingNodes(startNode, selectedIds) {
    const orphans = [];
    const findOrphansRecursive = (currentNode) => {
        const parentIsSelected = selectedIds.has(currentNode.id);

        currentNode.children.forEach(child => {
            const childIsSelected = selectedIds.has(child.id);
            if (parentIsSelected && !childIsSelected) {
                orphans.push(child); // Нашли сироту!
            } else {
                // Если ребенок тоже выбран (или родитель не был выбран),
                // продолжаем искать сирот глубже в этой ветке.
                findOrphansRecursive(child);
            }
        });
    };

    findOrphansRecursive(startNode);
    return orphans;
}
getNodePosition(node) {
    const parent = this.findParent(this.treeData, node.id);
    if (!parent) return { parentId: null, index: -1 };
    const index = parent.children.findIndex(child => child.id === node.id);
    return { parentId: parent.id, index };
}
async showCircularReplacementDialog() {
    const mode = await this.promptReplacementMode();
    if (!mode) return;

    if (mode === 'tornado') {
        this.showTornadoReplacementDialog();
    } else if (mode === 'limited') {
        this.showLimitedReplacementDialog();
    } else if (mode === 'restructure') {
        this.showRestructureDialog();
    } else if (mode === 'add_unit') {
        this.showNewStaffUnitDialog();
    } else if (mode === 'manage_positions') {
        this.showManagePositionsDialog();
    } else if (mode === 'manage_departments') {
        this.showDepartmentManagement();
    } else if (mode === 'liquidate_department') { // --- ИЗМЕНЕНИЕ ЗДЕСЬ ---
        this.showLiquidationDialog();
    }
}
promptReplacementMode() {
    return new Promise(resolve => {
        if (document.getElementById('mode-selection-dialog')) return;

        // --- Стили остаются без изменений ---
        if (!document.getElementById('mode-selection-dialog-styles')) {
            const style = document.createElement('style');
            style.id = 'mode-selection-dialog-styles';
            style.textContent = `
                .mode-selection-dialog-btn {
                    flex-basis: 45%; padding: 8px 12px !important; font-size: 0.9em !important;
                    cursor: pointer; border-radius: 8px !important; border: none;
                    background: linear-gradient(145deg, var(--primary-color), #6B9EBF);
                    color: white; font-weight: 500; transition: all 0.2s ease;
                    min-width: 110px !important; max-width: 220px !important;
                    height: 36px !important; line-height: 1.2 !important; box-sizing: border-box;
                    display: flex; align-items: center; justify-content: center;
                }
                .mode-selection-dialog-btn:hover {
                    transform: translateY(-2px);
                    box-shadow: 0 6px 12px rgba(93, 138, 168, 0.3);
                }
            `;
            document.head.appendChild(style);
        }

        const backdrop = document.createElement('div');
        backdrop.id = 'mode-selection-dialog';
        backdrop.style.cssText = `
            position: fixed; top: 0; left: 0; width: 100%; height: 100%;
            background: rgba(0,0,0,0.6); display: flex; justify-content: center;
            align-items: center; z-index: 10003; backdrop-filter: blur(5px);
        `;

        const dialog = document.createElement('div');
        dialog.style.cssText = `
            background: var(--controls-bg); padding: 25px; border-radius: 12px;
            box-shadow: 0 5px 20px rgba(0,0,0,0.25); text-align: center;
            border: 1px solid var(--primary-color); animation: dialog-appear 0.3s ease-out;
        `;

         dialog.innerHTML = `
            <h3 style="margin-top: 0; color: var(--primary-color);">Выберите режим операции</h3>
            <div style="display: flex; flex-wrap: wrap; gap: 15px; margin: 20px 0; justify-content: center;">
                <button data-mode="tornado" class="mode-selection-dialog-btn">Торнадо (4 списка)</button>
                <button data-mode="limited" class="mode-selection-dialog-btn">Ограниченная замена</button>
                <button data-mode="restructure" class="mode-selection-dialog-btn">Реструктуризация узла</button>
                <button data-mode="add_unit" class="mode-selection-dialog-btn">Новая штатная единица</button>
                <button data-mode="manage_positions" class="mode-selection-dialog-btn">Управление должностями</button>
                <button data-mode="manage_departments" class="mode-selection-dialog-btn">Управление отделами</button>
                <button data-mode="liquidate_department" class="mode-selection-dialog-btn">Ликвидация отделов</button>
            </div>
            <button data-mode="cancel" style="margin-top: 10px; background: transparent; color: var(--accent-color); border: none; cursor: pointer;">Отмена</button>
        `;

        const closeDialog = (mode = null) => {
            document.body.removeChild(backdrop);
            resolve(mode);
        };

        dialog.addEventListener('click', (e) => {
            if (e.target.dataset.mode) {
                closeDialog(e.target.dataset.mode === 'cancel' ? null : e.target.dataset.mode);
            }
        });

        backdrop.addEventListener('click', (e) => {
            if (e.target === backdrop) closeDialog();
        });

        backdrop.appendChild(dialog);
        document.body.appendChild(backdrop);
    });
}
showManagePositionsDialog() {
 if (!document.getElementById('manage-positions-styles')) {
 const style = document.createElement('style');
 style.id = 'manage-positions-styles';
 style.textContent = `
 .mp-backdrop { 
 position: fixed; 
 top: 0; 
 left: 0; 
 width: 100%; 
 height: 100%; 
 background: rgba(0,0,0,0.7); 
 display: flex; 
 justify-content: center; 
 align-items: center; 
 z-index: 10002; 
 backdrop-filter: blur(8px);
 }
 .mp-dialog { 
 background: var(--controls-bg); 
 padding: 25px; 
 width: 95vw; 
 height: 90vh; 
 box-sizing: border-box; 
 border-radius: 16px; 
 border: 2px solid var(--primary-color);
 display: flex; 
 flex-direction: column;
 box-shadow: 0 10px 30px rgba(0,0,0,0.3);
 overflow: hidden;
 }
 .mp-header { 
 text-align: center; 
 margin-bottom: 20px; 
 color: var(--primary-color); 
 }
 .mp-header h3 {
 margin: 0;
 font-size: 1.8rem;
 font-weight: 600;
 }
 .mp-content { 
 display: flex; 
 gap: 25px; 
 flex: 1; 
 min-height: 0; 
 }
 .mp-column { 
 display: flex; 
 flex-direction: column; 
 gap: 15px; 
 flex: 1; 
 min-width: 300px;
 background: rgba(93, 138, 168, 0.05);
 border-radius: 12px;
 padding: 15px;
 border: 1px solid var(--primary-color);
 }
 .mp-column h4 {
 margin: 0 0 15px 0;
 color: var(--primary-color);
 font-size: 1.3rem;
 text-align: center;
 padding-bottom: 8px;
 border-bottom: 2px solid var(--secondary-color);
 }
 .mp-search-input { 
 padding: 10px 12px; 
 border: 2px solid var(--secondary-color); 
 border-radius: 8px; 
 width: 100%; 
 box-sizing: border-box; 
 margin-bottom: 10px; 
 background: rgba(255, 255, 255, 0.1);
 color: var(--text-color);
 font-size: 1rem;
 }
 .mp-tree-container { 
 border: 2px solid var(--secondary-color); 
 border-radius: 10px; 
 padding: 12px; 
 flex: 1; 
 overflow-y: auto;
 background: rgba(255, 255, 255, 0.05);
 }
 .mp-footer { 
 margin-top: 20px; 
 display: flex; 
 justify-content: space-between; 
 align-items: center;
 padding-top: 15px;
 border-top: 1px solid var(--secondary-color);
 }
 .mp-actions { 
 display: flex; 
 gap: 15px; 
 }
 .mp-btn { 
 padding: 12px 24px; 
 border: none; 
 border-radius: 8px; 
 cursor: pointer; 
 font-weight: 600; 
 transition: all 0.3s ease;
 font-size: 1rem;
 }
 .mp-btn:disabled { 
 background: #666 !important; 
 cursor: not-allowed; 
 opacity: 0.6;
 }
 .mp-btn.apply { 
 background: linear-gradient(145deg, #4CAF50, #2E7D32);
 color: white; 
 box-shadow: 0 4px 6px rgba(76, 175, 80, 0.3);
 }
 .mp-btn.apply:hover:not(:disabled) {
 background: linear-gradient(145deg, #43A047, #1B5E20);
 transform: translateY(-2px);
 box-shadow: 0 6px 8px rgba(76, 175, 80, 0.4);
 }
 .mp-btn.cancel { 
 background: transparent; 
 color: var(--accent-color);
 border: 2px solid var(--accent-color);
 }
 .mp-btn.cancel:hover {
 background: rgba(255, 160, 122, 0.1);
 transform: translateY(-2px);
 }
 .mp-position-input { 
 padding: 10px 12px; 
 border: 2px solid var(--secondary-color); 
 border-radius: 8px; 
 width: 100%; 
 box-sizing: border-box; 
 margin-bottom: 12px; 
 background: rgba(255, 255, 255, 0.1);
 color: var(--text-color);
 font-size: 1rem;
 }
 .mp-position-select { 
 padding: 10px 12px; 
 border: 2px solid var(--secondary-color); 
 border-radius: 8px; 
 width: 100%; 
 box-sizing: border-box; 
 margin-bottom: 15px;
 background: rgba(255, 255, 255, 0.1);
 color: var(--text-color); 
 font-size: 1rem;
 cursor: pointer;
 position: relative;
 }
 .mp-position-select option {
 background: var(--controls-bg);
 color: var(--text-color);
 padding-right: 30px;
 position: relative;
 }
 .mp-add-position-btn { 
 padding: 10px 15px; 
 background: linear-gradient(145deg, var(--primary-color), #6B9EBF);
 color: white; 
 border: none; 
 border-radius: 8px; 
 cursor: pointer; 
 margin-bottom: 15px;
 font-weight: 600;
 transition: all 0.3s ease;
 box-shadow: 0 4px 6px rgba(93, 138, 168, 0.3);
 }
 .mp-add-position-btn:hover {
 background: linear-gradient(145deg, #6B9EBF, var(--primary-color));
 transform: translateY(-2px);
 box-shadow: 0 6px 8px rgba(93, 138, 168, 0.4);
 }
 .mp-custom-select {
 position: relative;
 margin-bottom: 15px;
 }
 .mp-select-header {
 padding: 10px 12px;
 border: 2px solid var(--secondary-color);
 border-radius: 8px;
 background: rgba(255, 255, 255, 0.1);
 color: var(--text-color);
 cursor: pointer;
 display: flex;
 justify-content: space-between;
 align-items: center;
 }
 .mp-select-dropdown {
 position: absolute;
 top: 100%;
 left: 0;
 right: 0;
 background: var(--controls-bg);
 border: 2px solid var(--secondary-color);
 border-top: none;
 border-radius: 0 0 8px 8px;
 max-height: 200px;
 overflow-y: auto;
 z-index: 1000;
 display: none;
 }
 .mp-select-option {
 padding: 10px 12px;
 display: flex;
 justify-content: space-between;
 align-items: center;
 cursor: pointer;
 border-bottom: 1px solid rgba(93, 138, 168, 0.2);
 }
 .mp-select-option:hover {
 background: rgba(93, 138, 168, 0.2);
 }
 .mp-delete-position-btn {
 background: none;
 border: none;
 color: var(--accent-color);
 cursor: pointer;
 font-size: 1.2em;
 padding: 0;
 width: 24px;
 height: 24px;
 display: flex;
 align-items: center;
 justify-content: center;
 border-radius: 50%;
 }
 .mp-delete-position-btn:hover {
 background: rgba(255, 160, 122, 0.2);
 transform: scale(1.1);
 }
 `;
 document.head.appendChild(style);
 }

 const backdrop = document.createElement('div');
 backdrop.className = 'mp-backdrop';
 const dialog = document.createElement('div');
 dialog.className = 'mp-dialog';
 dialog.innerHTML = `
 <div class="mp-header">
 <h3>Управление должностями</h3>
 </div>
 <div class="mp-content" id="mp-content-area"></div>
 <div class="mp-footer">
 <div></div>
 <div class="mp-actions">
 <button class="mp-btn cancel">Отмена</button>
 <button class="mp-btn apply" id="mp-apply-btn" disabled>Применить</button>
 </div>
 </div>
 `;
 backdrop.appendChild(dialog);
 document.body.appendChild(backdrop);

 const contentArea = dialog.querySelector('#mp-content-area');
 let selectedPosition = '';
 let selectedNodeId = null;
 const expansionState = new Set();

 let savedPositions = [];
 try {
 const positions = localStorage.getItem('treeAppPositions');
 if (positions) {
 savedPositions = JSON.parse(positions);
 }
 } catch (e) {
 console.error('Ошибка загрузки должностей:', e);
 }

 const renderColumns = () => {
 contentArea.innerHTML = '';

 const positionColumn = document.createElement('div');
 positionColumn.className = 'mp-column';

 const positionHeader = document.createElement('h4');
 positionHeader.textContent = 'Выбор должности';
 positionColumn.appendChild(positionHeader);

 const positionInput = document.createElement('input');
 positionInput.type = 'text';
 positionInput.placeholder = 'Введите новую должность';
 positionInput.className = 'mp-position-input';
 positionColumn.appendChild(positionInput);

 const addPositionBtn = document.createElement('button');
 addPositionBtn.textContent = 'Добавить должность';
 addPositionBtn.className = 'mp-add-position-btn';
 positionColumn.appendChild(addPositionBtn);

 const customSelect = document.createElement('div');
 customSelect.className = 'mp-custom-select';

 const selectHeader = document.createElement('div');
 selectHeader.className = 'mp-select-header';
 selectHeader.innerHTML = 'Выберите должность <span>▼</span>';
 customSelect.appendChild(selectHeader);

 const selectDropdown = document.createElement('div');
 selectDropdown.className = 'mp-select-dropdown';
 customSelect.appendChild(selectDropdown);

 positionColumn.appendChild(customSelect);
 contentArea.appendChild(positionColumn);

 const nodeColumn = document.createElement('div');
 nodeColumn.className = 'mp-column';

 const nodeHeader = document.createElement('h4');
 nodeHeader.textContent = 'Выбор узла';
 nodeColumn.appendChild(nodeHeader);

 const searchInput = document.createElement('input');
 searchInput.type = 'text';
 searchInput.placeholder = 'Поиск узла...';
 searchInput.className = 'mp-search-input';
 nodeColumn.appendChild(searchInput);

 const treeContainer = document.createElement('div');
 treeContainer.className = 'mp-tree-container';
 nodeColumn.appendChild(treeContainer);
 contentArea.appendChild(nodeColumn);

 // --- НАЧАЛО ИЗМЕНЕНИЙ ---

 // 1. Создаем поле поиска и контейнер для опций ОДИН РАЗ
 const positionSearchInput = document.createElement('input');
 positionSearchInput.type = 'text';
 positionSearchInput.placeholder = 'Поиск должности...';
 positionSearchInput.className = 'mp-search-input';
 positionSearchInput.style.margin = '5px';
 selectDropdown.appendChild(positionSearchInput);

 const optionsContainer = document.createElement('div');
 selectDropdown.appendChild(optionsContainer);

 // 2. Создаем функцию, которая обновляет ТОЛЬКО список опций
 const updateDropdownOptions = () => {
 optionsContainer.innerHTML = ''; // Очищаем только контейнер с опциями

 const filterText = positionSearchInput.value.toLowerCase().trim();
 const filteredPositions = filterText 
 ? savedPositions.filter(pos => pos.toLowerCase().includes(filterText))
 : savedPositions;

 const defaultOption = document.createElement('div');
 defaultOption.className = 'mp-select-option';
 defaultOption.innerHTML = '<span>Выберите должность</span>';
 defaultOption.addEventListener('click', () => {
 selectedPosition = '';
 selectHeader.innerHTML = 'Выберите должность <span>▼</span>';
 selectDropdown.style.display = 'none';
 updateApplyButton();
 });
 optionsContainer.appendChild(defaultOption);

 filteredPositions.forEach(position => {
 const option = document.createElement('div');
 option.className = 'mp-select-option';

 const textSpan = document.createElement('span');
 textSpan.textContent = position;

 const deleteBtn = document.createElement('button');
 deleteBtn.className = 'mp-delete-position-btn';
 deleteBtn.innerHTML = '&times;';
 deleteBtn.title = 'Удалить должность';

 deleteBtn.addEventListener('click', (e) => {
 e.stopPropagation();
 savedPositions = savedPositions.filter(p => p !== position);
 try {
 localStorage.setItem('treeAppPositions', JSON.stringify(savedPositions));
 } catch (e) {
 console.error('Ошибка сохранения должностей:', e);
 }
 updateDropdownOptions(); // Перерисовываем опции
 if (selectedPosition === position) {
 selectedPosition = '';
 selectHeader.innerHTML = 'Выберите должность <span>▼</span>';
 updateApplyButton();
 }
 });

 option.appendChild(textSpan);
 option.appendChild(deleteBtn);

 option.addEventListener('click', () => {
 selectedPosition = position;
 selectHeader.innerHTML = `${position} <span>▼</span>`;
 selectDropdown.style.display = 'none';
 updateApplyButton();
 });

 optionsContainer.appendChild(option);
 });
 };

 // 3. Вешаем обработчик на единственное поле поиска
 let positionSearchTimer;
 positionSearchInput.addEventListener('input', () => {
 clearTimeout(positionSearchTimer);
 positionSearchTimer = setTimeout(updateDropdownOptions, 300);
 });

 // --- КОНЕЦ ИЗМЕНЕНИЙ ---

 selectHeader.addEventListener('click', () => {
 const isVisible = selectDropdown.style.display === 'block';
 selectDropdown.style.display = isVisible ? 'none' : 'block';
 if (!isVisible) {
 updateDropdownOptions(); // Обновляем список при открытии
 positionSearchInput.focus();
 }
 });

 document.addEventListener('click', (e) => {
 if (!customSelect.contains(e.target)) {
 selectDropdown.style.display = 'none';
 }
 });

 addPositionBtn.addEventListener('click', () => {
 const newPosition = positionInput.value.trim();
 if (newPosition && !savedPositions.includes(newPosition)) {
 savedPositions.push(newPosition);
 try {
 localStorage.setItem('treeAppPositions', JSON.stringify(savedPositions));
 } catch (e) {
 console.error('Ошибка сохранения должностей:', e);
 }

 updateDropdownOptions(); // Обновляем опции
 positionInput.value = '';
 }
 });

 let nodeSearchTimer;
 const redrawTree = () => {
 const filterText = searchInput.value.toLowerCase().trim();
 this.createSingleSelectableTree(
 treeContainer,
 (nodeId) => {
 selectedNodeId = nodeId;
 updateApplyButton();
 },
 selectedNodeId,
 expansionState,
 filterText,
 false
 );
 };

 searchInput.addEventListener('input', () => {
 clearTimeout(nodeSearchTimer);
 nodeSearchTimer = setTimeout(redrawTree, 300);
 });

 redrawTree();
 updateDropdownOptions(); // Первоначальный вызов для заполнения списка

 const updateApplyButton = () => {
 const applyBtn = dialog.querySelector('#mp-apply-btn');
 applyBtn.disabled = !selectedPosition || !selectedNodeId;
 };
 };

 const closeDialog = () => document.body.removeChild(backdrop);

 dialog.querySelector('.cancel').addEventListener('click', () => {
    closeDialog();
    this.promptReplacementMode(); // Возвращаемся в главное меню
 });

 dialog.querySelector('#mp-apply-btn').addEventListener('click', () => {
 if (selectedPosition && selectedNodeId) {
 this.applyPositionToNodes(selectedPosition, selectedNodeId);
 closeDialog();
 }
 });

 backdrop.addEventListener('click', (e) => {
 if (e.target === backdrop) closeDialog();
 });

 renderColumns();
}
async showLiquidationDialog() {
    this.injectLiquidationDialogStyles();

    // Инициализация состояния для всего процесса цепочки
    this.liquidationChainState = {
        analogousNodes: [],       // Список всех узлов с одинаковым именем
        restructuredTrees: [],    // Массив для хранения измененных структур
        targetNodeId: null,         // ID целевого узла для вставки
        currentIndex: 0,          // Индекс текущего редактируемого узла
    };

    // Инициализация состояния для текущего редактора (как и было)
    this.liquidationDialogState = {
        dragMode: 'tree',
        restructuredSubtree: null,
        sourceNodeId: null,
        targetNodeId: null, // Это поле теперь будет использоваться для выбора в дереве цели
        sourceExpansionState: new Set(),
        targetExpansionState: new Set(),
        sortableInstances: []
    };

    const backdrop = document.createElement('div');
    backdrop.className = 'ld-backdrop';

    const dialog = document.createElement('div');
    dialog.className = 'ld-dialog';
   dialog.innerHTML = `
    <div class="ld-header">
        <div class="ld-drag-mode-toggle" id="ld-drag-mode-toggle" title="Переключить режим перетаскивания">
            <div class="ld-toggle-option active" data-mode="tree">Всей веткой</div>
            <div class="ld-toggle-option" data-mode="single">Только узел</div>
        </div>
        <h3 id="ld-main-header">Ликвидация и реструктуризация отделов</h3>
        <div></div> <!-- Пустой div для выравнивания по центру -->
    </div>
        <div class="ld-content">
            <div class="ld-column" id="ld-source-column">
                <h4>1. Выберите исходный узел</h4>
                <input type="text" placeholder="Поиск..." class="ld-search-input" id="ld-source-search">
                <div class="ld-tree-container" id="ld-source-tree"></div>
            </div>
            <div class="ld-column" id="ld-editor-column" style="display: none;">
                <h4 id="ld-editor-header">2. Отредактируйте структуру</h4>
                <div class="ld-tree-container ld-editor-container" id="ld-editor-tree"></div>
            </div>
            <div class="ld-column" id="ld-target-column" style="display: none;">
                <h4>3. Выберите целевой узел для вставки</h4>
                <input type="text" placeholder="Поиск..." class="ld-search-input" id="ld-target-search">
                <div class="ld-tree-container" id="ld-target-tree"></div>
            </div>
        </div>
    <div class="ld-footer">
            <div>
                 <button class="ld-btn ld-back-btn" style="display: none;">← Назад к выбору</button>
                 <button class="ld-btn ld-step-back-btn" style="display: none;">↩ Шаг назад</button>
            </div>
            <div>
                <button class="ld-btn ld-cancel">Отмена</button>
                <button class="ld-btn ld-confirm" id="ld-confirm-btn" disabled>Далее</button>
            </div>
        </div>
    `;
    backdrop.appendChild(dialog);
    document.body.appendChild(backdrop);

    // Получение элементов управления
    const mainHeader = dialog.querySelector('#ld-main-header');
    const sourceColumn = dialog.querySelector('#ld-source-column');
    const editorColumn = dialog.querySelector('#ld-editor-column');
    const editorHeader = dialog.querySelector('#ld-editor-header');
    const targetColumn = dialog.querySelector('#ld-target-column');
    const sourceSearch = dialog.querySelector('#ld-source-search');
    const sourceTreeContainer = dialog.querySelector('#ld-source-tree');
    const targetSearch = dialog.querySelector('#ld-target-search');
    const targetTreeContainer = dialog.querySelector('#ld-target-tree');
    const confirmBtn = dialog.querySelector('#ld-confirm-btn');
    const cancelBtn = dialog.querySelector('.ld-cancel');
    const toggle = dialog.querySelector('#ld-drag-mode-toggle');
    const toggleOptions = dialog.querySelectorAll('.ld-toggle-option');
    const backBtn = dialog.querySelector('.ld-back-btn');
    const stepBackBtn = dialog.querySelector('.ld-step-back-btn'); // Новая кнопка

    const closeDialog = () => {
        if (this.liquidationDialogState.sortableInstances) {
            this.liquidationDialogState.sortableInstances.forEach(instance => instance.destroy());
        }
        if (document.body.contains(backdrop)) {
            document.body.removeChild(backdrop);
        }
    };

    // Логика кнопки "Шаг назад"
    stepBackBtn.addEventListener('click', () => {
        if (this.liquidationChainState.currentIndex > 0) {
            // Уменьшаем индекс текущего шага
            this.liquidationChainState.currentIndex--;

            // Удаляем последнюю сохраненную структуру из массива [1, 2, 3]
            this.liquidationChainState.restructuredTrees.pop();

            // Загружаем предыдущий узел для редактирования
            const { currentIndex, analogousNodes } = this.liquidationChainState;
            const prevNode = analogousNodes[currentIndex];

            // Восстанавливаем состояние редактора из предыдущего шага, если оно есть, или из оригинала
            const prevState = this.liquidationChainState.restructuredTrees[currentIndex];
            this.liquidationDialogState.restructuredSubtree = JSON.parse(JSON.stringify(prevState || prevNode));

            // Обновляем UI
            editorHeader.textContent = `2. Редактирование ${currentIndex + 1} из ${analogousNodes.length}: "${prevNode.content.text}"`;
            this.renderEditableTree();
            confirmBtn.textContent = 'Далее';
            stepBackBtn.style.display = currentIndex > 0 ? 'inline-block' : 'none';
        }
    });

    backBtn.addEventListener('click', () => {
        // Восстанавливаем сохраненное состояние
        if (this.liquidationDialogState.initialTreeData) {
            this.treeData = this.liquidationDialogState.initialTreeData;
            this.clusters = this.liquidationDialogState.initialClusters;
        }

        // Сбрасываем состояния
        this.liquidationChainState = {
            analogousNodes: [],
            restructuredTrees: [],
            targetNodeId: null,
            currentIndex: 0,
        };
        this.liquidationDialogState.restructuredSubtree = null;

        // Возвращаем UI в исходное состояние
        sourceColumn.style.display = 'flex';
        editorColumn.style.display = 'none';
        targetColumn.style.display = 'none';
        backBtn.style.display = 'none';
        stepBackBtn.style.display = 'none'; // Скрываем новую кнопку
        mainHeader.textContent = 'Ликвидация и реструктуризация отделов';
        confirmBtn.textContent = 'Далее';
        confirmBtn.disabled = true;

        // Перерисовываем дерево выбора
        redrawSourceTree();
        this.showNotification('Операция отменена. Вы вернулись к выбору узла.');
    });

    cancelBtn.addEventListener('click', () => {
        closeDialog();
        this.promptReplacementMode(); // Возвращаемся в главное меню
    });
    backdrop.addEventListener('click', (e) => { if (e.target === backdrop) closeDialog(); });
    toggle.addEventListener('click', () => {
        this.liquidationDialogState.dragMode = this.liquidationDialogState.dragMode === 'tree' ? 'single' : 'tree';
        toggleOptions.forEach(opt => opt.classList.toggle('active', opt.dataset.mode === this.liquidationDialogState.dragMode));
    });

    // Функция для обновления состояния кнопки "Далее/Завершить"
    const updateConfirmButtonState = () => {
        const isTargetSelected = !!this.liquidationChainState.targetNodeId;
        confirmBtn.disabled = !isTargetSelected;
    };

    // Рендеринг дерева выбора исходного узла
    const redrawSourceTree = () => {
        const filterText = sourceSearch.value.toLowerCase().trim();
        this.createSingleSelectableTree(
            sourceTreeContainer,
            (nodeId) => {
                if (!nodeId) return;

                const node = this.findNode(this.treeData, nodeId);
                if (!node) return;
                this.liquidationDialogState.initialTreeData = JSON.parse(JSON.stringify(this.treeData));
                this.liquidationDialogState.initialClusters = new Map(this.clusters);

                this.liquidationChainState.analogousNodes = this.findAllNodesByName(this.treeData, node.content.text);
                const totalNodes = this.liquidationChainState.analogousNodes.length;

                if (totalNodes > 0) {
                    // Инициализируем процесс
                    this.liquidationChainState.currentIndex = 0;
                    const firstNode = this.liquidationChainState.analogousNodes[0];

                    // Настраиваем редактор для первого узла
                    this.liquidationDialogState.restructuredSubtree = JSON.parse(JSON.stringify(firstNode));
                    editorHeader.textContent = `2. Редактирование ${this.liquidationChainState.currentIndex + 1} из ${totalNodes}: "${firstNode.content.text}"`;
                    editorColumn.style.display = 'flex';
                    this.renderEditableTree();

                    // Показываем выбор цели
                    targetColumn.style.display = 'flex';
                    sourceColumn.style.display = 'none'; // Скрываем выбор источника
                    mainHeader.textContent = 'Реструктуризация по наименованию';
                    backBtn.style.display = 'inline-block';
                    stepBackBtn.style.display = 'none'; // Скрыта на первом шаге
                    if (totalNodes === 1) {
                        confirmBtn.textContent = 'Завершить';
                    }
                }
            },
            null, this.liquidationDialogState.sourceExpansionState, filterText, false
        );
    };

    // Рендеринг дерева выбора целевого узла
    const redrawTargetTree = () => {
        const filterText = targetSearch.value.toLowerCase().trim();
        this.createSingleSelectableTree(
            targetTreeContainer,
            (nodeId) => {
                this.liquidationChainState.targetNodeId = nodeId;
                updateConfirmButtonState();
            },
            this.liquidationChainState.targetNodeId, this.liquidationDialogState.targetExpansionState, filterText, false
        );
    };

    // Обработчики для полей поиска
    sourceSearch.addEventListener('input', redrawSourceTree);
    targetSearch.addEventListener('input', redrawTargetTree);

    // Основная логика кнопки "Далее/Завершить"
    confirmBtn.addEventListener('click', () => {
        // 1. Сохраняем текущую отредактированную структуру
        let currentStructure = this.liquidationDialogState.restructuredSubtree;
        if (currentStructure) {
            this.liquidationChainState.restructuredTrees.push(JSON.parse(JSON.stringify(currentStructure)));
        }

        // 2. Переходим к следующему узлу
        this.liquidationChainState.currentIndex++;
        const { currentIndex, analogousNodes } = this.liquidationChainState;
        const totalNodes = analogousNodes.length;

        if (currentIndex < totalNodes) {
            // Если есть еще узлы для редактирования
            const nextNode = analogousNodes[currentIndex];
            this.liquidationDialogState.restructuredSubtree = JSON.parse(JSON.stringify(nextNode));
            editorHeader.textContent = `2. Редактирование ${currentIndex + 1} из ${totalNodes}: "${nextNode.content.text}"`;
            this.renderEditableTree(); // Перерисовываем редактор

            // Показываем кнопку "Шаг назад"
            stepBackBtn.style.display = 'inline-block';

            // Если это последний узел, меняем текст кнопки
            if (currentIndex === totalNodes - 1) {
                confirmBtn.textContent = 'Завершить';
            }
        } else {
            // Если все узлы обработаны
            this.executeChainedLiquidation();
            closeDialog();
        }
    });

    // Первоначальный рендеринг
    redrawSourceTree();
    redrawTargetTree();
}
findNodeAndParentInSubtree(startNodeOrArray, nodeId) {
    let result = { node: null, parent: null };

    const findRecursive = (current, parent) => {
        if (current.id === nodeId) {
            result = { node: current, parent: parent };
            return true;
        }
        if (current.children) {
            for (const child of current.children) {
                if (findRecursive(child, current)) {
                    return true;
                }
            }
        }
        return false;
    };

    if (Array.isArray(startNodeOrArray)) {
        for (const rootNode of startNodeOrArray) {
            if (findRecursive(rootNode, null)) {
                break;
            }
        }
    } else if (startNodeOrArray) {
        findRecursive(startNodeOrArray, null);
    }

    return result;
}
deleteNodeAndPromoteChildrenInDialog(nodeId) {
    const { node, parent } = this.findNodeAndParentInSubtree(this.liquidationDialogState.restructuredSubtree, nodeId);

    if (!node) {
        this.showNotification('Узел не найден.', 'error');
        return;
    }

    // Получаем дочерние элементы, которые нужно "повысить". Если их нет, будет пустой массив.
    const childrenToPromote = node.children || [];

    if (parent) {
        // Сценарий 1: Удаляемый узел является дочерним.
        const index = parent.children.findIndex(child => child.id === nodeId);
        if (index !== -1) {
            // Заменяем один узел (deleteCount = 1) на все его дочерние элементы.
            // Метод splice идеально подходит для замены одного элемента в массиве на несколько других [1, 2, 5].
            // Мы используем оператор spread (...), чтобы передать дочерние элементы как отдельные аргументы.
            parent.children.splice(index, 1, ...childrenToPromote);
        }
    } else {
        // Сценарий 2: Удаляемый узел является корневым в редакторе.
        let subtree = this.liquidationDialogState.restructuredSubtree;
        if (!Array.isArray(subtree)) {
            // Если это был единственный корневой узел, его дочерние элементы становятся новым корнем.
            this.liquidationDialogState.restructuredSubtree = childrenToPromote;
        } else {
            // Если это один из нескольких корневых узлов, заменяем его на его детей.
            const index = subtree.findIndex(rootNode => rootNode.id === nodeId);
            if (index !== -1) {
                subtree.splice(index, 1, ...childrenToPromote);
            }
        }
    }

    this.showNotification(`Узел "${node.content.text}" удален, дочерние элементы повышены.`);
    // Эта существующая функция перерисует дерево и нормализует структуру данных.
    this.normalizeAndRedrawLiquidationTree();
}
cloneSingleNode(node) {
    // Поверхностное копирование объекта узла, но с пустым массивом children
    const clone = {
        ...node,
        content: { ...node.content }, // Также копируем объект content
        children: [], // Гарантируем, что дочерние узлы не переносятся
        id: this.generateId() // Генерируем новый уникальный ID
    };
    return clone;
}
deepCloneNode(node) {
    // Глубокое клонирование через JSON для создания полной копии
    const clone = JSON.parse(JSON.stringify(node));

    // Рекурсивная функция для обновления ID у всех узлов в клонированной ветке
    const regenerateIds = (n) => {
        n.id = this.generateId(); // Используем ваш существующий генератор ID
        if (n.children) {
            n.children.forEach(regenerateIds);
        }
    };
    regenerateIds(clone);
    return clone;
}
renderEditableTree() {
    const editorTreeContainer = document.getElementById('ld-editor-tree');
    if (!editorTreeContainer) return;

    if (this.liquidationDialogState && this.liquidationDialogState.sortableInstances) {
        this.liquidationDialogState.sortableInstances.forEach(instance => instance.destroy());
    }
    this.liquidationDialogState.sortableInstances = [];
    editorTreeContainer.innerHTML = '';

    if (!this.liquidationDialogState.restructuredSubtree) return;

    const createEditableNodeRecursive = (node, parentElement) => {
        const nodeEl = document.createElement('div');
        nodeEl.className = 'ld-editable-node';
        nodeEl.dataset.id = node.id;

        const contentWrapper = document.createElement('div');
        contentWrapper.className = 'ld-editable-content';

        const handle = document.createElement('span');
        handle.className = 'ld-drag-handle';
        handle.textContent = '☰';
        handle.title = 'Перетащить';
        contentWrapper.appendChild(handle);

        const span = document.createElement('span');
        span.className = 'ld-node-text';
        span.textContent = node.content.text;
        contentWrapper.appendChild(span);

        const controls = document.createElement('div');
        controls.className = 'ld-node-controls';

        // --- НАЧАЛО ИЗМЕНЕНИЙ ---

        // 1. Новая кнопка "Дублировать"
        const duplicateBtn = document.createElement('button');
        duplicateBtn.className = 'ld-node-btn';
        duplicateBtn.innerHTML = '⎘'; // Символ "копировать"
        duplicateBtn.title = 'Дублировать узел (с дочерними)';
        duplicateBtn.addEventListener('click', (e) => {
            e.stopPropagation();
            this.duplicateNodeInDialog(node.id); // Вызов новой функции
        });
        controls.appendChild(duplicateBtn);

        // 2. Существующая кнопка "Удалить с повышением"
        const promoteDeleteBtn = document.createElement('button');
        promoteDeleteBtn.className = 'ld-node-btn';
        promoteDeleteBtn.innerHTML = '⏏';
        promoteDeleteBtn.title = 'Удалить узел, подняв дочерние';
        promoteDeleteBtn.addEventListener('click', (e) => {
            e.stopPropagation();
            this.deleteNodeAndPromoteChildrenInDialog(node.id);
        });
        controls.appendChild(promoteDeleteBtn);

        // 3. Добавляем контейнер с кнопками к узлу (исправление)
        contentWrapper.appendChild(controls);

        // --- КОНЕЦ ИЗМЕНЕНИЙ ---

        nodeEl.appendChild(contentWrapper);

        const childrenContainer = document.createElement('div');
        childrenContainer.className = 'ld-editable-children';
        nodeEl.appendChild(childrenContainer);

        parentElement.appendChild(nodeEl);

        const sortableOptions = {
            group: 'liquidation-group',
            animation: 150,
            handle: '.ld-drag-handle',
            fallbackOnBody: true,
            swapThreshold: 0.65,
            ghostClass: "ld-ghost-base",
            dragClass: "sortable-drag",
            onStart: (evt) => {
                if (this.liquidationDialogState.dragMode === 'single') {
                    evt.item.classList.add('single-drag-visual');
                } else {
                    evt.item.classList.remove('single-drag-visual');
                }
            },
            onEnd: (evt) => this.handleDragEnd(evt),
        };

        const sortableChildren = new Sortable(childrenContainer, sortableOptions);
        this.liquidationDialogState.sortableInstances.push(sortableChildren);

        if (node.children && node.children.length > 0) {
            node.children.forEach(child => createEditableNodeRecursive(child, childrenContainer));
        }
    };

    const rootSortableOptions = {
        group: 'liquidation-group',
        animation: 150,
        handle: '.ld-drag-handle',
        fallbackOnBody: true,
        swapThreshold: 0.65,
        ghostClass: "ld-ghost-base",
        dragClass: "sortable-drag",
        onStart: (evt) => {
            if (this.liquidationDialogState.dragMode === 'single') {
                evt.item.classList.add('single-drag-visual');
            } else {
                evt.item.classList.remove('single-drag-visual');
            }
        },
        onEnd: (evt) => this.handleDragEnd(evt),
    };

    const sortableRoot = new Sortable(editorTreeContainer, rootSortableOptions);
    this.liquidationDialogState.sortableInstances.push(sortableRoot);

    let subtree = this.liquidationDialogState.restructuredSubtree;
    if (Array.isArray(subtree)) {
        subtree.forEach(node => createEditableNodeRecursive(node, editorTreeContainer));
    } else if (subtree) {
        createEditableNodeRecursive(subtree, editorTreeContainer);
    }
}
duplicateNodeInDialog(nodeId) {
    // Находим узел и его родителя в структуре данных диалогового окна
    const { node, parent } = this.findNodeAndParentInSubtree(this.liquidationDialogState.restructuredSubtree, nodeId);

    if (!node) {
        this.showNotification('Не удалось найти узел для дублирования.', 'error');
        return;
    }

    // Создаем полную "глубокую" копию узла, рекурсивно присваивая новые ID
    const clonedNode = this.deepCloneNode(node);

    if (parent) {
        // Если узел является дочерним, вставляем копию сразу после оригинала
        const index = parent.children.findIndex(child => child.id === nodeId);
        if (index !== -1) {
            parent.children.splice(index + 1, 0, clonedNode);
        }
    } else {
        // Если узел является корневым в редакторе
        let subtree = this.liquidationDialogState.restructuredSubtree;
        if (Array.isArray(subtree)) {
            // Если в корне массив узлов, вставляем копию после оригинала
            const index = subtree.findIndex(rootNode => rootNode.id === nodeId);
            if (index !== -1) {
                subtree.splice(index + 1, 0, clonedNode);
            }
        } else {
            // Если в корне был один узел, преобразуем его в массив с оригиналом и копией
            this.liquidationDialogState.restructuredSubtree = [subtree, clonedNode];
        }
    }

    this.showNotification(`Узел "${node.content.text}" дублирован.`);
    // Перерисовываем дерево в редакторе, чтобы отобразить изменения
    this.normalizeAndRedrawLiquidationTree();
}
resetNodeLevel(nodeId) {
    const { node, parent } = this.findNodeAndParentInSubtree(this.liquidationDialogState.restructuredSubtree, nodeId);
    if (!node) return;

    let subtree = this.liquidationDialogState.restructuredSubtree;
    // Для единообразия всегда работаем с корневым массивом
    if (!Array.isArray(subtree)) {
        subtree = [subtree];
    }

    if (parent) { // --- Сценарий 1: Узел является дочерним ---
        // Стандартное действие: повысить узел до уровня родителя, ставя его ПОСЛЕ родителя
        const grandparent = this.findNodeAndParentInSubtree(this.liquidationDialogState.restructuredSubtree, parent.id).parent;
        const nodeIndex = parent.children.findIndex(child => child.id === nodeId);
        const [nodeToMove] = parent.children.splice(nodeIndex, 1);

        if (grandparent) {
            const parentIndex = grandparent.children.findIndex(p => p.id === parent.id);
            grandparent.children.splice(parentIndex + 1, 0, nodeToMove);
        } else {
            const parentIndex = subtree.findIndex(p => p.id === parent.id);
            subtree.splice(parentIndex + 1, 0, nodeToMove);
        }
        this.showNotification(`"${node.content.text}" перемещен на уровень выше`);
    } else { // --- Сценарий 2: Узел является корневым ---
        const nodeIndex = subtree.findIndex(n => n.id === nodeId);

        if (nodeIndex < subtree.length - 1) {
            // Стандартное действие: переместить узел вправо (поменять местами с соседом)
            [subtree[nodeIndex], subtree[nodeIndex + 1]] = [subtree[nodeIndex + 1], subtree[nodeIndex]];
            this.showNotification(`"${node.content.text}" перемещен вправо`);
        } else if (subtree.length > 1) {
            // Граничный случай (последний узел): циклически переместить в начало списка
            const [nodeToMove] = subtree.splice(nodeIndex, 1);
            subtree.unshift(nodeToMove);
            this.showNotification(`"${node.content.text}" перемещен в начало списка`);
        }
    }

    this.liquidationDialogState.restructuredSubtree = subtree;
    this.normalizeAndRedrawLiquidationTree();
}
demoteNodeLevel(nodeId) {
    const { node, parent } = this.findNodeAndParentInSubtree(this.liquidationDialogState.restructuredSubtree, nodeId);
    if (!node) return;

    let subtree = this.liquidationDialogState.restructuredSubtree;
    // Для единообразия всегда работаем с корневым массивом
    if (!Array.isArray(subtree)) {
        subtree = [subtree];
    }

    if (parent) { // --- Сценарий 1: Узел является дочерним ---
        const siblings = parent.children;
        const nodeIndex = siblings.findIndex(n => n.id === nodeId);

        if (nodeIndex > 0) {
            // Стандартное действие: сделать узел дочерним для предыдущего соседа
            const newParent = siblings[nodeIndex - 1];
            if (!newParent.children) newParent.children = [];
            const [nodeToMove] = siblings.splice(nodeIndex, 1);
            newParent.children.push(nodeToMove);
            this.showNotification(`"${node.content.text}" стал дочерним для "${newParent.content.text}"`);
        } else {
            // Граничный случай (первый ребенок): повышаем узел до уровня родителя, ставя его ПЕРЕД родителем
            const grandparent = this.findNodeAndParentInSubtree(this.liquidationDialogState.restructuredSubtree, parent.id).parent;
            const [nodeToMove] = siblings.splice(nodeIndex, 1);

            if (grandparent) {
                const parentIndex = grandparent.children.findIndex(p => p.id === parent.id);
                grandparent.children.splice(parentIndex, 0, nodeToMove);
            } else {
                const parentIndex = subtree.findIndex(p => p.id === parent.id);
                subtree.splice(parentIndex, 0, nodeToMove);
            }
            this.showNotification(`"${node.content.text}" перемещен на уровень выше`);
        }
    } else { // --- Сценарий 2: Узел является корневым ---
        const nodeIndex = subtree.findIndex(n => n.id === nodeId);

        if (nodeIndex > 0) {
            // Стандартное действие: переместить узел влево (поменять местами с соседом)
            [subtree[nodeIndex], subtree[nodeIndex - 1]] = [subtree[nodeIndex - 1], subtree[nodeIndex]];
            this.showNotification(`"${node.content.text}" перемещен влево`);
        } else if (subtree.length > 1) {
            // Граничный случай (первый узел): циклически переместить в конец списка
            const [nodeToMove] = subtree.splice(nodeIndex, 1);
            subtree.push(nodeToMove);
            this.showNotification(`"${node.content.text}" перемещен в конец списка`);
        }
    }

    this.liquidationDialogState.restructuredSubtree = subtree;
    this.normalizeAndRedrawLiquidationTree();
}
handleNativeDrop(evt, dropZoneElement) {
    evt.preventDefault();
    evt.stopPropagation();

    const draggedNodeId = parseInt(evt.dataTransfer.getData("text/plain"), 10);

    // 1. Находим узел, который перетаскиваем, и его текущего родителя.
    const { node: draggedNode, parent: oldParent } = this.findNodeAndParentInSubtree(this.liquidationDialogState.restructuredSubtree, draggedNodeId);

    if (!draggedNode) {
        console.error("Перетаскиваемый узел не найден.");
        return;
    }

    // 2. Определяем целевой узел (на который бросили).
    const targetNodeElement = dropZoneElement.closest('.ld-editable-node');
    let targetNode = null;

    if (targetNodeElement) {
        const targetNodeId = parseInt(targetNodeElement.dataset.id, 10);

        // Проверка: нельзя бросить узел сам на себя.
        if (targetNodeId === draggedNodeId) {
            return;
        }

        // Проверка: нельзя бросить родительский узел внутрь одного из его потомков.
        const potentialTargetNode = this.findNodeAndParentInSubtree(this.liquidationDialogState.restructuredSubtree, targetNodeId).node;
        if (this.isDescendant(draggedNode, targetNodeId)) {
             this.showNotification("Ошибка: Нельзя переместить родительский узел внутрь дочернего.", "error");
             return;
        }
        targetNode = potentialTargetNode;
    }

    // --- НОВАЯ ЛОГИКА ПОДДЕРЖКИ МАССОВОГО ПЕРЕТАСКИВАНИЯ ---
    // Используем флаг из состояния диалога
    const isTreeDrag = this.liquidationDialogState.currentDragIsTree || false;

    if (isTreeDrag) {
        // Массовое перетаскивание: перемещаем узел со всеми детьми
        // Удаляем узел из его старого места
        if (oldParent) {
            oldParent.children = oldParent.children.filter(child => child.id !== draggedNodeId);
        } else {
            // Если узел был в корне редактора
            let subtree = this.liquidationDialogState.restructuredSubtree;
            if (Array.isArray(subtree)) {
                this.liquidationDialogState.restructuredSubtree = subtree.filter(n => n.id !== draggedNodeId);
            } else if (subtree && subtree.id === draggedNodeId) {
                this.liquidationDialogState.restructuredSubtree = null;
            }
        }

        // Добавляем узел (со всеми его детьми) в новое место
        if (targetNode) {
            if (!targetNode.children) {
                targetNode.children = [];
            }
            targetNode.children.push(draggedNode);
        } else {
            // Если бросили не на узел, а в корневую область редактора
            let subtree = this.liquidationDialogState.restructuredSubtree;
            if (!Array.isArray(subtree)) {
                subtree = subtree ? [subtree] : [];
            }
            subtree.push(draggedNode);
            this.liquidationDialogState.restructuredSubtree = subtree;
        }
    } else {
        // Одиночное перетаскивание: перемещаем только узел, дети "повышаются"
        const childrenToPromote = draggedNode.children || [];
        
        // Удаляем узел из его старого места
        if (oldParent) {
            const index = oldParent.children.findIndex(child => child.id === draggedNodeId);
            if (index !== -1) {
                // Заменяем узел на его детей
                oldParent.children.splice(index, 1, ...childrenToPromote);
            }
        } else {
            // Если узел был в корне редактора
            let subtree = this.liquidationDialogState.restructuredSubtree;
            if (Array.isArray(subtree)) {
                const index = subtree.findIndex(n => n.id === draggedNodeId);
                if (index !== -1) {
                    subtree.splice(index, 1, ...childrenToPromote);
                }
            } else if (subtree && subtree.id === draggedNodeId) {
                // Если это был единственный корневой узел
                this.liquidationDialogState.restructuredSubtree = childrenToPromote;
            }
        }

        // Добавляем "обезглавленный" узел в новое место
        const nodeToMove = { ...draggedNode, children: [] };
        if (targetNode) {
            if (!targetNode.children) {
                targetNode.children = [];
            }
            targetNode.children.push(nodeToMove);
        } else {
            // Если бросили не на узел, а в корневую область редактора
            let subtree = this.liquidationDialogState.restructuredSubtree;
            if (!Array.isArray(subtree)) {
                subtree = subtree ? [subtree] : [];
            }
            subtree.push(nodeToMove);
            this.liquidationDialogState.restructuredSubtree = subtree;
        }
    }
    
    // Сбрасываем флаг после использования
    this.liquidationDialogState.currentDragIsTree = false;
    
    // 5. Перерисовываем дерево в редакторе с новой структурой.
    this.normalizeAndRedrawLiquidationTree();
}
replaceNodeWithItsChildrenInDialog(nodeId) {
    // Находим узел и его родителя в структуре данных редактора
    const { node, parent } = this.findNodeAndParentInSubtree(this.liquidationDialogState.restructuredSubtree, nodeId);
    if (!node) return; // Если узел не найден, ничего не делаем

    // Получаем дочерние узлы, которые нужно "повысить"
    const childrenToPromote = node.children || [];

    if (parent) {
        // Сценарий 1: Узел находится внутри другого узла
        const index = parent.children.findIndex(child => child.id === nodeId);
        if (index !== -1) {
            // Заменяем один узел (node) на массив его дочерних узлов (childrenToPromote)
            parent.children.splice(index, 1, ...childrenToPromote);
        }
    } else {
        // Сценарий 2: Узел является корневым в редакторе
        let subtree = this.liquidationDialogState.restructuredSubtree;
        if (Array.isArray(subtree)) {
            const index = subtree.findIndex(n => n.id === nodeId);
            if (index !== -1) {
                // Заменяем корневой узел на его дочерние, которые также становятся корневыми
                subtree.splice(index, 1, ...childrenToPromote);
            }
        } else if (subtree && subtree.id === nodeId) {
            // Если это был единственный корневой узел, его дочерние элементы становятся новым корнем
            this.liquidationDialogState.restructuredSubtree = childrenToPromote;
        }
    }
}
handleDragEnd(evt) {
    // Предотвращаем стандартную обработку
    evt.preventDefault();
    evt.stopPropagation();

    const isTreeDrag = this.liquidationDialogState.dragMode === 'tree';
    const itemId = parseInt(evt.item.dataset.id, 10);
    const oldIndex = evt.oldDraggableIndex;
    const newIndex = evt.newDraggableIndex;

    // Определяем старого и нового родителя по DOM-структуре
    const oldParentEl = evt.from.closest('.ld-editable-node');
    const newParentEl = evt.to.closest('.ld-editable-node');
    const oldParentId = oldParentEl ? parseInt(oldParentEl.dataset.id, 10) : null;
    const newParentId = newParentEl ? parseInt(newParentEl.dataset.id, 10) : null;

    // Проверка на недопустимое действие: перемещение родителя в своего же потомка
    const { node: draggedNodeData } = this.findNodeAndParentInSubtree(this.liquidationDialogState.restructuredSubtree, itemId);
    if (newParentId && draggedNodeData && this.isDescendant(draggedNodeData, newParentId)) {
        this.showNotification("Ошибка: Нельзя переместить родительский узел внутрь дочернего.", "error");
        // Отменяем действие, возвращая элемент на место
        evt.from.insertBefore(evt.item, evt.from.children[evt.oldIndex]);
        return;
    }

    // --- ОСНОВНАЯ ЛОГИКА ---

    // 1. Извлекаем узел из его старой позиции в структуре данных
    let draggedNode;
    if (oldParentId) {
        const { node: oldParent } = this.findNodeAndParentInSubtree(this.liquidationDialogState.restructuredSubtree, oldParentId);
        if (oldParent && oldParent.children) {
            [draggedNode] = oldParent.children.splice(oldIndex, 1);
        }
    } else {
        // Если узел был в корне редактора
        let subtree = this.liquidationDialogState.restructuredSubtree;
        if (Array.isArray(subtree)) {
            [draggedNode] = subtree.splice(oldIndex, 1);
        } else if (subtree && subtree.id === itemId) {
            draggedNode = this.liquidationDialogState.restructuredSubtree;
            this.liquidationDialogState.restructuredSubtree = []; // Корень теперь пуст (в виде массива)
        }
    }

    if (!draggedNode) {
        console.error("Не удалось найти перетаскиваемый узел в структуре данных. Отмена операции.");
        // Отменяем DOM-изменение, если что-то пошло не так
        evt.from.insertBefore(evt.item, evt.from.children[evt.oldIndex]);
        return;
    }

    // 2. Обрабатываем узел в зависимости от режима перетаскивания
    if (!isTreeDrag) {
        // Режим "Только узел": "обезглавливаем" узел и "повышаем" его детей.
        const childrenToPromote = draggedNode.children || [];
        draggedNode.children = []; // Обезглавливаем.

        // Вставляем "повышенных" детей на старое место их родителя.
        if (oldParentId) {
            const { node: oldParent } = this.findNodeAndParentInSubtree(this.liquidationDialogState.restructuredSubtree, oldParentId);
            if (oldParent && oldParent.children) {
                oldParent.children.splice(oldIndex, 0, ...childrenToPromote);
            }
        } else {
            let subtree = this.liquidationDialogState.restructuredSubtree;
            if (!Array.isArray(subtree)) subtree = subtree ? [subtree] : [];
            subtree.splice(oldIndex, 0, ...childrenToPromote);
            this.liquidationDialogState.restructuredSubtree = subtree;
        }
    }

    // 3. Вставляем обработанный узел в новую позицию в структуре данных
    if (newParentId) {
        // Если есть новый родитель (узел бросили ВНУТРЬ другого узла)
        const { node: newParent } = this.findNodeAndParentInSubtree(this.liquidationDialogState.restructuredSubtree, newParentId);
        if (newParent) {
            if (!newParent.children) newParent.children = [];
            newParent.children.splice(newIndex, 0, draggedNode);
        }
    } else {
        // Если нового родителя нет, вставляем узел в корень редактора
        let subtree = this.liquidationDialogState.restructuredSubtree;
        if (!Array.isArray(subtree)) subtree = subtree ? [subtree] : [];
        subtree.splice(newIndex, 0, draggedNode);
        this.liquidationDialogState.restructuredSubtree = subtree;
    }

    // 4. Финальная нормализация данных и перерисовка всего дерева в редакторе
    this.normalizeAndRedrawLiquidationTree();
}
normalizeAndRedrawLiquidationTree() {
    let finalSubtree = this.liquidationDialogState.restructuredSubtree;
    if (Array.isArray(finalSubtree) && finalSubtree.length === 1) {
        this.liquidationDialogState.restructuredSubtree = finalSubtree[0];
    } else if (Array.isArray(finalSubtree) && finalSubtree.length === 0) {
        this.liquidationDialogState.restructuredSubtree = null;
    }

    this.showNotification('Структура в редакторе обновлена');
    this.renderEditableTree();
}
isDescendant(node, ancestorId) {
    if (node.id === ancestorId) return true;

    for (const child of node.children) {
        if (this.isDescendant(child, ancestorId)) {
            return true;
        }
    }
    return false;
}
executeChainedLiquidation() {
    this.saveToHistory(false, true);

    const { analogousNodes, restructuredTrees, targetNodeId } = this.liquidationChainState;

    const targetNode = this.findNode(this.treeData, targetNodeId);
    if (!targetNode) {
        this.showNotification("Ошибка: Целевой узел не найден.", "error");
        return;
    }

    // 1. Собираем ID всех оригинальных узлов для удаления
    const originalNodeIds = new Set(analogousNodes.map(node => node.id));

    // 2. Удаляем все оригинальные узлы из дерева
    const removeRecursive = (parent) => {
        parent.children = parent.children.filter(child => !originalNodeIds.has(child.id));
        parent.children.forEach(removeRecursive);
    };
    removeRecursive(this.treeData);

    // 3. Вставляем все отредактированные и клонированные структуры в целевой узел
    if (!targetNode.children) {
        targetNode.children = [];
    }

    restructuredTrees.forEach(treeToInsert => {
        // Для каждого сохраненного дерева создаем глубокую копию с новыми ID [5, 9, 10, 12, 13]
        const clonedTree = this.deepCloneNode(treeToInsert);
        const nodesToInsert = Array.isArray(clonedTree) ? clonedTree : [clonedTree];
        targetNode.children.push(...nodesToInsert);
    });

    targetNode.isExpanded = true;

    this.logAction(`Массовая реструктуризация для "${analogousNodes[0].content.text}": ${analogousNodes.length} узлов перенесено в "${targetNode.content.text}"`);
    this.showNotification(`Операция завершена: ${analogousNodes.length} структур успешно перенесено.`);

    // 4. Обновляем и сохраняем
    this.updateTree();
    this.saveData();
}
executeLiquidation() {
    console.warn("Вызвана устаревшая функция executeLiquidation. Используйте executeChainedLiquidation.");
}
findAllNodesByName(startNode, name) {
    let results = [];
    const findRecursive = (node) => {
        if (node.content.text === name) {
            results.push(node);
        }
        if (node.children) {
            node.children.forEach(findRecursive);
        }
    };
    findRecursive(startNode);
    return results;
}
async confirmMassRestructure(nodeName, count) {
    return new Promise(resolve => {
        if (document.getElementById('mass-restructure-confirm-dialog')) {
            resolve(false);
            return;
        }

        const backdrop = document.createElement('div');
        backdrop.id = 'mass-restructure-confirm-dialog';
        backdrop.style.cssText = `
            position: fixed; top: 0; left: 0; width: 100%; height: 100%;
            background: rgba(0,0,0,0.6); display: flex; justify-content: center;
            align-items: center; z-index: 10005; backdrop-filter: blur(5px);
        `;

        const dialog = document.createElement('div');
        dialog.style.cssText = `
            background: var(--controls-bg); padding: 25px; border-radius: 12px;
            box-shadow: 0 5px 20px rgba(0,0,0,0.25); text-align: center;
            border: 1px solid var(--primary-color); animation: dialog-appear 0.3s ease-out;
            max-width: 450px;
        `;

        dialog.innerHTML = `
            <h3 style="margin-top: 0; color: var(--primary-color);">Массовая реструктуризация</h3>
            <p>Найдены другие узлы (${count} шт.) с таким же именем: "<strong>${nodeName}</strong>".</p>
            <p>Применить выполненную реструктуризацию ко всем этим узлам?</p>
            <div style="display: flex; justify-content: center; gap: 15px; margin-top: 25px;">
                <button id="confirm-yes" class="ld-btn ld-confirm">Да, применить ко всем</button>
                <button id="confirm-no" class="ld-btn ld-cancel">Нет, только этот</button>
            </div>
        `;

        const closeDialog = (result) => {
            document.body.removeChild(backdrop);
            resolve(result);
        };

        dialog.querySelector('#confirm-yes').addEventListener('click', () => closeDialog(true));
        dialog.querySelector('#confirm-no').addEventListener('click', () => closeDialog(false));
        backdrop.addEventListener('click', (e) => {
            if (e.target === backdrop) closeDialog(false);
        });

        backdrop.appendChild(dialog);
        document.body.appendChild(backdrop);
    });
}
injectLiquidationDialogStyles() {
    if (document.getElementById('liquidation-dialog-styles')) return;
    const style = document.createElement('style');
    style.id = 'liquidation-dialog-styles';
    style.textContent = `
    .ld-backdrop {
        position: fixed;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        background: rgba(0, 0, 0, 0.7);
        display: flex;
        justify-content: center;
        align-items: center;
        z-index: 10002;
        backdrop-filter: blur(8px);
    }

    .ld-dialog {
        background: var(--controls-bg);
        padding: 20px;
        width: 95vw;
        height: 90vh;
        box-sizing: border-box;
        border-radius: 16px;
        border: 2px solid var(--primary-color);
        display: flex;
        flex-direction: column;
        box-shadow: 0 10px 30px rgba(0, 0, 0, 0.3);
    }

    /* --- НАЧАЛО ИЗМЕНЕНИЙ --- */
    .ld-header {
        display: flex;
        justify-content: space-between; /* Распределяет элементы по краям */
        align-items: center;
        margin-bottom: 15px;
        color: var(--primary-color);
    }

    .ld-header h3 {
        margin: 0;
        text-align: center;
        flex-grow: 1; /* Позволяет заголовку занять центральное пространство */
    }

    /* --- КОНЕЦ ИЗМЕНЕНИЙ --- */

    .ld-drag-mode-toggle {
        display: flex;
        align-items: center;
        background-color: rgba(93, 138, 168, 0.1);
        border-radius: 20px;
        padding: 4px;
        cursor: pointer;
        user-select: none;
        border: 1px solid var(--primary-color);
    }

    .ld-toggle-option {
        padding: 6px 12px;
        border-radius: 16px;
        font-size: 0.9em;
        font-weight: 500;
        transition: all 0.3s ease;
    }

    .ld-toggle-option.active {
        background-color: var(--primary-color);
        color: white;
        box-shadow: 0 2px 4px rgba(0, 0, 0, 0.2);
    }

    .ld-content {
        display: flex;
        gap: 15px;
        flex: 1;
        min-height: 0;
    }

    .ld-column {
        display: flex;
        flex-direction: column;
        gap: 10px;
        flex: 1;
        min-width: 300px;
    }

    .ld-search-input {
        padding: 8px;
        border: 1px solid var(--secondary-color);
        border-radius: 4px;
        width: 100%;
        box-sizing: border-box;
    }

    .ld-tree-container {
        border: 1px solid var(--secondary-color);
        border-radius: 8px;
        padding: 10px;
        flex: 1;
        max-height: 65vh;
        overflow-y: auto;
        scrollbar-width: thin;
        scrollbar-color: var(--primary-color) transparent;
    }

    .ld-footer {
        margin-top: 15px;
        display: flex;
        justify-content: space-between;
        align-items: center;
    }

    .ld-btn {
        padding: 10px 20px;
        border: none;
        border-radius: 6px;
        cursor: pointer;
        font-weight: 500;
        transition: all 0.2s ease;
    }

    .ld-btn:disabled {
        background: #ccc !important;
        cursor: not-allowed;
    }

    .ld-btn.ld-confirm {
        background: #4CAF50;
        color: white;
    }

    .ld-btn.ld-cancel {
        background: transparent;
        color: var(--accent-color);
    }

    .ld-editor-container .ld-editable-node {
        padding: 2px;
        margin: 2px 0;
    }

    .ld-editable-content {
        display: flex;
        align-items: center;
        padding: 5px;
        background: rgba(93, 138, 168, 0.1);
        border-radius: 4px;
    }

    .ld-node-text {
        flex-grow: 1;
        margin-left: 8px;
    }

    .ld-node-controls {
        display: flex;
        gap: 5px;
    }

    .ld-node-btn {
        background: none;
        border: none;
        cursor: pointer;
        font-size: 1.2em;
        width: 24px;
        height: 24px;
        display: flex;
        align-items: center;
        justify-content: center;
        border-radius: 4px;
        transition: background-color 0.2s;
    }

    .ld-node-btn:hover {
        background-color: rgba(93, 138, 168, 0.2);
    }

    .ld-drag-handle {
        padding: 0 8px;
        color: var(--primary-color);
        font-size: 1.4em;
        cursor: grab;
        touch-action: none;
    }

    .ld-drag-handle:active {
        cursor: grabbing;
    }

    .ld-editable-children {
        margin-left: 25px;
        padding-left: 10px;
        border-left: 2px dashed rgba(93, 138, 168, 0.2);
        min-height: 5px;
    }

    .ld-ghost-base {
        opacity: 0.7;
        border: 2px dashed var(--accent-color);
        background-color: rgba(255, 160, 122, 0.2);
    }

    .ld-ghost-base .ld-editable-children {
        display: none !important;
    }

    .sortable-drag {
        opacity: 0.9 !important;
        transform: rotate(2deg);
        box-shadow: 0 5px 15px rgba(0, 0, 0, 0.2);
    }

    .sortable-drag.single-drag-visual .ld-editable-children {
        display: none !important;
    }
        /* --- ✨ КОНЕЦ ИЗМЕНЕНИЙ --- */
    `;
    document.head.appendChild(style);
}
restructureAndPruneTree(currentNode, selectedIds) {
    // 1. Сначала рекурсивно обрабатываем всех потомков.
    if (currentNode.children && currentNode.children.length > 0) {
        const newChildren = [];
        currentNode.children.forEach(child => {
            const resultOfChildProcessing = this.restructureAndPruneTree(child, selectedIds);
            newChildren.push(...resultOfChildProcessing);
        });
        currentNode.children = newChildren;
    }

    // 2. Теперь решаем судьбу самого currentNode.
    if (selectedIds.has(currentNode.id)) {
        // Если узел ВЫБРАН, возвращаем на его место его детей.
        // Это и есть механизм "продвижения" оставшихся узлов.
        return currentNode.children || [];
    } else {
        // Если узел НЕ ВЫБРАН, он остается на своем месте.
        return [currentNode];
    }
}
applyPositionToNodes(position, targetNodeId) {
    const targetNode = this.findNode(this.treeData, targetNodeId);
    if (!targetNode) return;

    this.saveToHistory(false, true);

    const targetName = targetNode.content.text;
    let updatedCount = 0;

    const updateRecursive = (node) => {
        if (node.content.text === targetName) {
            // Добавляем или обновляем должность
            node.content.position = position;
            updatedCount++;
        }
        node.children.forEach(updateRecursive);
    };

    updateRecursive(this.treeData);

    this.logAction(`Установлена должность "${position}" для ${updatedCount} узлов с наименованием "${targetName}"`);
    this.updateTree();
    this.saveData();
    this.showNotification(`Должность "${position}" применена к ${updatedCount} узлам`);
}
async showLimitedReplacementDialog() {
    const expansionStates = new Map();
    const filterStates = new Map();

    if (!document.getElementById('limited-replacement-styles')) {
        const style = document.createElement('style');
        style.id = 'limited-replacement-styles';
        style.textContent = `
            .lr-backdrop { position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: rgba(0,0,0,0.6); display: flex; justify-content: center; align-items: center; z-index: 10002; backdrop-filter: blur(5px); }
            .lr-dialog { background: var(--controls-bg); padding: 20px; width: 100vw; height: 100vh; box-sizing: border-box; border-radius: 0; border: none; display: flex; flex-direction: column; }
            .lr-header { text-align: center; margin-bottom: 15px; color: var(--primary-color); }
            .lr-content { display: flex; gap: 15px; flex: 1; min-height: 0; }
            .lr-column { display: flex; flex-direction: column; gap: 10px; flex: 1; min-width: 500px; }
            .lr-search-input { padding: 8px; border: 1px solid var(--secondary-color); border-radius: 4px; width: 100%; box-sizing: border-box; margin-bottom: 5px; }
            .lr-tree-container { border: 1px solid var(--secondary-color); border-radius: 8px; padding: 10px; flex: 1; overflow-y: auto; }
            .lr-footer { margin-top: 15px; display: flex; justify-content: space-between; align-items: center; }
            .lr-actions { display: flex; gap: 10px; }
            .lr-btn { padding: 10px 20px; border: none; border-radius: 6px; cursor: pointer; font-weight: 500; transition: all 0.2s ease; }
            .lr-btn:disabled { background: #ccc !important; cursor: not-allowed; }
            .lr-btn.replace-delete { background: #FFA500; color: white; }
            .lr-btn.cycle { background: #00BFFF; color: white; }
            .lr-btn.cancel { background: transparent; color: var(--accent-color); }
            .lr-tooltip { position: relative; display: inline-block; }
            .lr-tooltip .lr-tooltiptext { visibility: hidden; width: 220px; background-color: #555; color: #fff; text-align: center; border-radius: 6px; padding: 5px 0; position: absolute; z-index: 1; bottom: 125%; left: 50%; margin-left: -110px; opacity: 0; transition: opacity 0.3s; }
            .lr-tooltip:hover .lr-tooltiptext { visibility: visible; opacity: 1; }
        `;
        document.head.appendChild(style);
    }

    const backdrop = document.createElement('div');
    backdrop.className = 'lr-backdrop';
    const dialog = document.createElement('div');
    dialog.className = 'lr-dialog';
    dialog.innerHTML = `
        <div class="lr-header"><h3>Ограниченная замена</h3></div>
        <div class="lr-content" id="lr-content-area"></div>
        <div class="lr-footer">
            <button class="lr-btn cancel">Отмена</button>
            <div class="lr-actions">
                <div class="lr-tooltip">
                    <button class="lr-btn replace-delete" id="lr-replace-delete-btn" disabled>Заменить с удалением</button>
                    <span class="lr-tooltiptext">Действует только для узла без дочерних элементов.</span>
                </div>
                <button class="lr-btn cycle" id="lr-cycle-btn">Круговорот</button>
            </div>
        </div>
    `;
    backdrop.appendChild(dialog);
    document.body.appendChild(backdrop);

    const contentArea = dialog.querySelector('#lr-content-area');
    let selectedNodes = new Map();

    const renderColumns = () => {
        contentArea.innerHTML = '';
        for (let i = 1; i <= 2; i++) {
            if (!expansionStates.has(i)) expansionStates.set(i, new Set());

            const column = document.createElement('div');
            column.className = 'lr-column';
            const searchInput = document.createElement('input');
            searchInput.type = 'text';
            searchInput.placeholder = `Поиск в списке №${i}...`;
            searchInput.className = 'lr-search-input';
            searchInput.value = filterStates.get(i) || '';
            const treeContainer = document.createElement('div');
            treeContainer.className = 'lr-tree-container';

            column.appendChild(searchInput);
            column.appendChild(treeContainer);
            contentArea.appendChild(column);

            const redrawTree = () => {
                const filterText = searchInput.value.toLowerCase().trim();
                filterStates.set(i, searchInput.value);

                const isFirstColumn = (i === 1);
                // --- ✨ ИЗМЕНЕНИЕ ЗДЕСЬ: Включаем авто-раскрытие для ОБЕИХ колонок ---
                const autoExpand = true;

                this.createSingleSelectableTree(
                    treeContainer,
                    (nodeId) => {
                        selectedNodes.set(i, nodeId);
                        updateButtonStates();
                    },
                    selectedNodes.get(i),
                    expansionStates.get(i),
                    filterText,
                    isFirstColumn,
                    null,
                    null,
                    autoExpand // Передаем обновленный параметр
                );
            };

            searchInput.addEventListener('input', redrawTree);
            redrawTree();
        }
    };
    const updateButtonStates = () => {
        const replaceDeleteBtn = dialog.querySelector('#lr-replace-delete-btn');
        const node1Id = selectedNodes.get(1);
        if (node1Id) {
            const node1 = this.findNode(this.treeData, node1Id);
            replaceDeleteBtn.disabled = !(node1 && node1.children.length === 0);
        } else {
            replaceDeleteBtn.disabled = true;
        }
    };

    const closeDialog = () => document.body.removeChild(backdrop);
    dialog.querySelector('.lr-btn.cancel').addEventListener('click', () => {
        closeDialog();
        this.promptReplacementMode(); 
    });
    backdrop.addEventListener('click', (e) => { if (e.target === backdrop) closeDialog(); });

    dialog.querySelector('#lr-replace-delete-btn').addEventListener('click', () => {
        const sourceNodeId = selectedNodes.get(1);
        const targetNodeId = selectedNodes.get(2);
        if (!sourceNodeId || !targetNodeId) {
            this.showNotification('Нужно выбрать оба узла', 'error');
            return;
        }
        this.executeReplaceAndDelete(sourceNodeId, targetNodeId);
        closeDialog();
    });

    dialog.querySelector('#lr-cycle-btn').addEventListener('click', () => {
        const node1Id = selectedNodes.get(1);
        const node2Id = selectedNodes.get(2);
        if (!node1Id || !node2Id) {
            this.showNotification('Нужно выбрать оба узла', 'error');
            return;
        }
        this.executeCycle(node1Id, node2Id);
        closeDialog();
    });

    renderColumns();
    updateButtonStates();
}
executeReplaceAndDelete(sourceNodeId, targetNodeId) {
    const sourceNode = this.findNode(this.treeData, sourceNodeId);
    const targetNode = this.findNode(this.treeData, targetNodeId);

    // Проверки безопасности
    if (!sourceNode || !targetNode) return;
    if (sourceNode.content.text === targetNode.content.text) {
        this.showNotification('Нельзя выбирать узлы с одинаковыми названиями.', 'error');
        return;
    }
    if (sourceNode.content.isIndicator || sourceNode.content.isOKR || targetNode.content.isIndicator || targetNode.content.isOKR) {
        this.showNotification('Нельзя использовать в замене узлы типа "Гос. программа" или "OKR".', 'error');
        return;
    }
    if (sourceNode.children.length > 0) {
        this.showNotification('Исходный узел не должен иметь дочерних элементов для этой операции.', 'error');
        return;
    }

    this.saveToHistory(false, true);

    const sourceContentCopy = JSON.parse(JSON.stringify(sourceNode.content));
    const targetName = targetNode.content.text;
    let replacementCount = 0;

const replaceRecursive = (node) => {
    if (node.content.text === targetName) {
        // --- НАЧАЛО ИЗМЕНЕНИЯ ---
        // Сохраняем важные атрибуты целевого узла
        const originalFiles = node.content.files || [];
        const originalSubBlocks = node.content.subBlocks || [];
        const originalPosition = node.content.position || null; // Сохраняем должность
        const originalSpecialFlags = {
            isSubordinate: node.content.isSubordinate, isPower269: node.content.isPower269,
            absent269: node.content.absent269, isForAll: node.content.isForAll,
            isAuthority: node.content.isAuthority, isOKR: node.content.isOKR, isIndicator: node.content.isIndicator
        };
        const originalCluster = this.clusters.get(node.id);
        // --- КОНЕЦ ИЗМЕНЕНИЯ ---

        // Производим замену
        node.content = JSON.parse(JSON.stringify(sourceContentCopy));
        node.content.isHorizontal = true; // Условие: всегда горизонтальный

        // Восстанавливаем сохраненные атрибуты
        node.content.files = originalFiles;
        node.content.subBlocks = originalSubBlocks;
        node.content.position = originalPosition; // Восстанавливаем должность
        Object.assign(node.content, originalSpecialFlags);

        // Наследуем кластер
        if (originalCluster) {
            this.clusters.set(node.id, originalCluster);
        }

        node.circularlyReplaced = true; // Игнорируем фильтром "показать новые"
        replacementCount++;
    }
    node.children.forEach(replaceRecursive);
};

    replaceRecursive(this.treeData);

    // Удаляем исходный узел
    const parent = this.findParent(this.treeData, sourceNodeId);
    if (parent) {
        parent.children = parent.children.filter(child => child.id !== sourceNodeId);
    }

    this.logAction(`Замена с удалением: Узел "${targetName}" заменен на "${sourceNode.content.text}" (${replacementCount} раз), исходник удален.`);
    this.updateTree();
    this.saveData();
    this.showNotification('Замена с удалением успешно выполнена!');
}
executeCycle(node1Id, node2Id) {
    const node1 = this.findNode(this.treeData, node1Id);
    const node2 = this.findNode(this.treeData, node2Id);

    if (!node1 || !node2) return;
    if (node1.content.text === node2.content.text) {
        this.showNotification('Нельзя выбирать узлы с одинаковыми названиями.', 'error');
        return;
    }
    if (node1.content.isIndicator || node1.content.isOKR || node2.content.isIndicator || node2.content.isOKR) {
        this.showNotification('Нельзя использовать в замене узлы типа "Гос. программа" или "OKR".', 'error');
        return;
    }

    this.saveToHistory(false, true);

    const name1 = node1.content.text;
    const name2 = node2.content.text;

    const content1Copy = JSON.parse(JSON.stringify(node1.content));
    const content2Copy = JSON.parse(JSON.stringify(node2.content));

    const swapRecursive = (node) => {
        // ✨ 1. Сохраняем ВСЕ уникальные свойства узла, которые должны остаться на месте
        const originalDataToPreserve = {
            files: node.content.files || [],
            subBlocks: node.content.subBlocks || [],
position: node.content.position || null, 
            isSubordinate: node.content.isSubordinate,
            isPower269: node.content.isPower269,
            absent269: node.content.absent269,
            isForAll: node.content.isForAll,
            isAuthority: node.content.isAuthority,
            isOKR: node.content.isOKR,
            isIndicator: node.content.isIndicator
        };

        let swapped = false;

        if (node.content.text === name1) {
            // 2. Меняем ВЕСЬ блок `content` на копию
            node.content = JSON.parse(JSON.stringify(content2Copy));
            swapped = true;
        } else if (node.content.text === name2) {
            // 2. Меняем ВЕСЬ блок `content` на копию
            node.content = JSON.parse(JSON.stringify(content1Copy));
            swapped = true;
        }

        if (swapped) {
            
            Object.assign(node.content, originalDataToPreserve);

            
            node.content.isHorizontal = true;
            node.circularlyReplaced = true;
        }

        
        node.children.forEach(swapRecursive);
    };

    swapRecursive(this.treeData);

    this.logAction(`Круговорот: Узлы "${name1}" и "${name2}" массово поменялись местами (с фото и пометками).`);
    this.updateTree();
    this.saveData();
    this.showNotification('Круговорот (с фото и пометками) успешно выполнен!');
}
showRestructureDialog() {
    // 1. Внедрение стилей (без изменений)
    if (!document.getElementById('restructure-dialog-styles')) {
        const style = document.createElement('style');
        style.id = 'restructure-dialog-styles';
        style.textContent = `
            .rs-backdrop { position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: rgba(0,0,0,0.6); display: flex; justify-content: center; align-items: center; z-index: 10002; backdrop-filter: blur(5px); }
            .rs-dialog { background: var(--controls-bg); padding: 20px; width: 100vw; height: 100vh; box-sizing: border-box; display: flex; flex-direction: column; }
            .rs-header { display: flex; justify-content: center; align-items: center; position: relative; text-align: center; margin-bottom: 15px; color: var(--primary-color); flex-shrink: 0; }
            .rs-column-controls { position: absolute; right: 20px; top: 50%; transform: translateY(-50%); display: flex; gap: 8px; }
            .rs-column-btn { background: #4CAF50; color: white; border: none; border-radius: 50%; width: 30px; height: 30px; font-size: 20px; font-weight: bold; cursor: pointer; transition: all 0.2s ease; display: flex; align-items: center; justify-content: center; }
            .rs-column-btn:hover:not(:disabled) { transform: scale(1.1); }
            .rs-column-btn:disabled { background: #ccc; cursor: not-allowed; }
            .rs-remove-column-btn { background: #d32f2f; }
            .rs-content { display: flex; gap: 15px; flex: 1; min-height: 0; }
            .rs-column { display: flex; flex-direction: column; gap: 10px; flex: 1; min-width: 0; }
            .rs-search-input { padding: 8px; border: 1px solid var(--secondary-color); border-radius: 4px; width: 100%; box-sizing: border-box; margin-bottom: 5px; }
            .rs-tree-container { border: 1px solid var(--secondary-color); border-radius: 8px; padding: 10px; flex: 1; overflow-y: auto; }
            .rs-target-header { display: flex; justify-content: center; align-items: center; gap: 15px; }
            .rs-target-nav-btn { background: var(--primary-color); color: white; border: none; border-radius: 50%; width: 28px; height: 28px; font-size: 18px; cursor: pointer; }
            .rs-target-nav-btn:disabled { background: #ccc; cursor: not-allowed; }
            .rs-target-title { font-weight: bold; color: var(--primary-color); }
            .rs-footer { margin-top: 15px; display: flex; justify-content: flex-end; gap: 10px; }
            .rs-btn { padding: 10px 20px; border: none; border-radius: 6px; cursor: pointer; }
            .rs-btn.ok { background: var(--primary-color); color: white; }
            .rs-btn.cancel { background: #d32f2f; color: white; }
            .tree-selection-node.selected-target { background-color: rgba(93, 138, 168, 0.2); border-radius: 4px; }
            .rs-confirm-selection-btn { background: #2196F3; color: white; border: none; border-radius: 6px; padding: 8px 12px; cursor: pointer; margin-top: 10px; width: 100%; font-weight: 500; transition: background-color 0.2s; }
            .rs-confirm-selection-btn:hover { background: #1976D2; }
            .rs-confirm-selection-btn:disabled { background: #ccc; cursor: not-allowed; }
        `;
        document.head.appendChild(style);
    }

    // 2. Создание HTML-структуры (без изменений)
    const backdrop = document.createElement('div');
    backdrop.className = 'rs-backdrop';
    const dialog = document.createElement('div');
    dialog.className = 'rs-dialog';
    dialog.innerHTML = `
        <div class="rs-header">
            <h3>Реструктуризация узла</h3>
            <div class="rs-column-controls">
                <button class="rs-column-btn rs-remove-column-btn" id="rs-remove-column-btn" title="Убрать колонку выбора">-</button>
                <button class="rs-column-btn rs-add-column-btn" id="rs-add-column-btn" title="Добавить колонку выбора">+</button>
            </div>
        </div>
        <div class="rs-content">
            <div class="rs-column" id="rs-target-column-wrapper">
                <div class="rs-target-header">
                    <button class="rs-target-nav-btn" id="rs-target-prev-btn" title="Предыдущая цель">⬅️</button>
                    <h4 class="rs-target-title" id="rs-target-title-text">Целевой узел</h4>
                    <button class="rs-target-nav-btn" id="rs-target-next-btn" title="Следующая цель">➡️</button>
                </div>
                <input type="text" placeholder="Поиск..." class="rs-search-input" id="rs-search-target">
                <div class="rs-tree-container" id="rs-tree-target"></div>
                <button class="rs-confirm-selection-btn" id="rs-confirm-btn" disabled>Подтвердить выбор</button>
            </div>
        </div>
        <div class="rs-footer">
            <button class="rs-btn cancel">Отмена</button>
            <button class="rs-btn ok">Выполнить</button>
        </div>
    `;
    backdrop.appendChild(dialog);
    document.body.appendChild(backdrop);

    // 3. Логика работы диалога
    const contentArea = dialog.querySelector('.rs-content');
    const targetWrapper = dialog.querySelector('#rs-target-column-wrapper');
    const addColumnBtn = dialog.querySelector('#rs-add-column-btn');
    const removeColumnBtn = dialog.querySelector('#rs-remove-column-btn');
    let selectionGroups = [];
    const groupColors = ["var(--primary-color)", "#4CAF50", "#FFA500"];
    let activeTargetIndex = 0;
    const sourceTreeExpansionStates = new Map();
    const targetTreeExpansionState = new Set();
    const targetTitleEl = dialog.querySelector('#rs-target-title-text');
    const prevTargetBtn = dialog.querySelector('#rs-target-prev-btn');
    const nextTargetBtn = dialog.querySelector('#rs-target-next-btn');
    const targetSearchInput = dialog.querySelector('#rs-search-target');
    const targetTreeContainer = dialog.querySelector('#rs-tree-target');
    const confirmBtn = dialog.querySelector('#rs-confirm-btn');

    const updateAllVisualStates = () => {
        const globallySelectedNodes = new Map();
        selectionGroups.forEach(group => {
            group.state.forEach((state, id) => {
                if (state !== 'none') {
                    globallySelectedNodes.set(id, { state, color: group.color });
                }
            });
        });

        document.querySelectorAll('.rs-column:not(#rs-target-column-wrapper)').forEach((col, index) => {
            const group = selectionGroups[index];
            if (!group) return;
            col.querySelectorAll('input[type="checkbox"].custom-checkbox').forEach(input => {
                const nodeId = parseInt(input.value, 10);
                const selectionInfo = globallySelectedNodes.get(nodeId);
                const isSelectedInOtherGroup = !!(selectionInfo && selectionInfo.color !== group.color);

                input.disabled = (input.dataset.isLocked === 'true') || isSelectedInOtherGroup;

                if (isSelectedInOtherGroup) {
                    input.dataset.state = selectionInfo.state;
                    input.dataset.groupColor = selectionInfo.color;
                } else {
                    input.dataset.state = group.state.get(nodeId) || 'none';
                    input.dataset.groupColor = group.color;
                }
                if (typeof input.updateVisuals === 'function') {
                    input.updateVisuals();
                }
            });
        });

        updateTargetColumnView(true);
    };

    const updateTargetColumnView = (fullRedraw = true) => {
        if (selectionGroups.length === 0) return;
        if (activeTargetIndex >= selectionGroups.length) {
            activeTargetIndex = Math.max(0, selectionGroups.length - 1);
        }
        const activeGroup = selectionGroups[activeTargetIndex];
        if (activeGroup.pendingTargetId === null && activeGroup.targetId !== null) {
            activeGroup.pendingTargetId = activeGroup.targetId;
        }
        confirmBtn.disabled = !activeGroup.pendingTargetId || (activeGroup.pendingTargetId === activeGroup.targetId);
        targetTitleEl.textContent = `Цель для Группы №${activeTargetIndex + 1}`;
        targetTitleEl.style.borderBottom = `3px solid ${activeGroup.color}`;
        const canNavigate = selectionGroups.length > 1;
        prevTargetBtn.disabled = !canNavigate;
        nextTargetBtn.disabled = !canNavigate;

        if (fullRedraw) {
            const filterText = targetSearchInput.value.toLowerCase().trim();
            const expansionStateForRender = new Set(targetTreeExpansionState);
            targetTreeContainer.innerHTML = '';

            const allTargets = new Map();
            selectionGroups.forEach((group, index) => {
                if (group.targetId) {
                    allTargets.set(group.targetId, { color: group.color, is_active: index === activeTargetIndex });
                }
            });

            const globallyDisabledNodes = new Map();
            selectionGroups.forEach(group => {
                group.state.forEach((state, id) => {
                    if (state === 'move' || state === 'delete') {
                        globallyDisabledNodes.set(id, true);
                    }
                });
            });

            const selectionState = new Map();
            if (activeGroup.pendingTargetId) {
                selectionState.set(activeGroup.pendingTargetId, 'selected');
            }

            const highlightTargetNode = (id) => {
                const node = this.findNode(this.treeData, id);
                if (node && (node.content.isIndicator || node.content.isOKR)) {
                    this.showNotification('Узлы типа "Гос. программа" и "OKR" не могут быть выбраны в качестве цели.', 'error');
                    const selectedElement = targetTreeContainer.querySelector('.selected-target');
                    if (selectedElement) {
                        const radio = selectedElement.querySelector('input[type="radio"]');
                        if (radio) radio.checked = false;
                        selectedElement.classList.remove('selected-target');
                    }
                    if (activeGroup) {
                        activeGroup.pendingTargetId = activeGroup.targetId || null;
                    }
                    confirmBtn.disabled = true;
                    return;
                }
                if (activeGroup) {
                    activeGroup.pendingTargetId = id;
                }
                confirmBtn.disabled = !activeGroup || activeGroup.pendingTargetId === activeGroup.targetId;
                targetTreeContainer.querySelectorAll('.selected-target').forEach(el => el.classList.remove('selected-target'));
                const newSelectedInput = targetTreeContainer.querySelector(`input[value="${id}"]`);
                if (newSelectedInput) {
                    newSelectedInput.closest('.tree-selection-node').classList.add('selected-target');
                }
            };

            this.createSelectableTree(
                targetTreeContainer,
                highlightTargetNode,
                this.treeData,
                false,
                selectionState,
                filterText,
                expansionStateForRender,
                targetTreeExpansionState,
                globallyDisabledNodes,
                '1',
                allTargets,
                false // <-- ✨ ИЗМЕНЕНИЕ ЗДЕСЬ: Отключаем авто-раскрытие для цели
            );
        }
    };

    confirmBtn.addEventListener('click', () => {
        const activeGroup = selectionGroups[activeTargetIndex];
        if (activeGroup && activeGroup.pendingTargetId !== null) {
            activeGroup.targetId = activeGroup.pendingTargetId;
            confirmBtn.disabled = true;
            updateTargetColumnView(true);
            this.showNotification(`Цель для Группы №${activeTargetIndex + 1} зафиксирована.`);
        }
    });

    prevTargetBtn.addEventListener('click', () => {
        activeTargetIndex = (activeTargetIndex - 1 + selectionGroups.length) % selectionGroups.length;
        updateTargetColumnView(true);
    });

    nextTargetBtn.addEventListener('click', () => {
        activeTargetIndex = (activeTargetIndex + 1) % selectionGroups.length;
        updateTargetColumnView(true);
    });

    targetSearchInput.addEventListener('input', () => updateTargetColumnView(true));

    const redrawSingleSourceTree = (index) => {
        const group = selectionGroups[index];
        if (!group) return;
        const col = document.querySelectorAll('.rs-column:not(#rs-target-column-wrapper)')[index];
        const searchInput = col.querySelector('input.rs-search-input');
        const treeContainer = col.querySelector('.rs-tree-container');
        const filterText = searchInput.value.toLowerCase().trim();
        const manualExpansionState = sourceTreeExpansionStates.get(group.id);
        const expansionStateForRender = new Set(manualExpansionState);
        treeContainer.innerHTML = '';

        this.createSelectableTree(
            treeContainer,
            (id, state) => {
                if (state === 'none') {
                    group.state.delete(id);
                } else {
                    group.state.set(id, state);
                }
                updateAllVisualStates();
                updateTargetColumnView(true);
            },
            this.treeData,
            true,
            group.state,
            filterText,
            expansionStateForRender,
            manualExpansionState,
            new Map(),
            group.color,
            new Map(),
            true // autoExpandOnFilter
        );
        updateAllVisualStates();
    };

    const updateColumnButtonsState = () => {
        addColumnBtn.disabled = selectionGroups.length >= 3;
        removeColumnBtn.disabled = selectionGroups.length <= 1;
    };

    const addSourceColumn = () => {
        if (selectionGroups.length >= 3) return;
        const groupIndex = selectionGroups.length;
        const newGroup = { id: groupIndex + 1, state: new Map(), targetId: null, pendingTargetId: null, color: groupColors[groupIndex] };
        selectionGroups.push(newGroup);
        sourceTreeExpansionStates.set(newGroup.id, new Set());
        const column = document.createElement('div');
        column.className = 'rs-column';
        column.innerHTML = `
            <h4 style="margin: 0; text-align: center;">Группа выбора №${newGroup.id}</h4>
            <input type="text" placeholder="Поиск..." class="rs-search-input">
            <div class="rs-tree-container"></div>
        `;
        contentArea.insertBefore(column, targetWrapper);
        const searchInput = column.querySelector('input');
        searchInput.addEventListener('input', () => redrawSingleSourceTree(groupIndex));
        redrawSingleSourceTree(groupIndex);
        updateColumnButtonsState();
        updateTargetColumnView(false);
    };

    const removeSourceColumn = () => {
        if (selectionGroups.length <= 1) return;
        const removedGroup = selectionGroups.pop();
        sourceTreeExpansionStates.delete(removedGroup.id);
        const columns = contentArea.querySelectorAll('.rs-column:not(#rs-target-column-wrapper)');
        columns[columns.length - 1].remove();
        updateAllVisualStates();
        updateColumnButtonsState();
        updateTargetColumnView(false);
    };

    addColumnBtn.addEventListener('click', addSourceColumn);
    removeColumnBtn.addEventListener('click', removeSourceColumn);

    const closeDialog = () => {
        document.body.removeChild(backdrop);
        this.elements.controls.style.display = 'flex';
        document.getElementById('historyLogIcon').style.display = 'flex';
        document.getElementById('circular-replacement-btn-main').style.display = 'flex';
        this.elements.toggleControls.style.display = 'flex';
    };

    dialog.querySelector('.ok').addEventListener('click', () => {
        this.performMultiTargetRestructure(selectionGroups);
        closeDialog();
    });
        dialog.querySelector('.rs-btn.cancel').addEventListener('click', () => {
        closeDialog();
        this.promptReplacementMode(); // Возвращаемся в главное меню
    });
    backdrop.addEventListener('click', (e) => {
        if (e.target === backdrop) closeDialog();
    });

    // Инициализация
    addSourceColumn();
    updateTargetColumnView(true);
    this.elements.controls.style.display = 'none';
    document.getElementById('historyLogIcon').style.display = 'none';
    document.getElementById('circular-replacement-btn-main').style.display = 'none';
    this.elements.toggleControls.style.display = 'none';
}
recursivelyUpdateCluster(nodes, clusterName) {
    nodes.forEach(node => {
        if (clusterName) {
            // Присваиваем новый кластер
            this.clusters.set(node.id, clusterName);
        } else {
            // Если у целевого узла нет кластера, удаляем его и у перемещаемого узла
            this.clusters.delete(node.id);
        }
        // Продолжаем рекурсивно для всех дочерних элементов
        if (node.children && node.children.length > 0) {
            this.recursivelyUpdateCluster(node.children, clusterName);
        }
    });
}
performMultiTargetRestructure(groups) {
    this.saveToHistory(false, true);

    let totalMoved = 0;
    let totalDeleted = 0;
    groups.forEach(group => {
        group.state.forEach((state) => {
            if (state === 'move') totalMoved++;
            if (state === 'delete') totalDeleted++;
        });
    });

    const logParts = [];
    if (totalMoved > 0) logParts.push(`перемещено ${totalMoved} узлов`);
    if (totalDeleted > 0) logParts.push(`удалено ${totalDeleted} узлов`);
    if (logParts.length > 0) {
        this.logAction(`Реструктуризация: ${logParts.join(', ')}.`);
    }

    const allNodesToModify = new Set();
    const nodesToDelete = new Set();
    const moveOperations = [];
    let errorOccurred = false;

    groups.forEach((group, index) => {
        if (errorOccurred) return;
        const nodesToMoveInGroup = new Set();
        group.state.forEach((state, id) => {
            allNodesToModify.add(id);
            if (state === 'delete') {
                nodesToDelete.add(id);
            } else if (state === 'move') {
                nodesToMoveInGroup.add(id);
            }
        });
        if (nodesToMoveInGroup.size > 0) {
            if (!group.targetId) {
                this.showNotification(`Не выбран целевой узел для Группы №${index + 1}`, 'error');
                errorOccurred = true;
                return;
            }
            moveOperations.push({
                nodes: nodesToMoveInGroup,
                targetId: group.targetId
            });
        }
    });

    if (errorOccurred) return;

    nodesToDelete.forEach(id => allNodesToModify.add(id));

    moveOperations.forEach(op => {
        op.hierarchy = this.buildPreservedHierarchy(op.nodes);
    });

    const newRootChildren = [];
    this.treeData.children.forEach(child => {
        const result = this.restructureAndPruneTree(child, allNodesToModify);
        newRootChildren.push(...result);
    });
    this.treeData.children = newRootChildren;

    moveOperations.forEach(op => {
        const targetNode = this.findNode(this.treeData, op.targetId);
        if (targetNode) {
            if (!targetNode.children) {
                targetNode.children = [];
            }
            targetNode.children.push(...op.hierarchy);
            targetNode.isExpanded = true;

            // --- ✨ ВОТ ИСПРАВЛЕНИЕ: Восстановлен блок обновления кластера ---
            const targetCluster = this.clusters.get(targetNode.id);
            this.recursivelyUpdateCluster(op.hierarchy, targetCluster);
            // --- ✨ КОНЕЦ ИСПРАВЛЕНИЯ ---

        } else {
            console.error(`Критическая ошибка: Целевой узел с ID ${op.targetId} не найден после удаления веток.`);
        }
    });

    this.updateTree();
    this.saveData();
    this.showNotification('Реструктуризация успешно выполнена.');
}
performRestructure(selectedNodesWithState, targetId) {
    const nodesToMoveIds = new Set();
    const nodesToDeleteIds = new Set();
    selectedNodesWithState.forEach((state, id) => {
        if (state === 'move') {
            nodesToMoveIds.add(id);
        } else if (state === 'delete') {
            nodesToDeleteIds.add(id);
        }
    });

    if (nodesToMoveIds.size === 0 && nodesToDeleteIds.size === 0) {
        this.showNotification('Не выбраны узлы для переноса или удаления.', 'error');
        return;
    }

    if (nodesToMoveIds.size > 0 && !targetId) {
        this.showNotification('Не выбран целевой узел для вставки.', 'error');
        return;
    }

    const targetNodeOriginal = this.findNode(this.treeData, targetId);
    if (nodesToMoveIds.size > 0 && !targetNodeOriginal) {
        this.showNotification('Целевой узел не найден.', 'error');
        return;
    }

    this.saveToHistory(false, true);

    const logParts = [];
    if (nodesToMoveIds.size > 0) logParts.push(`перемещено ${nodesToMoveIds.size} узлов`);
    if (nodesToDeleteIds.size > 0) logParts.push(`удалено ${nodesToDeleteIds.size} узлов`);
    if (logParts.length > 0) {
        this.logAction(`Реструктуризация: ${logParts.join(', ')}.`);
    }

    const movedHierarchy = this.buildPreservedHierarchy(nodesToMoveIds);
    const allSelectedIds = new Set([...nodesToMoveIds, ...nodesToDeleteIds]);

    const newRootChildren = [];
    this.treeData.children.forEach(child => {
        const result = this.restructureAndPruneTree(child, allSelectedIds);
        newRootChildren.push(...result);
    });
    this.treeData.children = newRootChildren;

    if (targetNodeOriginal && movedHierarchy.length > 0) {
        const targetNodeInNewTree = this.findNode(this.treeData, targetId);
        if (targetNodeInNewTree) {
            if (!targetNodeInNewTree.children) {
                targetNodeInNewTree.children = [];
            }
            targetNodeInNewTree.children.push(...movedHierarchy);
            targetNodeInNewTree.isExpanded = true;

            // --- ИЗМЕНЕНИЕ ЗДЕСЬ ---
            // Получаем кластер целевого узла
            const targetCluster = this.clusters.get(targetId);
            // Рекурсивно применяем его ко всем перемещенным узлам и их детям
            this.recursivelyUpdateCluster(movedHierarchy, targetCluster);
            // --- КОНЕЦ ИЗМЕНЕНИЯ ---

        } else {
            console.error("Критическая ошибка: целевой узел не найден после перестройки дерева.");
            this.showNotification('Ошибка: целевой узел исчез после удаления веток.', 'error');
            return;
        }
    }

    this.updateTree();
    this.saveData();
    this.showNotification('Реструктуризация успешно выполнена.');
}
buildPreservedHierarchy(nodesToMoveIds) {
    const nodeCopies = new Map();
    // 1. Создаем глубокие, но "плоские" копии всех выбранных узлов.
    nodesToMoveIds.forEach(id => {
        const originalNode = this.findNode(this.treeData, id);
        if (originalNode) {
            const nodeCopy = JSON.parse(JSON.stringify(originalNode));
            nodeCopy.children = []; // Очищаем детей, связи восстановим позже.
            nodeCopies.set(id, nodeCopy);
        }
    });

    const hierarchyRoots = [];
    // 2. Восстанавливаем иерархические связи, находя ближайшего выбранного предка.
    nodeCopies.forEach((nodeCopy, id) => {
        // Находим ближайшего предка, который ТАКЖЕ был выбран для переноса.
        const nearestAncestor = this.findNearestSelectedAncestor(id, nodesToMoveIds);

        if (nearestAncestor) {
            // Если предок найден, добавляем текущий узел к его копии.
            const parentCopy = nodeCopies.get(nearestAncestor.id);
            if (parentCopy) {
                parentCopy.children.push(nodeCopy);
            }
        } else {
            // Если предка в списке переноса нет, значит, этот узел - корень новой иерархии.
            hierarchyRoots.push(nodeCopy);
        }
    });

    return hierarchyRoots;
}
findNearestSelectedAncestor(startNodeId, selectedIds) {
    // Находим прямого родителя в оригинальном дереве
    const parent = this.findParent(this.treeData, startNodeId);

    // Если родителя нет, мы достигли корня дерева
    if (!parent) {
        return null;
    }

    // Если ID родителя есть в списке выбранных, мы нашли его!
    if (selectedIds.has(parent.id)) {
        return parent;
    }

    // Если прямой родитель не выбран, ищем выше по иерархии
    return this.findNearestSelectedAncestor(parent.id, selectedIds);
}
async showNewStaffUnitDialog() {
    // Внедряем стили, если их еще нет
    if (!document.getElementById('new-unit-dialog-styles')) {
        const style = document.createElement('style');
        style.id = 'new-unit-dialog-styles';
        style.textContent = `
            .nu-backdrop { position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: rgba(0,0,0,0.6); display: flex; justify-content: center; align-items: center; z-index: 10002; backdrop-filter: blur(5px); }
            .nu-dialog { background: var(--controls-bg); padding: 25px; border-radius: 12px; box-shadow: 0 5px 20px rgba(0,0,0,0.25); width: 90%; max-width: 600px; border: 1px solid var(--primary-color); display: flex; flex-direction: column; }
            .nu-header { text-align: center; margin-bottom: 20px; color: var(--primary-color); }
            .nu-content { display: flex; flex-direction: column; gap: 15px; }
            .nu-input, .nu-btn { padding: 10px; border: 1px solid var(--secondary-color); border-radius: 6px; width: 100%; box-sizing: border-box; font-size: 1em; }
            .nu-tree-container { border: 1px solid var(--secondary-color); border-radius: 8px; padding: 10px; max-height: 40vh; overflow-y: auto; }
            .nu-image-preview { max-width: 100px; max-height: 100px; display: none; margin-top: 10px; border-radius: 6px; border: 1px solid var(--secondary-color); }
            .nu-footer { margin-top: 20px; display: flex; justify-content: flex-end; gap: 10px; }
            .nu-btn { border: none; cursor: pointer; font-weight: 500; transition: all 0.2s ease; }
            .nu-btn.confirm { background: #4CAF50; color: white; }
            .nu-btn.confirm:disabled { background: #ccc; cursor: not-allowed; }
            .nu-btn.cancel { background: transparent; color: var(--accent-color); }
            .nu-btn.image-btn { background: var(--secondary-color); color: white; }
        `;
        document.head.appendChild(style);
    }

    // Создаем Promise, который будет разрешен с данными из диалога
    const userChoice = await new Promise(resolve => {
        const backdrop = document.createElement('div');
        backdrop.className = 'nu-backdrop';
        const dialog = document.createElement('div');
        dialog.className = 'nu-dialog';
        dialog.innerHTML = `
            <div class="nu-header"><h3>Создать дубликаты по наименованию</h3></div>
            <div class="nu-content">
                <p>1. Выберите узел, чтобы использовать его наименование как эталон.</p>
                <input type="text" placeholder="Поиск узла по наименованию..." class="nu-input nu-search-input">
                <div class="nu-tree-container"></div>
                <p>2. Введите наименование для новых узлов-дубликатов.</p>
                <input type="text" class="nu-input" id="nu-new-name-input" value="Новая штатная единица">
                <p>3. Выберите изображение (необязательно).</p>
                <input type="file" id="nu-image-upload-input" accept="image/*" style="display: none;">
                <button class="nu-btn image-btn" id="nu-image-select-btn">Выбрать изображение</button>
                <img id="nu-image-preview" class="nu-image-preview">
            </div>
            <div class="nu-footer">
                <button class="nu-btn cancel">Отмена</button>
                <button class="nu-btn confirm" disabled>Выполнить</button>
            </div>
        `;
        document.body.appendChild(backdrop);
        backdrop.appendChild(dialog);

        const searchInput = dialog.querySelector('.nu-search-input');
        const treeContainer = dialog.querySelector('.nu-tree-container');
        const confirmBtn = dialog.querySelector('.confirm');
        const cancelBtn = dialog.querySelector('.cancel');
        const newNameInput = dialog.querySelector('#nu-new-name-input');
        const imageSelectBtn = dialog.querySelector('#nu-image-select-btn');
        const imageUploadInput = dialog.querySelector('#nu-image-upload-input');
        const imagePreview = dialog.querySelector('#nu-image-preview');

        let selectedNodeId = null;
        let imageBase64 = null;
        const expansionState = new Set();

        const redrawTree = () => {
            const filterText = searchInput.value.toLowerCase().trim();
            this.createSingleSelectableTree(
                treeContainer,
                (nodeId) => {
                    selectedNodeId = nodeId;
                    confirmBtn.disabled = !selectedNodeId;
                },
                selectedNodeId,
                expansionState,
                filterText,
                true
            );
        };

        imageSelectBtn.addEventListener('click', () => imageUploadInput.click());
        imageUploadInput.addEventListener('change', (e) => {
            const file = e.target.files[0];
            if (file) {
                const reader = new FileReader();
                reader.onload = (event) => {
                    imageBase64 = event.target.result;
                    imagePreview.src = imageBase64;
                    imagePreview.style.display = 'block';
                };
                reader.readAsDataURL(file);
            }
        });

       const closeDialog = (result) => {
            document.body.removeChild(backdrop);
            resolve(result);
        };

        searchInput.addEventListener('input', redrawTree);
        cancelBtn.addEventListener('click', () => {
            document.body.removeChild(backdrop); // Закрываем текущее окно
            this.promptReplacementMode();       // Открываем главное меню
            resolve(null);                      // Завершаем Promise, чтобы избежать ошибок
        });
        confirmBtn.addEventListener('click', () => {
            const newNodeName = newNameInput.value.trim() || "Новая штатная единица";
            closeDialog({ templateNodeId: selectedNodeId, newNodeName, imageBase64 });
        });
        backdrop.addEventListener('click', (e) => {
            if (e.target === backdrop) closeDialog(null);
        });

        redrawTree();
    });

    if (userChoice) {
        this.executeAddStaffUnit(userChoice.templateNodeId, userChoice.newNodeName, userChoice.imageBase64);
    } else {
        this.showNotification('Операция отменена.');
    }
}
async executeAddStaffUnit(templateNodeId, newNodeName, newImageDataBase64) {
    const selectedNode = this.findNode(this.treeData, templateNodeId);
    if (!selectedNode) {
        this.showNotification('Выбранный узел-эталон не найден.', 'error');
        return;
    }

    this.saveToHistory(false, true);
    const targetName = selectedNode.content.text;

    // --- ✨ ИЗМЕНЕНИЕ 1: Получаем кластер ИСХОДНОГО узла, выбранного в диалоге ---
    const sourceCluster = this.clusters.get(selectedNode.id);

    const targets = [];
    // Этап 1: Поиск всех узлов с нужным именем
    const findTargetsRecursive = (node) => {
        if (node.content.text === targetName) {
            targets.push(node);
        }
        if (node.children) {
            [...node.children].forEach(child => findTargetsRecursive(child));
        }
    };
    findTargetsRecursive(this.treeData);

    if (targets.length === 0) {
        this.showNotification('Не найдено узлов с таким наименованием для дублирования.', 'info');
        return;
    }

    let insertionCount = 0;
    let imageId = null;

    // Обработка изображения (если оно было предоставлено)
    if (newImageDataBase64) {
        try {
            const blob = await (await fetch(newImageDataBase64)).blob();
            const compressedImage = await this.compressImage(new File([blob], "upload.jpg", { type: "image/jpeg" }));
            imageId = 'img_' + Date.now() + '_' + Math.random().toString(36).substr(2, 9);
            this.imagesData[imageId] = compressedImage;
        } catch (error) {
            console.error("Ошибка обработки изображения:", error);
            this.showNotification("Не удалось обработать изображение.", "error");
            imageId = null;
        }
    }

    // Этап 2: Обработка и вставка копий
    targets.forEach(originalNode => {
        const parent = this.findParent(this.treeData, originalNode.id);
        if (parent) {
            const hierarchyToCopy = this.serializeNodeWithChildren(originalNode);
            const newNode = this.restoreNodeWithChildren(hierarchyToCopy);

            // Применяем новое имя и изображение
            newNode.content.text = newNodeName;
            newNode.content.img = imageId;
            newNode.content.isHorizontal = true;

            // --- ✨ ИЗМЕНЕНИЕ 2: Присваиваем ВСЕМ новым узлам кластер от ИСХОДНОГО узла ---
            if (sourceCluster) {
                this.clusters.set(newNode.id, sourceCluster);
                // Убедимся, что кластер существует в списке доступных
                if (!this.availableClusters.has(sourceCluster)) {
                    this.availableClusters.add(sourceCluster);
                }
            } else {
                // Если у исходного узла не было кластера, удаляем его у копии
                this.clusters.delete(newNode.id);
            }

            // Вставляем готовый узел в дерево
            const index = parent.children.findIndex(child => child.id === originalNode.id);
            if (index !== -1) {
                parent.children.splice(index + 1, 0, newNode);
                insertionCount++;
            }
        }
    });

    if (insertionCount > 0) {
        this.logAction(`Дублировано ${insertionCount} узлов с наименованием "${targetName}" как "${newNodeName}"`);
        this.updateTree();
        this.saveData();
        this.showNotification(`Создано ${insertionCount} дубликатов для узлов "${targetName}".`);
    } else {
        this.showNotification('Не удалось создать дубликаты.', 'warning');
    }
}
async showTornadoReplacementDialog() {
    const expansionStates = new Map();
    const filterStates = new Map();

    if (!document.getElementById('circular-replacement-styles')) {
        const style = document.createElement('style');
        style.id = 'circular-replacement-styles';
        style.textContent = `
            .cr-backdrop { position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: rgba(0,0,0,0.6); display: flex; justify-content: center; align-items: center; z-index: 10002; backdrop-filter: blur(5px); }
            .cr-dialog { background: var(--controls-bg); padding: 20px; width: 100vw; height: 100vh; box-sizing: border-box; border-radius: 0; border: none; display: flex; flex-direction: column; }
            .cr-header { display: flex; justify-content: space-between; align-items: center; margin-bottom: 15px; padding-bottom: 10px; border-bottom: 1px solid var(--secondary-color); }
            .cr-header h3 { margin: 0; color: var(--primary-color); }
            .cr-content { display: flex; gap: 15px; flex: 1; min-height: 0; overflow-x: auto; padding: 10px; }
            .cr-pair-column { display: flex; flex-direction: column; gap: 10px; min-width: 500px; flex: 1; position: relative; }
            .cr-column-header { display: flex; justify-content: space-between; align-items: center; margin: 0 0 5px 0; text-align: center; flex-wrap: wrap; gap: 5px; }
            .cr-column-header h4 { margin: 0; flex-grow: 1; }
            .cr-search-input { padding: 4px 8px; border: 1px solid var(--secondary-color); border-radius: 4px; width: 100%; box-sizing: border-box; }
            .cr-tree-container { border: 1px solid var(--secondary-color); border-radius: 8px; padding: 10px; flex: 1; overflow-y: auto; }
            .cr-footer { margin-top: 15px; display: flex; justify-content: space-between; align-items: center; }
            .cr-footer .btn-group { display: flex; gap: 10px; }
            .cr-btn { padding: 8px 16px; border: none; border-radius: 6px; cursor: pointer; font-weight: 500; }
            .cr-add-btn { background: var(--primary-color); color: white; }
            .cr-remove-btn { background: var(--accent-color); color: white; }
            .cr-confirm-btn { background: #4CAF50; color: white; }
            .cr-cancel-btn { background: transparent; color: var(--accent-color); }
            .cr-tree-container .tree-selection-node input[type="checkbox"] { display: none; }
            .cr-tree-container .tree-selection-node label { display: block; width: 100%; padding: 4px; border-radius: 4px; cursor: pointer; }
            .cr-tree-container .tree-selection-node input[type="checkbox"]:checked + label { background-color: var(--secondary-color); color: white; font-weight: bold; }
        `;
        document.head.appendChild(style);
    }

    const backdrop = document.createElement('div');
    backdrop.className = 'cr-backdrop';
    const dialog = document.createElement('div');
    dialog.className = 'cr-dialog';
    dialog.innerHTML = `
        <div class="cr-header"><h3>Круговая замена (Торнадо)</h3></div>
        <div class="cr-content" id="cr-content-area"></div>
        <div class="cr-footer">
            <div class="btn-group">
                <button class="cr-btn cr-add-btn" id="cr-add-pair-btn">+ Добавить</button>
                <button class="cr-btn cr-remove-btn" id="cr-remove-pair-btn">- Убрать</button>
            </div>
            <div class="btn-group">
                <button class="cr-btn cr-cancel-btn">Отмена</button>
                <button class="cr-btn cr-confirm-btn">Выполнить</button>
            </div>
        </div>`;
    backdrop.appendChild(dialog);
    document.body.appendChild(backdrop);

    const contentArea = dialog.querySelector('#cr-content-area');
    let pairCount = 0;
    let selectedNodes = new Map();

    const renderColumns = () => {
        contentArea.querySelectorAll('.cr-search-input').forEach((input, index) => {
            filterStates.set(index + 1, input.value);
        });

        contentArea.innerHTML = '';
        for (let i = 1; i <= pairCount; i++) {
            const currentPairId = i;
            if (!expansionStates.has(currentPairId)) {
                expansionStates.set(currentPairId, new Set());
            }

            const column = document.createElement('div');
            column.className = 'cr-pair-column';
            column.dataset.pairId = currentPairId;

            const header = document.createElement('div');
            header.className = 'cr-column-header';
            const title = document.createElement('h4');
            title.textContent = currentPairId === 1 ? `Кого меняем (№1)` : `На кого меняем (№${currentPairId - 1})`;

            const searchInput = document.createElement('input');
            searchInput.type = 'text';
            searchInput.placeholder = 'Поиск...';
            searchInput.className = 'cr-search-input';
            searchInput.value = filterStates.get(currentPairId) || '';

            header.appendChild(title);
            header.appendChild(searchInput);
            column.appendChild(header);

            const treeContainer = document.createElement('div');
            treeContainer.className = 'cr-tree-container';
            column.appendChild(treeContainer);
            contentArea.appendChild(column);

            const redrawTree = () => {
                const filterText = searchInput.value.toLowerCase().trim();
                filterStates.set(currentPairId, searchInput.value);
                // --- ИЗМЕНЕНИЕ ЗДЕСЬ ---
                // Устанавливаем флаг авто-раскрытия в true для всех колонок
                const autoExpand = true;
                this.createSingleSelectableTree(
                    treeContainer,
                    (nodeId) => selectedNodes.set(currentPairId, nodeId),
                    selectedNodes.get(currentPairId),
                    expansionStates.get(currentPairId),
                    filterText,
                    true, // isFirstColumn (оставляем для совместимости, если где-то еще используется)
                    null,
                    null,
                    autoExpand // Новый параметр
                );
            };

            searchInput.addEventListener('input', redrawTree);
            redrawTree();
        }
    };

    const addPairColumn = () => {
        if (pairCount >= 4) {
            this.showNotification("Максимум 4 пары для замены.");
            return;
        }
        pairCount++;
        renderColumns();
    };

    const removePairColumn = () => {
        if (pairCount > 2) {
            selectedNodes.delete(pairCount);
            expansionStates.delete(pairCount);
            filterStates.delete(pairCount);
            pairCount--;
            renderColumns();
        } else {
            this.showNotification("Минимум 2 колонки для замены.");
        }
    };

    addPairColumn();
    addPairColumn();

    dialog.querySelector('#cr-add-pair-btn').addEventListener('click', addPairColumn);
    dialog.querySelector('#cr-remove-pair-btn').addEventListener('click', removePairColumn);
    const closeDialog = () => document.body.removeChild(backdrop);
    dialog.querySelector('.cr-cancel-btn').addEventListener('click', () => {
        closeDialog();
        this.promptReplacementMode();
    });
    backdrop.addEventListener('click', (e) => { if (e.target === backdrop) closeDialog(); });
    dialog.querySelector('.cr-confirm-btn').addEventListener('click', async () => {
        const replacementChain = [];
        for (let i = 1; i <= pairCount; i++) {
            if (!selectedNodes.has(i) || selectedNodes.get(i) === null) {
                this.showNotification(`Не выбран узел в колонке №${i}`, 'error');
                return;
            }
            replacementChain.push(selectedNodes.get(i));
        }
        await this.executeCircularReplacement(replacementChain);
        closeDialog();
    });
}
createSingleSelectableTree(container, onSelect, selectedId = null, expansionState = new Set(), filterText = '', isFirstColumn = false, disableRule = null, redrawCallback = null, autoExpandOnFilter = false) {
    container.innerHTML = '';

    // --- НАЧАЛО ИЗМЕНЕНИЙ: Логика автоматического раскрытия ---
    if (filterText && autoExpandOnFilter) {
        const expandMatchingNodes = (node) => {
            let matches = this.nodeMatchesSearch(node, filterText);
            let hasMatchingChild = false;

            if (node.children && node.children.length > 0) {
                node.children.forEach(child => {
                    // Рекурсивный вызов возвращает true, если потомок соответствует
                    if (expandMatchingNodes(child)) {
                        hasMatchingChild = true;
                    }
                });
            }

            // Раскрываем узел, если он сам или его потомок соответствует фильтру
            if (matches || hasMatchingChild) {
                expansionState.add(node.id);
                return true; // Сообщаем родителю, что нужно раскрыться
            }
            return false;
        };
        expandMatchingNodes(this.treeData);
    }
    // --- КОНЕЦ ИЗМЕНЕНИЙ ---

    const finalRedrawCallback = redrawCallback || (() => {
        this.createSingleSelectableTree(container, onSelect, selectedId, expansionState, filterText, isFirstColumn, disableRule, finalRedrawCallback, autoExpandOnFilter);
    });

    const createNodeRecursive = (node, parentElement, level = 0, ancestorMatches = false) => {
        const currentNodeMatches = filterText ? this.nodeMatchesSearch(node, filterText) : true;
        const hasVisibleChild = filterText ? this.isParentOfMatch(node, filterText) : false;

        if (filterText && !currentNodeMatches && !hasVisibleChild && !ancestorMatches) {
            return;
        }

        const nodeElement = document.createElement('div');
        nodeElement.className = 'tree-selection-node';
        nodeElement.style.marginLeft = `${level * 15}px`;

        const isDisabled = disableRule ? disableRule(node) : false;
        if (isDisabled) {
            nodeElement.dataset.disabled = "true";
        }

        const contentWrapper = document.createElement('div');
        contentWrapper.style.display = 'flex';
        contentWrapper.style.alignItems = 'center';

        const expandIcon = document.createElement('span');
        expandIcon.style.cursor = 'pointer';
        expandIcon.style.width = '15px';
        expandIcon.style.display = 'inline-block';

        const childrenContainer = document.createElement('div');
        childrenContainer.className = 'tree-selection-children';

        const isExpanded = expansionState.has(node.id);
        childrenContainer.style.display = isExpanded ? 'block' : 'none';

        if (node.children && node.children.length > 0) {
            expandIcon.textContent = isExpanded ? '▼' : '▶';
            expandIcon.addEventListener('click', (e) => {
                e.stopPropagation();
                if (expansionState.has(node.id)) {
                    expansionState.delete(node.id);
                } else {
                    expansionState.add(node.id);
                }
                if (finalRedrawCallback) {
                    finalRedrawCallback();
                }
            });
        }

        const inputId = `cr-node-${node.id}-${Math.random()}`;
        const input = document.createElement('input');
        input.type = 'checkbox';
        input.id = inputId;
        input.value = node.id;
        if (node.id === selectedId) {
            input.checked = true;
        }
        if (isDisabled) {
            input.disabled = true;
        }

        input.addEventListener('change', () => {
            container.querySelectorAll('input[type="checkbox"]').forEach(cb => {
                if (cb !== input) cb.checked = false;
            });
            const newSelectedId = input.checked ? parseInt(node.id, 10) : null;
            onSelect(newSelectedId);
            this.createSingleSelectableTree(container, onSelect, newSelectedId, expansionState, filterText, isFirstColumn, disableRule, finalRedrawCallback, autoExpandOnFilter);
        });

        const label = document.createElement('label');
        label.htmlFor = inputId;
        label.textContent = node.content.text;

        contentWrapper.appendChild(expandIcon);
        contentWrapper.appendChild(input);
        contentWrapper.appendChild(label);
        nodeElement.appendChild(contentWrapper);
        nodeElement.appendChild(childrenContainer);
        parentElement.appendChild(nodeElement);

        if (isExpanded) {
            node.children.forEach(child => createNodeRecursive(child, childrenContainer, level + 1, ancestorMatches || currentNodeMatches));
        }
    };

    createNodeRecursive(this.treeData, container, 0, false);
}
async executeCircularReplacement(idChain) {
    // ✨ НАЧАЛО ИЗМЕНЕНИЙ: Проверки перед выполнением ✨
    const selectedNodeObjects = idChain.map(id => this.findNode(this.treeData, id));
    const nodeNames = selectedNodeObjects.map(node => node.content.text);

    // 1. Проверка на спец. узлы (isIndicator или isOKR)
    for (const node of selectedNodeObjects) {
        if (node.content.isIndicator || node.content.isOKR) {
            this.showNotification(`Нельзя использовать в замене специальные узлы типа "Гос. программа" или "OKR": "${node.content.text}"`, 'error');
            return;
        }
    }

    // 2. Проверка на дубликаты имен
    // Аналогия: `Set` — это как коллекция, в которой каждый предмет может быть только один раз.
    // Если после добавления всех имен в Set их количество меньше, чем было в исходном списке, значит, были дубликаты. [5, 6]
    if (new Set(nodeNames).size !== nodeNames.length) {
        this.showNotification('Нельзя выбирать узлы с одинаковыми названиями для круговой замены.', 'error');
        return;
    }
    // ✨ КОНЕЦ ИЗМЕНЕНИЙ ✨

    this.saveToHistory(false, true);

    const replacementPlan = new Map();
    const logParts = [];

    for (let i = 0; i < idChain.length; i++) {
        const sourceNode = this.findNode(this.treeData, idChain[i]);
        if (!sourceNode) continue;

        const sourceText = sourceNode.content.text;
        let newContent;
        let logMessage = '';

        if (i < idChain.length - 1) {
            const targetNode = this.findNode(this.treeData, idChain[i + 1]);
            if (!targetNode) continue;
            newContent = JSON.parse(JSON.stringify(targetNode.content));
            logMessage = `'${sourceText}' → '${targetNode.content.text}'`;
        } else {
            newContent = {
                text: "Оргштатные мероприятия",
                img: null,
                subBlocks: [],
                isHorizontal: true,
                isOrganizationalEvent: true,
                files: []
            };
            logMessage = `'${sourceText}' → 'Оргштатные мероприятия'`;
        }

        if (!replacementPlan.has(sourceText)) {
            replacementPlan.set(sourceText, { newContent });
            logParts.push(logMessage);
        }
    }

const applyReplacementRecursive = (node) => {
    node.children.forEach(child => applyReplacementRecursive(child));

    if (replacementPlan.has(node.content.text)) {
        const plan = replacementPlan.get(node.content.text);
        // --- НАЧАЛО ИЗМЕНЕНИЯ ---
        // 1. Сохраняем оригинальную должность
        const originalPosition = node.content.position || null;
        // --- КОНЕЦ ИЗМЕНЕНИЯ ---

        const originalFiles = node.content.files || [];
        const originalSubBlocks = node.content.subBlocks || [];
        const originalSpecialFlags = {
            isSubordinate: node.content.isSubordinate || false,
            isPower269: node.content.isPower269 || false,
            absent269: node.content.absent269 || false,
            isForAll: node.content.isForAll || false,
            isAuthority: node.content.isAuthority || false,
            isOKR: node.content.isOKR || false,
            isIndicator: node.content.isIndicator || false
        };

        node.content = JSON.parse(JSON.stringify(plan.newContent));
        node.content.files = originalFiles;
        node.content.subBlocks = originalSubBlocks;
        Object.assign(node.content, originalSpecialFlags);

        // --- НАЧАЛО ИЗМЕНЕНИЯ ---
        // 2. Восстанавливаем оригинальную должность
        node.content.position = originalPosition;
        // --- КОНЕЦ ИЗМЕНЕНИЯ ---

        node.circularlyReplaced = true;
    }
};

    applyReplacementRecursive(this.treeData);
    this.logAction(`Круговая замена: ${logParts.join(', ')}.`);
    this.updateTree();
    this.saveData();
    this.showNotification('Круговая замена по всей иерархии успешно выполнена!');
}
async showTreeSelectionDialog(node) {
    const container = document.createElement('div');
    container.style.cssText = `
        position: fixed; top: 50%; left: 50%; transform: translate(-50%, -50%);
        background: var(--controls-bg); padding: 20px; border: 1px solid var(--primary-color);
        border-radius: 8px; box-shadow: 0 4px 8px rgba(0,0,0,0.2); z-index: 10000;
        max-height: 80vh; overflow-y: auto; min-width: 300px; max-width: 600px;
    `;

    const title = document.createElement('h3');
    title.textContent = 'Выберите узлы для копирования';
    title.style.cssText = 'margin-top: 0; color: var(--primary-color);';
    container.appendChild(title);

    const treeContainer = document.createElement('div');
    treeContainer.style.cssText = 'max-height: 60vh; overflow-y: auto;';
    container.appendChild(treeContainer);

    const selectedIds = new Set();
    // ✨ ИСПРАВЛЕНИЕ 1: Сразу добавляем корневой узел в список выбранных. [1]
    selectedIds.add(node.id);

    const createTreeNode = (node, parentElement, level = 0) => {
        const nodeElement = document.createElement('div');
        nodeElement.style.cssText = `
            padding: 8px 8px 8px ${level * 20 + 8}px; border-bottom: 1px solid rgba(93, 138, 168, 0.2);
            display: flex; align-items: center;
        `;

        let expandIcon = null;
        if (node.children.length > 0) {
            expandIcon = document.createElement('span');
            expandIcon.textContent = '▼';
            expandIcon.style.cssText = 'cursor: pointer; margin-right: 8px;';
            nodeElement.appendChild(expandIcon);
        } else {
            const spacer = document.createElement('span');
            spacer.style.cssText = 'width: 16px; display: inline-block;';
            nodeElement.appendChild(spacer);
        }

        const checkbox = document.createElement('input');
        checkbox.type = 'checkbox';
        checkbox.id = `node-${node.id}`;
        checkbox.value = node.id;

        // ✨ ИСПРАВЛЕНИЕ 2: Делаем корневой узел выбранным и неактивным для снятия галочки. [2]
        if (level === 0) {
            checkbox.checked = true;
            checkbox.disabled = true;
        } else {
            checkbox.checked = false;
        }

        checkbox.style.marginRight = '10px';
        nodeElement.appendChild(checkbox);

        const label = document.createElement('label');
        label.htmlFor = `node-${node.id}`;
        label.textContent = node.content.text.length > 50 ? node.content.text.substring(0, 47) + '...' : node.content.text;
        label.title = node.content.text;
        label.style.cssText = 'cursor: pointer; flex-grow: 1;';
        nodeElement.appendChild(label);

        checkbox.addEventListener('change', () => {
            if (checkbox.checked) {
                selectedIds.add(node.id);
            } else {
                selectedIds.delete(node.id);
            }
        });

        parentElement.appendChild(nodeElement);

        const childrenContainer = document.createElement('div');
        childrenContainer.style.display = 'block';
        parentElement.appendChild(childrenContainer);

        if (expandIcon) {
            expandIcon.addEventListener('click', () => {
                const isExpanded = childrenContainer.style.display === 'block';
                childrenContainer.style.display = isExpanded ? 'none' : 'block';
                expandIcon.textContent = isExpanded ? '▼' : '▶';
            });
        }

        node.children.forEach(child => createTreeNode(child, childrenContainer, level + 1));
    };

    createTreeNode(node, treeContainer, 0);

    const buttons = document.createElement('div');
    buttons.style.cssText = 'display: flex; justify-content: flex-end; gap: 10px; margin-top: 15px;';
    container.appendChild(buttons);

    const okButton = document.createElement('button');
    okButton.textContent = 'ОК';
    okButton.style.cssText = `
        padding: 6px 12px; background: var(--primary-color); color: white;
        border: none; border-radius: 4px; cursor: pointer;
    `;
    buttons.appendChild(okButton);

    const cancelButton = document.createElement('button');
    cancelButton.textContent = 'Отмена';
    cancelButton.style.cssText = `
        padding: 6px 12px; background: linear-gradient(145deg, #ff4444, #d32f2f);
        color: white; border: none; border-radius: 4px; cursor: pointer;
    `;
    buttons.appendChild(cancelButton);

    document.body.appendChild(container);

    // Оборачиваем в Promise, чтобы дождаться выбора пользователя. [3]
    return new Promise((resolve) => {
        okButton.addEventListener('click', () => {
            document.body.removeChild(container);
            resolve(selectedIds);
        });
        cancelButton.addEventListener('click', () => {
            document.body.removeChild(container);
            resolve(null);
        });
    });
}
getAllDescendantIds(startNode) {
    const ids = [];
    const collect = (node) => {
        if (!node || !node.children) return;
        for (const child of node.children) {
            ids.push(child.id);
            collect(child); // Рекурсивный вызов для сбора внуков и т.д.
        }
    };
    collect(startNode);
    return ids;
}
createSelectableTree( container, onSelect, startNode = this.treeData, useCheckboxes = false, initialState = new Map(), filterText = '', expansionStateForRender = new Set(), expansionStateForManualToggle = null, disabledNodeIds = new Map(), groupColor = '1', allTargets = new Map(), autoExpandOnFilter = false ) {
    if (!document.getElementById('rs-checkbox-styles')) {
        const style = document.createElement('style');
        style.id = 'rs-checkbox-styles';
        style.textContent = `
            .rs-dialog input[type="checkbox"].custom-checkbox {
                appearance: none;
                width: 16px;
                height: 16px;
                border: 2px solid var(--secondary-color);
                border-radius: 4px;
                cursor: pointer;
                position: relative;
                outline: none;
                transition: all 0.2s ease;
            }
            .rs-dialog input[type="checkbox"].custom-checkbox::before {
                content: var(--symbol-content, "");
                color: white;
                position: absolute;
                top: 50%;
                left: 50%;
                transform: translate(-50%, -50%);
                font-size: 12px;
                font-weight: bold;
            }
        `;
        document.head.appendChild(style);
    }

    // --- ✨ ИЗМЕНЕНИЕ ЗДЕСЬ: Логика авто-раскрытия теперь зависит от нового параметра ---
    if (filterText && autoExpandOnFilter) {
        const expandMatchingNodes = (node) => {
            let matches = this.nodeMatchesSearch(node, filterText, true);
            let hasMatchingChild = false;

            if (node.children && node.children.length > 0) {
                node.children.forEach(child => {
                    if (expandMatchingNodes(child)) {
                        hasMatchingChild = true;
                    }
                });
            }

            // Раскрываем узел, если он сам или его потомок соответствует фильтру
            if (matches || hasMatchingChild) {
                expansionStateForRender.add(node.id);
                return true; // Сообщаем родителю, что нужно раскрыться
            }
            return false;
        };
        expandMatchingNodes(this.treeData);
    }
    // --- КОНЕЦ ИЗМЕНЕНИЯ ---

    const createTreeNode = (node, parentElement, level = 0, ancestorMatches = false) => {
        const currentNodeMatches = filterText ? this.nodeMatchesSearch(node, filterText, true) : true;
        const hasVisibleChild = filterText ? this.isParentOfMatch(node, filterText, true) : false;

        if (filterText && !currentNodeMatches && !hasVisibleChild && !ancestorMatches) {
            return;
        }

        const nodeElement = document.createElement('div');
        nodeElement.className = 'tree-selection-node';
        nodeElement.style.cssText = `padding: 5px; display: flex; align-items: center; border-radius: 4px; margin-left: ${level * 20}px; user-select: none; transition: all 0.2s;`;

        if (allTargets.has(node.id)) {
            const targetInfo = allTargets.get(node.id);
            nodeElement.style.border = `2px solid ${targetInfo.color}`;
            nodeElement.style.paddingLeft = '3px';
            nodeElement.style.marginLeft = `${level * 20 - 2}px`;
            if (targetInfo.is_active) {
                const hexToRgb = (hex) => {
                    const result = /^#?([a-f\\d]{2})([a-f\\d]{2})([a-f\\d]{2})$/i.exec(hex);
                    return result ? `${parseInt(result[1], 16)}, ${parseInt(result[2], 16)}, ${parseInt(result[3], 16)}` : '93, 138, 168';
                };
                let colorRgb = '93, 138, 168';
                if (targetInfo.color.startsWith('#')) {
                    colorRgb = hexToRgb(targetInfo.color);
                }
                nodeElement.style.background = `rgba(${colorRgb}, 0.15)`;
            }
        }

        let expandIcon = null;
        if (node.children && node.children.length > 0) {
            expandIcon = document.createElement('span');
            expandIcon.style.cssText = 'cursor: pointer; margin-right: 8px; width: 16px;';
            nodeElement.appendChild(expandIcon);
        } else {
            const spacer = document.createElement('span');
            spacer.style.cssText = 'display: inline-block; width: 24px;';
            nodeElement.appendChild(spacer);
        }

        const input = document.createElement('input');
        input.type = useCheckboxes ? 'checkbox' : 'radio';
        input.name = useCheckboxes ? `select-move-${node.id}-${groupColor}` : `reparent-target-${container.id}`;
        input.value = node.id;
        input.id = `dialog-input-${node.id}-${groupColor}`;
        input.style.marginRight = '8px';

        const label = document.createElement('label');
        label.textContent = node.content.text;
        label.htmlFor = input.id;
        label.style.cursor = 'pointer';

        if (node.content.isIndicator || node.content.isOKR) {
            disabledNodeIds.set(node.id, true);
            if (useCheckboxes) {
                input.dataset.isLocked = 'true';
            }
        }

        if (disabledNodeIds.has(node.id)) {
            input.disabled = true;
            nodeElement.style.opacity = '0.5';
            nodeElement.style.cursor = 'not-allowed';
            label.style.textDecoration = 'line-through';
            label.style.cursor = 'not-allowed';
        }

        if (useCheckboxes) {
            input.className = 'custom-checkbox';
            input.style.cssText = 'appearance: none; width: 16px; height: 16px; border: 2px solid var(--secondary-color); border-radius: 4px; cursor: pointer; position: relative; outline: none; transition: all 0.2s ease;';

            input.updateVisuals = () => {
                input.style.backgroundColor = 'transparent';
                input.style.borderColor = 'var(--secondary-color)';
                input.style.setProperty('--symbol-content', '""');
                nodeElement.style.opacity = input.disabled ? '0.6' : '1';
                const state = input.dataset.state;
                const color = input.dataset.groupColor;
                if (state === 'move') {
                    input.style.backgroundColor = color;
                    input.style.borderColor = color;
                    input.style.setProperty('--symbol-content', '"✔"');
                } else if (state === 'delete') {
                    input.style.backgroundColor = color;
                    input.style.borderColor = color;
                    input.style.setProperty('--symbol-content', '"✖"');
                }
            };

            input.dataset.groupColor = groupColor;
            const currentState = initialState.get(node.id);
            input.dataset.state = currentState || 'none';
        } else {
            if (initialState.has(node.id)) {
                input.checked = true;
            }
        }

        nodeElement.appendChild(input);
        nodeElement.appendChild(label);
        parentElement.appendChild(nodeElement);

        const childrenContainer = document.createElement('div');
        childrenContainer.className = 'tree-selection-children';
        parentElement.appendChild(childrenContainer);

        const isExpanded = expansionStateForRender.has(node.id);
        childrenContainer.style.display = isExpanded ? 'block' : 'none';
        if (expandIcon) {
            expandIcon.textContent = isExpanded ? '▼' : '▶';
        }

        if (useCheckboxes) {
            const handleSelection = (e, type) => {
                e.preventDefault();
                if (input.disabled) return;
                const targetState = type === 'move' ? 'move' : 'delete';

                if (e.ctrlKey) {
                    const clickedNode = this.findNode(this.treeData, node.id);
                    if (clickedNode) {
                        const descendantIds = this.getAllDescendantIds(clickedNode);
                        const allIdsToChange = [node.id, ...descendantIds];
                        const currentState = initialState.get(node.id) || 'none';
                        const newState = currentState === targetState ? 'none' : targetState;

                        allIdsToChange.forEach(id => {
                            const nodeToUpdate = this.findNode(this.treeData, id);

                            if (nodeToUpdate && !nodeToUpdate.content.isIndicator && !nodeToUpdate.content.isOKR) {
                                onSelect(id, newState);
                            }
                        });

                        if (typeof updateAllVisualStates === 'function') {
                            updateAllVisualStates();
                        }
                    }
                } else {
                    const currentState = input.dataset.state || 'none';
                    const newState = currentState === targetState ? 'none' : targetState;
                    onSelect(parseInt(node.id, 10), newState);
                }
            };

            nodeElement.addEventListener('click', (e) => handleSelection(e, 'move'));
            nodeElement.addEventListener('contextmenu', (e) => handleSelection(e, 'delete'));
        } else {
            nodeElement.addEventListener('click', () => {
                if (input.disabled) {
                    onSelect(parseInt(node.id, 10));
                    return;
                }
                if (input.checked) return;
                input.checked = true;
                onSelect(parseInt(node.id, 10));
            });
        }

        if (typeof input.updateVisuals === 'function') {
            input.updateVisuals();
        }

        if (expandIcon) {
            expandIcon.addEventListener('click', (e) => {
                e.stopPropagation();
                const stateToModify = expansionStateForManualToggle || expansionStateForRender;
                const isCurrentlyExpanded = stateToModify.has(node.id);
                if (isCurrentlyExpanded) {
                    stateToModify.delete(node.id);
                    childrenContainer.style.display = 'none';
                    expandIcon.textContent = '▶';
                } else {
                    stateToModify.add(node.id);
                    if (!childrenContainer.hasChildNodes()) {
                        if (node.children) {
                            node.children.forEach(child => createTreeNode(child, childrenContainer, level + 1, ancestorMatches || currentNodeMatches));
                        }
                    }
                    childrenContainer.style.display = 'block';
                    expandIcon.textContent = '▼';
                }
            });
        }

        if (node.children && isExpanded) {
            node.children.forEach(child => createTreeNode(child, childrenContainer, level + 1, ancestorMatches || currentNodeMatches));
        }
    };

    createTreeNode(startNode, container, 0, false);
}
addSelectedNodesToStructure(parentStructure, levelNodes, selectedIds, level) {
    levelNodes.forEach(node => {
        if (selectedIds.has(node.id)) {
            const parent = this.findParent(this.treeData, node.id);
            let parentStruct = parentStructure;
            if (level > 1) {
                // Находим родительскую структуру для текущего уровня
                let current = parentStructure;
                for (let i = 1; i < level; i++) {
                    const nextParent = current.children.find(c => c.id === (i === level - 1 ? parent.id : c.id));
                    if (nextParent) {
                        current = nextParent;
                    } else {
                        break;
                    }
                }
                parentStruct = current;
            }
            if (!parentStruct.children) parentStruct.children = [];
            parentStruct.children.push({ id: node.id, children: [] });
        }
    });
}
serializeNodeWithSelectedChildren(node, structure) {
    const serialized = {
        id: node.id,
        content: {
            text: node.content.text,
            img: node.content.img,
            hideIcon: node.content.hideIcon || false,
            isTextOnly: node.content.isTextOnly || false,
            subBlocks: [...(node.content.subBlocks || [])],
            isHorizontal: node.content.isHorizontal || false,
            metricBlocks: node.content.metricBlocks ? [...node.content.metricBlocks] : [],
            isAuthority: node.content.isAuthority || false,
            absent269: node.content.absent269 || false,
            isPower269: node.content.isPower269 || false,
            isOKR: node.content.isOKR || false,
            isSubordinate: node.content.isSubordinate || false,
            isForAll: node.content.isForAll || false,
            isIndicator: node.content.isIndicator || false,
            indicators: node.content.isIndicator ? {...node.content.indicators} : null,
            files: [],
position: node.content.position || null
        },
        children: [],
        isExpanded: node.isExpanded
    };

    // Добавляем только выбранные дети
    if (structure.children && structure.children.length > 0) {
        structure.children.forEach(childStruct => {
            const childNode = this.findNode(node, childStruct.id);
            if (childNode) {
                const childSerialized = this.serializeNodeWithSelectedChildren(childNode, childStruct);
                serialized.children.push(childSerialized);
            }
        });
    }

    return serialized;
}
pasteNode() {
    this.saveToHistory();
    try {
        if (!this.clipboard || !this.selectedNode) {
            this.showNotification('Нет узлов в буфере обмена или не выбран целевой узел');
            return;
        }

        if (this.clipboard.timestamp && Date.now() - this.clipboard.timestamp > 3600000) {
            if (!confirm('Скопированные данные устарели (старше 1 часа). Использовать их?')) {
                return;
            }
        }

        const processPastedNode = (nodeData) => {
            const newNode = this.restoreNodeWithChildren(nodeData);
            const markForUpdate = (node) => {
                node.needsClusterUpdate = true;
                node.children.forEach(markForUpdate);
            };
            markForUpdate(newNode);
            return newNode;
        };

        const handleCutOperation = (nodesData) => {
            if (!this.clipboard.isCutOperation) return;
            nodesData.forEach(nodeData => {
                const originalNode = this.findNode(this.treeData, nodeData.id);
                if (originalNode) {
                    const parent = this.findParent(this.treeData, nodeData.id);
                    if (parent) {
                        const copiedChildIds = this.getCopiedChildIds(nodeData);
                        const remainingChildren = originalNode.children.filter(child => !copiedChildIds.has(child.id));
                        const index = parent.children.indexOf(originalNode);
                        parent.children.splice(index + 1, 0, ...remainingChildren);
                        parent.children = parent.children.filter(child => child.id !== originalNode.id);
                    }
                }
            });
        };

        // --- ✨ WHAT'S NEW HERE ✨ ---
        const pastedNodeNames = [];
        if (this.clipboard.isMultiCopy && this.clipboard.nodes) {
            this.clipboard.nodes.forEach(nodeData => pastedNodeNames.push(`"${nodeData.content.text}"`));
            this.logAction(`Вставлено узлов (${pastedNodeNames.length}) рядом с "${this.selectedNode.node.content.text}": ${pastedNodeNames.join(', ')}`);
        } else if (this.clipboard.node) {
            pastedNodeNames.push(`"${this.clipboard.node.content.text}"`);
            this.logAction(`Вставлен узел ${pastedNodeNames[0]} рядом с "${this.selectedNode.node.content.text}"`);
        }
        // --- ✨ END OF CHANGES ✨ ---

        if (this.clipboard.isMultiCopy && this.clipboard.nodes) {
            const parent = this.findParent(this.treeData, this.selectedNode.node.id);
            const newNodes = this.clipboard.nodes.map(processPastedNode);

            if (parent) {
                const selectedIndex = parent.children.indexOf(this.selectedNode.node);
                parent.children.splice(selectedIndex + 1, 0, ...newNodes);
            } else {
                this.selectedNode.node.children.push(...newNodes);
            }

            handleCutOperation(this.clipboard.nodes);
            this.showNotification(`Вставлено ${newNodes.length} узлов с детьми`);

        } else if (this.clipboard.node) {
            const newNode = processPastedNode(this.clipboard.node);
            const parent = this.findParent(this.treeData, this.selectedNode.node.id);

            if (parent) {
                const selectedIndex = parent.children.indexOf(this.selectedNode.node);
                parent.children.splice(selectedIndex + 1, 0, newNode);
            } else {
                this.selectedNode.node.children.push(newNode);
            }

            handleCutOperation([this.clipboard.node]);
            this.showNotification(`Узел с детьми вставлен рядом с "${this.selectedNode.node.content.text}"`);
        }

        this.updateTree();
        this.saveData();
        this.clipboard = null;
        this.clearMultiSelection();

    } catch (error) {
        console.error('Ошибка вставки:', error);
        this.showNotification('Ошибка при вставке узла');
    }
}
getCopiedChildIds(nodeData) {
    const ids = new Set();
    if (nodeData.children) {
        nodeData.children.forEach(child => {
            ids.add(child.id);
            this.addAllChildIds(child, ids);
        });
    }
    return ids;
}
addAllChildIds(nodeData, ids) {
    if (nodeData.children) {
        nodeData.children.forEach(child => {
            ids.add(child.id);
            this.addAllChildIds(child, ids);
        });
    }
}
pasteNodeAsChild() {
    this.saveToHistory();
    try {
        if (!this.clipboard || !this.selectedNode) {
            this.showNotification('Нет узлов в буфере обмена или не выбран целевой узел');
            return;
        }

        if (this.clipboard.timestamp && Date.now() - this.clipboard.timestamp > 3600000) {
            if (!confirm('Скопированные данные устарели (старше 1 часа). Использовать их?')) {
                return;
            }
        }

        const processPastedNode = (nodeData) => {
            const newNode = this.restoreNodeWithChildren(nodeData);
            const markForUpdate = (node) => {
                node.needsClusterUpdate = true;
                node.children.forEach(markForUpdate);
            };
            markForUpdate(newNode);
            return newNode;
        };

        const handleCutOperation = (nodesData) => {
            if (!this.clipboard.isCutOperation) return;
            nodesData.forEach(nodeData => {
                const originalNode = this.findNode(this.treeData, nodeData.id);
                if (originalNode) {
                    const parent = this.findParent(this.treeData, nodeData.id);
                    if (parent) {
                        const copiedChildIds = this.getCopiedChildIds(nodeData);
                        const remainingChildren = originalNode.children.filter(child => !copiedChildIds.has(child.id));
                        const index = parent.children.indexOf(originalNode);
                        parent.children.splice(index + 1, 0, ...remainingChildren);
                        parent.children = parent.children.filter(child => child.id !== originalNode.id);
                    }
                }
            });
        };

        // --- ✨ WHAT'S NEW HERE ✨ ---
        const pastedNodeNames = [];
        if (this.clipboard.isMultiCopy && this.clipboard.nodes) {
            this.clipboard.nodes.forEach(nodeData => pastedNodeNames.push(`"${nodeData.content.text}"`));
            this.logAction(`Вставлено узлов (${pastedNodeNames.length}) как дочерние к "${this.selectedNode.node.content.text}": ${pastedNodeNames.join(', ')}`);
        } else if (this.clipboard.node) {
            pastedNodeNames.push(`"${this.clipboard.node.content.text}"`);
            this.logAction(`Вставлен узел ${pastedNodeNames[0]} как дочерний к "${this.selectedNode.node.content.text}"`);
        }
        // --- ✨ END OF CHANGES ✨ ---

        if (this.clipboard.isMultiCopy && this.clipboard.nodes) {
            const newNodes = this.clipboard.nodes.map(processPastedNode);
            this.selectedNode.node.children.push(...newNodes);
            handleCutOperation(this.clipboard.nodes);
            this.showNotification(`Вставлено ${newNodes.length} узлов как дочерние`);

        } else if (this.clipboard.node) {
            const newNode = processPastedNode(this.clipboard.node);
            this.selectedNode.node.children.push(newNode);
            handleCutOperation([this.clipboard.node]);
            this.showNotification(`Вставлен узел "${newNode.content.text}" как дочерний`);
        }

        this.updateTree();
        this.saveData();
        this.clipboard = null;
        this.clearMultiSelection();

    } catch (error) {
        console.error('Ошибка вставки как дочернего:', error);
        this.showNotification('Ошибка при вставке как дочернего: ' + error.message);
    }
}

pasteAsParent() {
    if (!this.selectedNode || !this.clipboard || this.clipboard.isMultiCopy || (this.clipboard.node && this.clipboard.node.children.length > 0)) {
        this.showNotification('Эта операция возможна только для одиночного узла, скопированного без дочерних элементов.', 'error');
        return;
    }

    const parent = this.findParent(this.treeData, this.selectedNode.node.id);
    if (!parent) {
        this.showNotification('Нельзя выполнить эту операцию для корневого узла.', 'error');
        return;
    }

    this.saveToHistory();

    const newNode = this.restoreNodeWithChildren(this.clipboard.node);
    const selected = this.selectedNode.node;
    const index = parent.children.findIndex(child => child.id === selected.id);

    // --- ✨ WHAT'S NEW HERE ✨ ---
    this.logAction(`Узел "${newNode.content.text}" вставлен как родительский для "${selected.content.text}"`);
    // --- ✨ END OF CHANGES ✨ ---

    const markForUpdate = (node) => {
        if (!node) return;
        node.needsClusterUpdate = true;
        node.children.forEach(markForUpdate);
    };
    markForUpdate(newNode);

    if (index !== -1) {
        newNode.children.push(selected);
        parent.children.splice(index, 1, newNode);
    }

    this.updateTree();
    this.saveData();
    this.showNotification(`Узел "${newNode.content.text}" стал родительским.`);
}
replaceNode() {
    // Проверяем, что в буфере одиночный узел без детей
    if (!this.selectedNode || !this.clipboard || this.clipboard.isMultiCopy || (this.clipboard.node && this.clipboard.node.children.length > 0)) {
        this.showNotification('Эта операция возможна только для одиночного узла, скопированного без дочерних элементов.', 'error');
        return;
    }

    const parent = this.findParent(this.treeData, this.selectedNode.node.id);
    if (!parent) {
        this.showNotification('Нельзя заменить корневой узел.', 'error');
        return;
    }

    this.saveToHistory(); // Сохраняем состояние для отмены

    const newNode = this.restoreNodeWithChildren(this.clipboard.node);
    const selected = this.selectedNode.node;
    const index = parent.children.findIndex(child => child.id === selected.id);

    // --- ✨ ВОТ И ИЗМЕНЕНИЕ ✨ ---
    // Просто добавляем запись в лог перед тем, как что-либо менять.
    // Мы используем `newNode.content.text` для имени нового узла и `selected.content.text` для старого.
    this.logAction(`Узел "${selected.content.text}" заменен на "${newNode.content.text}"`);
    // --- ✨ КОНЕЦ ИЗМЕНЕНИЯ ✨ ---

    // ⭐ Помечаем новый узел для обновления в интерфейсе отделов
    const markForUpdate = (node) => {
        if (!node) return;
        // Установка этого свойства — это как повесить на узел ярлык "Требует внимания"
        node.needsClusterUpdate = true;
        // Рекурсивно помечаем всех детей, чтобы вся ветка подсветилась
        node.children.forEach(markForUpdate);
    };
    markForUpdate(newNode);

    if (index !== -1) {
        newNode.children = selected.children; // Переносим всех детей старого узла в новый
        // Заменяем старый узел новым
        parent.children.splice(index, 1, newNode);
    }

    this.selectedNode = null; // Сбрасываем выделение
    this.selectedNodeId = null;

    this.updateTree();
    this.saveData();
    this.showNotification(`Узел заменен на "${newNode.content.text}".`);
}
// --- ВСТАВИТЬ СЮДА ---
getCopiedChildIds(nodeData) {
    const copiedIds = new Set();
    const collectIds = (node) => {
        copiedIds.add(node.id);
        if (node.children) {
            node.children.forEach(child => collectIds(child));
        }
    };
    collectIds(nodeData);
    return copiedIds;
}
async checkClipboard() {
    if (!navigator.clipboard) return;
    
    try {
        const text = await navigator.clipboard.readText();
        try {
            const data = JSON.parse(text);
            if (data.version && (data.node || data.nodes)) {
                this.clipboard = data;
                return true;
            }
        } catch {
            return false;
        }
    } catch (err) {
        console.error('Clipboard check failed:', err);
        return false;
    }
    return false;
}
checkParentNodeState(parentNode) {
    const hasChildren = parentNode.children.length > 0;
    const element = document.querySelector(`[data-node-id="${parentNode.id}"] .node-content`);
    
    if (element) {
        if (hasChildren) {
            element.classList.remove('no-children');
        } else {
            element.classList.add('no-children');
        }
    }
    
    // Рекурсивно проверяем всех родителей вверх по дереву
    const grandParent = this.findParent(this.treeData, parentNode.id);
    if (grandParent) {
        this.checkParentNodeState(grandParent);
    }
}
serializeNode(node) {
    // ⭐ ИЗМЕНЕНИЕ: Получаем кластер узла
    const cluster = this.clusters.get(node.id) || null;
    const serialized = {
        id: node.id,
        // ⭐ ИЗМЕНЕНИЕ: Сохраняем кластер в копируемые данные
        cluster: cluster,
        content: {
            text: node.content.text,
            img: node.content.img,
            hideIcon: node.content.hideIcon || false,
            isTextOnly: node.content.isTextOnly || false,
            subBlocks: [...(node.content.subBlocks || [])],
            isHorizontal: node.content.isHorizontal || false,
            metricBlocks: node.content.metricBlocks ? [...node.content.metricBlocks] : [],
            isAuthority: node.content.isAuthority || false,
            absent269: node.content.absent269 || false,
            isPower269: node.content.isPower269 || false,
            isOKR: node.content.isOKR || false,
            isSubordinate: node.content.isSubordinate || false,
            isForAll: node.content.isForAll || false,
            isIndicator: node.content.isIndicator || false,
            indicators: node.content.isIndicator ? {...node.content.indicators} : null,
            files: [...(node.content.files || [])],
position: node.content.position || null 
        },
        children: [],
        isExpanded: node.isExpanded
    };

    // Очищаем ссылки на файлы при копировании
    serialized.content.files = [];

    return serialized;
}
serializeNodeWithChildren(node) {
    // ⭐ ИЗМЕНЕНИЕ: Получаем кластер узла
    const cluster = this.clusters.get(node.id) || null;
    const serialized = {
        id: node.id,
        // ⭐ ИЗМЕНЕНИЕ: Сохраняем кластер в копируемые данные
        cluster: cluster,
        content: {
            text: node.content.text,
            img: node.content.img,
            hideIcon: node.content.hideIcon || false,
            isTextOnly: node.content.isTextOnly || false,
            subBlocks: [...(node.content.subBlocks || [])],
            isHorizontal: node.content.isHorizontal || false,
            metricBlocks: node.content.metricBlocks ? [...node.content.metricBlocks] : [],
            isAuthority: node.content.isAuthority || false,
            absent269: node.content.absent269 || false,
            isPower269: node.content.isPower269 || false,
            isOKR: node.content.isOKR || false,
            isSubordinate: node.content.isSubordinate || false,
            isForAll: node.content.isForAll || false,
            isIndicator: node.content.isIndicator || false,
            indicators: node.content.isIndicator ? {...node.content.indicators} : null,
            files: [...(node.content.files || [])]
        },
        children: node.children.map(child => this.serializeNodeWithChildren(child)), // Рекурсивно сериализуем детей
        isExpanded: node.isExpanded
    };

    // Очищаем ссылки на файлы при копировании
    serialized.content.files = [];

    return serialized;
}
// Восстановление узла из сериализованных данных
restoreNode(nodeData) {
    return {
        id: nodeData.id,
        content: {
            text: nodeData.content?.text || 'Новый узел',
            img: nodeData.content?.img || null,
            subBlocks: nodeData.content?.subBlocks || [],
            hideIcon: nodeData.content?.hideIcon || false,
            isTextOnly: nodeData.content?.isTextOnly || false,
            metricBlocks: nodeData.content?.metricBlocks || [],
            isHorizontal: nodeData.content?.isHorizontal || false,
            isOKR: nodeData.content?.isOKR || false,
            isAuthority: nodeData.content?.isAuthority || false,
            absent269: nodeData.content?.absent269 || false,
            isPower269: nodeData.content?.isPower269 || false,
            isSubordinate: nodeData.content?.isSubordinate || false,
            isForAll: nodeData.content?.isForAll || false,
            isIndicator: nodeData.content?.isIndicator || false,
            indicators: nodeData.content?.isIndicator ? {...nodeData.content.indicators} : null,
            files: nodeData.content?.files || [],
position: nodeData.content?.position || null 
        },
        children: [],
        isExpanded: nodeData.isExpanded !== undefined ? nodeData.isExpanded : true
    };
}
restoreNodeWithChildren(nodeData) {
    const node = {
        id: this.generateId(), // Генерируем новый ID для вставки
        content: {
            text: nodeData.content?.text || 'Новый узел',
            img: nodeData.content?.img || null,
            subBlocks: nodeData.content?.subBlocks || [],
            hideIcon: nodeData.content?.hideIcon || false,
            isTextOnly: nodeData.content?.isTextOnly || false,
            metricBlocks: nodeData.content?.metricBlocks || [],
            isHorizontal: nodeData.content?.isHorizontal || false,
            isOKR: nodeData.content?.isOKR || false,
            isAuthority: nodeData.content?.isAuthority || false,
            absent269: nodeData.content?.absent269 || false,
            isPower269: nodeData.content?.isPower269 || false,
            isSubordinate: nodeData.content?.isSubordinate || false,
            isForAll: nodeData.content?.isForAll || false,
            isIndicator: nodeData.content?.isIndicator || false,
            indicators: nodeData.content?.isIndicator ? {...node.content.indicators} : null,
            files: nodeData.content?.files || [],
position: nodeData.content?.position || null 
        },
        children: (nodeData.children || []).map(child => this.restoreNodeWithChildren(child)), // Рекурсивно восстанавливаем детей
        isExpanded: nodeData.isExpanded !== undefined ? nodeData.isExpanded : true
    };

    // ⭐ ИЗМЕНЕНИЕ: Восстанавливаем кластер, если он был
    if (nodeData.cluster) {
        this.clusters.set(node.id, nodeData.cluster);
        // Также убедимся, что этот кластер есть в списке доступных
        if (!this.availableClusters.has(nodeData.cluster)) {
            this.availableClusters.add(nodeData.cluster);
        }
    }

    return node;
}
centerOnElement(element) {
    try {
        const treeContainer = this.elements.treeContainer;
        
        // Временно убираем все transitions чтобы избежать конфликтов
        treeContainer.style.transition = '';
        
        // Получаем размеры viewport
        const viewportCenterX = window.innerWidth / 2;
        const viewportCenterY = window.innerHeight / 2;
        
        // Получаем позицию элемента относительно страницы
        const elementRect = element.getBoundingClientRect();
        
        // Получаем текущий transform контейнера
        const currentTransform = treeContainer.style.transform;
        const currentTranslateMatch = currentTransform.match(/translate\(([^,]+),\s*([^)]+)\)/);
        const currentTranslateX = currentTranslateMatch ? parseFloat(currentTranslateMatch[1]) : 0;
        const currentTranslateY = currentTranslateMatch ? parseFloat(currentTranslateMatch[2]) : 0;
        
        // Вычисляем центр элемента с учетом текущего transform
        const elementCenterX = elementRect.left + elementRect.width / 2;
        const elementCenterY = elementRect.top + elementRect.height / 2;
        
        // Вычисляем необходимое смещение для центрирования
        const deltaX = viewportCenterX - elementCenterX;
        const deltaY = viewportCenterY - elementCenterY;
        
        // Новые координаты с учетом текущего положения
        const newTranslateX = currentTranslateX + deltaX;
        const newTranslateY = currentTranslateY + deltaY;
        
        // Обновляем переменные pan/zoom системы ПЕРЕД применением трансформации
        if (window.panZoomVars) {
            window.panZoomVars.translateX = newTranslateX;
            window.panZoomVars.translateY = newTranslateY;
            window.panZoomVars.scale = this.scale;
        }
        
        // Применяем трансформацию с плавной анимацией
        treeContainer.style.transition = 'transform 0.3s ease-out';
        treeContainer.style.transform = `translate(${newTranslateX}px, ${newTranslateY}px) scale(${this.scale})`;
        
        // Убираем transition после анимации
        setTimeout(() => {
            treeContainer.style.transition = '';
        }, 300);
        
        // Подсвечиваем элемент
        element.classList.add('highlight-parent');
        setTimeout(() => {
            element.classList.remove('highlight-parent');
        }, 1500);
        
    } catch (error) {
        console.error('Ошибка при центрировании:', error);
        // Fallback к стандартному scrollIntoView
        element.scrollIntoView({
            behavior: 'smooth',
            block: 'center',
            inline: 'center'
        });
    }
}
changeZoom(delta) {
    const treeContainer = this.elements.treeContainer;
    this.scale = this.scale || 0.7; // Изменено с 1 на 0.7
    
    // Остальной код остается без изменений...
    this.scrollState = {
        scrollLeft: treeContainer.scrollLeft,
        scrollTop: treeContainer.scrollTop
    };

    const viewportCenterX = window.innerWidth / 2;
    const viewportCenterY = window.innerHeight / 2;
    
    const transform = treeContainer.style.transform;
    const translateMatch = transform.match(/translate\(([^,]+),\s*([^)]+)\)/);
    const currentTranslateX = translateMatch ? parseFloat(translateMatch[1]) : 0;
    const currentTranslateY = translateMatch ? parseFloat(translateMatch[2]) : 0;
    
    const oldScale = this.scale;
    this.scale = Math.max(0.5, Math.min(2, this.scale + delta));
    
    if (oldScale === this.scale) return;
    
    const scaleFactor = this.scale / oldScale;
    const newTranslateX = viewportCenterX + (currentTranslateX - viewportCenterX) * scaleFactor;
    const newTranslateY = viewportCenterY + (currentTranslateY - viewportCenterY) * scaleFactor;
    
    if (window.panZoomVars) {
        window.panZoomVars.scale = this.scale;
        window.panZoomVars.translateX = newTranslateX;
        window.panZoomVars.translateY = newTranslateY;
    }
    
    treeContainer.style.transform = `translate(${newTranslateX}px, ${newTranslateY}px) scale(${this.scale})`;
    
    requestAnimationFrame(() => {
        treeContainer.scrollLeft = this.scrollState.scrollLeft;
        treeContainer.scrollTop = this.scrollState.scrollTop;
    });
}
addSuperordinateAbove() {
    if (!this.selectedNode) {
        alert('Выберите узел!');
        return;
    }

    const selectedNode = this.selectedNode.node;
    const parent = this.findParent(this.treeData, selectedNode.id);

    if (!parent) {
        alert('Нельзя добавить узел выше корневого!');
        return;
    }

    // Создаем новый узел, который станет родителем
    const newNode = this.createNewNode('Новый родительский узел');
    
    // Находим индекс выбранного узла у его родителя
    const index = parent.children.indexOf(selectedNode);
    
    // Заменяем выбранный узел новым узлом
    parent.children[index] = newNode;
    
    // Делаем выбранный узел дочерним для нового узла
    newNode.children.push(selectedNode);

    this.updateTree();
    this.saveData();
    this.showNotification('Добавлен узел на уровень выше');
}
expandAllNodes() {
    const expandRecursive = (node) => {
        node.isExpanded = true;
        node.children.forEach(expandRecursive);
    };
    
    expandRecursive(this.treeData);
    
    // Сохраняем фокус на текущем выбранном узле или корне
    this.focusNodeId = this.selectedNode ? this.selectedNode.node.id : this.treeData.id;
    
    this.updateTree();
    this.saveData();
    this.showNotification('Все узлы развернуты');
}
toggle269Mark() {
this.saveToHistory();
    if (!this.selectedNode) {
        alert('Выберите узел для отметки!');
        return;
    }
    const node = this.selectedNode.node;
    node.content.absent269 = !node.content.absent269;
    
    // Снимаем другие отметки при установке этой
if (node.content.absent269) {
    node.content.isForAll = false;
    node.content.isPower269 = false;
    node.content.isSubordinate = false;
    node.content.isAuthority = false;
    node.content.isOKR = false; // Добавлено
    node.content.isIndicator = false; // Добавлено
}
    this.updateTree();
    this.saveData();
    
    this.showNotification(
        node.content.absent269 
            ? 'Узел отмечен как отсутствующий в 269-П'
            : 'Снята отметка об отсутствии в 269-П'
    );
}
toggleForAll() {
this.saveToHistory();
    if (!this.selectedNode) {
        alert('Выберите узел!');
        return;
    }
    const node = this.selectedNode.node;
    node.content.isForAll = !node.content.isForAll;
    
    // Снимаем другие отметки при установке этой
    if (node.content.isForAll) {
    node.content.absent269 = false;
    node.content.isPower269 = false;
    node.content.isSubordinate = false;
    node.content.isAuthority = false;
    node.content.isOKR = false; // Добавлено
    node.content.isIndicator = false; // Добавлено
}
    
    this.updateTree();
    this.saveData();
    this.showNotification(
        node.content.isForAll 
            ? 'Узел помечен как "Для всех сотрудников"'
            : 'Снята пометка "Для всех сотрудников"'
    );
}
toggleSubordinateMark() {
this.saveToHistory();
    if (!this.selectedNode) {
        alert('Выберите узел!');
        return;
    }
    const node = this.selectedNode.node;
    node.content.isSubordinate = !node.content.isSubordinate;
    
    // Устанавливаем/удаляем masterId при изменении статуса
    if (node.content.isSubordinate) {
        const parent = this.findParent(this.treeData, node.id);
        if (parent) {
            node.content.masterId = parent.id;
        }
    } else {
        node.content.masterId = null;
    }
    
    // Снимаем другие отметки при установке этой
if (node.content.isSubordinate) {
    node.content.absent269 = false;
    node.content.isPower269 = false;
    node.content.isForAll = false;
    node.content.isAuthority = false;
    node.content.isOKR = false; // Добавлено
    node.content.isIndicator = false; // Добавлено
}
    
    this.updateTree();
    this.saveData();
    this.showNotification(
        node.content.isSubordinate 
            ? 'Узел помечен как "Должностные регламенты"'
            : 'Снята пометка "Должностные регламенты"'
    );
}
toggleOKRMark() {
this.saveToHistory();
    if (!this.selectedNode) {
        alert('Выберите узел!');
        return;
    }
    const node = this.selectedNode.node;
    node.content.isOKR = !node.content.isOKR;
    
    // Снимаем другие отметки при установке этой
    if (node.content.isOKR) {
        node.content.absent269 = false;
        node.content.isPower269 = false;
        node.content.isForAll = false;
        node.content.isSubordinate = false;
        node.content.isAuthority = false;
        node.content.isIndicator = false;
    }
    
    this.updateTree();
    this.saveData();
    
    this.showNotification(
        node.content.isOKR 
            ? 'Узел помечен как "OKR (Цели и ключевые результаты)"'
            : 'Снята пометка "OKR (Цели и ключевые результаты)"'
    );
}
toggleIndicatorMark() {
this.saveToHistory();
    if (!this.selectedNode) {
        alert('Выберите узел!');
        return;
    }
    const node = this.selectedNode.node;
    node.content.isIndicator = !node.content.isIndicator;
    
    if (node.content.isIndicator) {
        // Инициализация структуры данных
        node.content.indicators = {
            years: [2022, 2023, 2024, 2025, 2026, 2027, 2028, 2029, 2030],
           stages: ["Выделено. руб", "Этап 2", "Этап 3", "Вес. значение"],
values: Array(9).fill().map(() => Array(4).fill(0)),
            metrics: [] // Добавляем массив для метрик
        };
        
        // Снимаем другие отметки
 node.content.absent269 = false;
    node.content.isPower269 = false;
    node.content.isForAll = false;
    node.content.isSubordinate = false;
    node.content.isAuthority = false;
    node.content.isOKR = false; // Добавлено
    }
    
    this.updateTree();
    this.saveData();
    this.showNotification(
        node.content.isIndicator 
            ? 'Узел помечен как "Государственная программа"'
            : 'Снята пометка "Государственная программа"'
    );
}

toggleAuthorityMark() {
this.saveToHistory();
    if (!this.selectedNode) {
        alert('Выберите узел!');
        return;
    }
    const node = this.selectedNode.node;
    node.content.isAuthority = !node.content.isAuthority;
    
    // Снимаем другие отметки при установке этой
if (node.content.isAuthority) {
    node.content.absent269 = false;
    node.content.isPower269 = false;
    node.content.isForAll = false;
    node.content.isSubordinate = false;
    node.content.isOKR = false; // Добавлено
    node.content.isIndicator = false; // Добавлено
}
    
    this.updateTree();
    this.saveData();
    this.showNotification(
        node.content.isAuthority 
            ? 'Узел помечен как "Идентичное полномочие"'
            : 'Снята пометка "Идентичное полномочие"'
    );
}
collapseParentNode() {
    try {
        if (!this.selectedNode) {
            throw new Error('Выберите узел!');
        }
        
        // 1. Находим родительский узел
        const parentNode = this.findParent(this.treeData, this.selectedNode.node.id);
        if (!parentNode) {
            throw new Error('Это корневой узел, у него нет родителя!');
        }
        
        // 2. Сохраняем текущее состояние прокрутки и трансформации
        const treeContainer = this.elements.treeContainer;
        const currentTransform = treeContainer.style.transform;
        const currentScroll = {
            left: treeContainer.scrollLeft,
            top: treeContainer.scrollTop
        };
        
        // 3. Получаем позицию родительского узла ДО сворачивания
        const parentElement = document.querySelector(`[data-node-id="${parentNode.id}"]`);
        if (!parentElement) return;
        
        const parentRect = parentElement.getBoundingClientRect();
        const parentCenter = {
            x: parentRect.left + parentRect.width / 2,
            y: parentRect.top + parentRect.height / 2
        };
        
        // 4. Сворачиваем родительский узел и все его дочерние узлы
        const collapseAllChildren = (node) => {
            node.isExpanded = false;
            node.children.forEach(child => collapseAllChildren(child));
        };
        
        collapseAllChildren(parentNode);
        
        // 5. Устанавливаем фокус на родительский узел
        this.focusNodeId = parentNode.id;
        
        // 6. Обновляем дерево с сохранением позиции
        this.skipScrollRestore = true;
        this.updateTree();
        this.skipScrollRestore = false;
        
        // 7. Восстанавливаем позицию после обновления
        requestAnimationFrame(() => {
            // Применяем сохраненную трансформацию
            treeContainer.style.transform = currentTransform;
            
            // Вычисляем новую позицию родительского узла
            const newParentElement = document.querySelector(`[data-node-id="${parentNode.id}"]`);
            if (!newParentElement) return;
            
            const newParentRect = newParentElement.getBoundingClientRect();
            const newParentCenter = {
                x: newParentRect.left + newParentRect.width / 2,
                y: newParentRect.top + newParentRect.height / 2
            };
            
            // Корректируем прокрутку для компенсации изменения размера
            const deltaX = parentCenter.x - newParentCenter.x;
            const deltaY = parentCenter.y - newParentCenter.y;
            
            treeContainer.scrollLeft = currentScroll.left + deltaX;
            treeContainer.scrollTop = currentScroll.top + deltaY;
            
            // Подсвечиваем родительский элемент
            newParentElement.classList.add('highlight-parent');
            setTimeout(() => {
                newParentElement.classList.remove('highlight-parent');
            }, 1000);
        });
        
        this.saveData();
        this.showNotification('Родительский узел и все его внутренние узлы свернуты');
    } catch (error) {
        alert(error.message);
    }
}
saveScrollPosition() {
    const treeContainer = this.elements.treeContainer;
    if (treeContainer) {
        this.scrollPosition = {
            scrollLeft: treeContainer.scrollLeft,
            scrollTop: treeContainer.scrollTop,
            transform: treeContainer.style.transform || 'translate(0px, 0px) scale(1)'
        };
    }
}
restoreScrollPosition() {
    if (!this.scrollPosition) return;
    
    const treeContainer = this.elements.treeContainer;
    if (!treeContainer) return;
    
    // Используем requestAnimationFrame для плавного восстановления
    requestAnimationFrame(() => {
        treeContainer.scrollLeft = this.scrollPosition.scrollLeft;
        treeContainer.scrollTop = this.scrollPosition.scrollTop;
        
        if (this.scrollPosition.transform) {
            treeContainer.style.transform = this.scrollPosition.transform;
        }
    });
}

async exportToJSON() {
  try {
    const imagesToSave = {};
    for(const [key, value] of Object.entries(this.imagesData)) {
      if(value.startsWith('data:image')) {
        imagesToSave[key] = value;
      }
    }
    
    const data = {
      version: '2.7',
      tree: this.serializeTree(this.treeData),
      images: imagesToSave,
      filesData: this.filesData,
      clusters: Array.from(this.clusters.entries()),
      availableClusters: Array.from(this.availableClusters),
      settings: {
        nodeCounter: this.nodeCounter,
        darkMode: this.darkMode,
        activeCluster: this.activeCluster
      },
      timestamp: Date.now()
    };
    
    const jsonString = JSON.stringify(data);
    
    // УБИРАЕМ LZString - используем обычный JSON
    const finalData = jsonString;
    
    const blob = new Blob([finalData], { type: 'application/json' });
    const link = document.createElement('a');
    link.href = URL.createObjectURL(blob);
    link.download = `tree-project_${Date.now()}.json`;
    link.click();
    
    this.showNotification('Проект успешно экспортирован в JSON');
  } catch(error) {
    console.error('Ошибка экспорта:', error);
    this.showNotification(`Ошибка экспорта: ${error.message}`);
  }
}

async importFromJSON() {
  return new Promise((resolve) => {
    const input = document.createElement('input');
    input.type = 'file';
    input.accept = '.json';
    
    input.onchange = async (e) => {
      const file = e.target.files[0];
      if (!file) {
        resolve(false);
        return;
      }
      
      const reader = new FileReader();
      
      reader.onload = async (e) => {
        try {
          // Теперь читаем как обычный текст (без сжатия)
          const jsonString = e.target.result;
          
          // Отладка
          console.log('Длина jsonString:', jsonString?.length);
          console.log('Первые 200 символов:', jsonString?.substring(0, 200));
          
          const data = JSON.parse(jsonString);
          
          if (!data.version || data.version < '2.0') {
            throw new Error('Устаревший формат файла');
          }
          
          // Валидация и загрузка изображений
          const validatedImages = {};
          for(const [key, value] of Object.entries(data.images || {})) {
            if(typeof value === 'string' && value.startsWith('data:image')) {
              validatedImages[key] = value;
            }
          }
          
          // Загрузка основных данных
          this.imagesData = validatedImages;
          this.nodeCounter = data.settings.nodeCounter || 1;
          this.treeData = this.restoreTree(data.tree);
          this.filesData = data.filesData || {};
          
          // Загрузка данных о кластерах (для версий 2.7+)
          if (data.version >= '2.7') {
            this.clusters = new Map(data.clusters || []);
            this.availableClusters = new Set(data.availableClusters || []);
            this.activeCluster = data.settings?.activeCluster || null;
          } else {
            // Для старых версий инициализируем пустые кластеры
            this.clusters = new Map();
            this.availableClusters = new Set();
            this.activeCluster = null;
          }
          
          // Обновляем интерфейс
          this.updateClusterSelect();
          this.saveToHistory(true, true);
          this.updateTree();
          this.saveData();
          
          this.showNotification('Проект успешно импортирован!');
          resolve(true);
        } catch(error) {
          console.error('Ошибка импорта:', error);
          this.showNotification(`Ошибка импорта: ${error.message}`);
          resolve(false);
        }
      };
      
      // Используем readAsText для обычного JSON
      reader.readAsText(file);
    };
    
    input.click();
  });
}
  showNotification(text) {
    const notification = document.createElement('div');
    notification.className = 'notification';
    notification.textContent = text;
    document.body.appendChild(notification);
    setTimeout(() => notification.remove(), 3000);
  }

  addSubBlock(node) {
    node.content.subBlocks = node.content.subBlocks || [];
    node.content.subBlocks.push('Новый подблок');
    this.updateTree();
    this.saveData();
  }
editSubBlock(node, index) {
    let currentText = node.content.subBlocks[index];
    
    const newText = prompt('Редактировать подблок:', currentText);
    if(newText !== null) {
        let processedText = newText.trim();
        
        // Проверяем email (более строгая проверка)
        if (this.isValidEmail(processedText)) {
            processedText = processedText.toLowerCase();
        } 
        // Проверяем URL (только если строка явно похожа на URL)
        else if (this.isValidUrl(processedText)) {
            processedText = processedText.startsWith('http') ? processedText : `https://${processedText}`;
        }
        
        node.content.subBlocks[index] = processedText;
        this.updateTree();
        this.saveData();
    }
}
  removeSubBlock(node, index) {
    if(confirm('Удалить этот подблок?')) {
      node.content.subBlocks.splice(index, 1);
      this.updateTree();
      this.saveData();
    }
  }

  handleDragOver(e) {
    e.preventDefault();
    if(e.dataTransfer.types.includes('Files')) {
      this.elements.dropZone.classList.add('active');
    }
  }

  handleFileDrop(e) {
    e.preventDefault();
    this.elements.dropZone.classList.remove('active');
    const files = e.dataTransfer.files;
    if(files.length === 0) return;
    const file = files[0];
    if(file.name.endsWith('.html')) {
      this.handleProjectImport(file);
    } else if(file.type.startsWith('image/') && this.selectedNode) {
      this.handleImageUpload(file, this.selectedNode.node);
    }
  }
async handleFileUpload(file, node) {
    if (!['application/vnd.openxmlformats-officedocument.spreadsheetml.sheet',
            'application/vnd.ms-excel',
            'application/msword',
            'application/vnd.openxmlformats-officedocument.wordprocessingml.document'].includes(file.type)) {
        alert('Пожалуйста, выберите XLSX или Word файл');
        return;
    }

    try {
        const fileId = 'file_' + Date.now() + '_' + Math.random().toString(36).substr(2, 9);
        
        // Читаем файл как ArrayBuffer
        const arrayBuffer = await new Promise((resolve, reject) => {
            const reader = new FileReader();
            reader.onload = () => resolve(reader.result);
            reader.onerror = reject;
            reader.readAsArrayBuffer(file);
        });

        // Сохраняем метаданные в памяти, а файл в IndexedDB
        this.filesData[fileId] = {
            name: file.name,
            type: file.type,
            size: file.size,
            lastModified: file.lastModified
        };

        // Сохраняем файл в IndexedDB
        await this.db.saveFile(fileId, {
            name: file.name,
            type: file.type,
            data: arrayBuffer,
            size: file.size,
            lastModified: file.lastModified
        });

        // Добавляем ссылку на файл в узел
        node.content.files = node.content.files || [];
        node.content.files.push(fileId);

        this.updateTree();
        this.saveData();
        this.showNotification(`Файл "${file.name}" успешно загружен`);

    } catch(error) {
        console.error('Error uploading file:', error);
        alert('Ошибка загрузки файла: ' + error.message);
    }
}

async downloadFile(fileId) {
    try {
        const fileMeta = this.filesData[fileId];
        if (!fileMeta) throw new Error('File not found');
        
        // Получаем файл из IndexedDB
        const fileData = await this.db.getFile(fileId);
        if (!fileData) throw new Error('File data not found');
        
        // Создаем Blob из ArrayBuffer
        const blob = new Blob([fileData.data], { type: fileData.type });
        const url = URL.createObjectURL(blob);
        
        const link = document.createElement('a');
        link.href = url;
        link.download = fileData.name;
        link.click();
        
        // Освобождаем память
        setTimeout(() => URL.revokeObjectURL(url), 100);
        
    } catch(error) {
        console.error('Download error:', error);
        alert('Ошибка загрузки файла: ' + error.message);
    }
}

async removeFile(node, fileId) {
    if(confirm('Удалить этот файл?')) {
        try {
            // Удаляем из узла
            node.content.files = node.content.files.filter(id => id !== fileId);
            
            // Удаляем метаданные
            delete this.filesData[fileId];
            
            // Удаляем файл из IndexedDB
            await this.db.deleteFile(fileId);
            
            this.updateTree();
            this.saveData();
            this.showNotification('Файл удален');
            
        } catch(error) {
            console.error('Remove file error:', error);
            alert('Ошибка удаления файла: ' + error.message);
        }
    }
}
  async handleProjectImport(file) {
    try {
      const text = await file.text();
      const parser = new DOMParser();
      const doc = parser.parseFromString(text, 'text/html');
      const scriptContent = doc.querySelector('script:last-child').innerHTML;
      const compressedData = scriptContent.match(/compressedData\s*=\s*"([^"]+)"/)[1];
      const jsonString = LZString.decompressFromBase64(compressedData);
      const data = JSON.parse(jsonString);
      this.importData(data);
      alert('Проект успешно загружен!');
    } catch(error) {
      console.error('Ошибка импорта:', error);
      alert('Ошибка загрузки файла проекта');
    }
  }

  importData(data) {
  try {
    if (data.version && data.version !== '1.0') {
      const userConfirmed = confirm(
        'Этот файл создан в другой версии приложения.\n' +
        'Возможны ошибки в работе. Продолжить импорт?'
      );
      if (!userConfirmed) {
        throw new Error('Импорт отменен пользователем');
      }
    }
    this.imagesData = data.images || {};
    this.nodeCounter = data.counter || 1;
    this.treeData = this.restoreTree(data.tree);
       if (this.treeData) {
            const walkTree = (node) => {
                // Если hideIcon не определен, устанавливаем false
                if (node.content.hideIcon === undefined) {
                    node.content.hideIcon = false;
                }
                node.children.forEach(walkTree);
            };
            walkTree(this.treeData);
        }
    this.filesData = data.filesData || {}; // Import filesData
    this.darkMode = data.theme === 'dark';
    document.documentElement.classList.toggle('dark', this.darkMode);
    this.updateTree();
this.saveToHistory(true, true);
    this.treeData.isExpanded = true;
    this.saveData();
    this.setupEventListeners();
this.setupDragAndDrop();
  } catch(error) {
    console.error('Ошибка импорта:', error);
    alert('Ошибка загрузки: ' + error.message);
    throw new Error('Некорректный формат файла');
  }
}
uploadFile() { 
    if(!this.selectedNode) return;

    const input = document.createElement('input');
    input.type = 'file';
    input.accept = '.xlsx,.xls,.doc,.docx';
    input.onchange = (e) => {
        if(e.target.files[0]) this.handleFileUpload(e.target.files[0], this.selectedNode.node);
    };
    input.click();
}
uploadFileForMetric(node, blockIndex, quarterIndex) {
    const input = document.createElement('input');
    input.type = 'file';
    input.accept = '.xlsx,.xls,.doc,.docx,.pdf,.txt';
    input.onchange = async (e) => {
        if (e.target.files[0]) {
            try {
                const fileId = 'file_' + Date.now() + '_' + Math.random().toString(36).substr(2, 9);
                const file = e.target.files[0];
                
                // Сохраняем файл
                this.filesData[fileId] = {
                    name: file.name,
                    type: file.type,
                    size: file.size,
                    lastModified: file.lastModified
                };
                
                // Добавляем ссылку в метрику
                node.content.metricBlocks[blockIndex].quarters[quarterIndex].files.push(fileId);
                
                this.updateTree();
                this.saveData();
                this.showNotification(`Файл "${file.name}" прикреплен к метрике`);
            } catch (error) {
                console.error('Ошибка загрузки файла:', error);
                alert('Ошибка загрузки файла');
            }
        }
    };
    input.click();
}
downloadFile(fileId) {
    const file = this.filesData[fileId];
    if (!file) return;

    const link = document.createElement('a');
    link.href = file.data;
    link.download = file.name;
    link.click();
}

removeFile(node, fileId) {
    if(confirm('Удалить этот файл?')) {
        node.content.files = node.content.files.filter(id => id !== fileId);
        delete this.filesData[fileId];
        this.updateTree();
        this.saveData();
    }
}
setupDragAndDrop() {
    // ✨ Новая строка: Внедряем стили при инициализации
    this.injectDragDropStyles();

    // Создаем индикатор места вставки
    this.dropIndicator = document.createElement('div');
    this.dropIndicator.className = 'drop-indicator';
    this.dropIndicator.style.display = 'none';
    document.body.appendChild(this.dropIndicator);

    // Обработчики для всего документа
    document.addEventListener('dragover', this.handleDragOver.bind(this));
    document.addEventListener('drop', this.handleDrop.bind(this));
    document.addEventListener('dragend', this.handleDragEnd.bind(this));
}
injectDragDropStyles() {
    // Проверяем, не были ли стили уже добавлены, чтобы избежать дублирования
    if (document.getElementById('drag-drop-styles')) {
        return;
    }

    const style = document.createElement('style');
    style.id = 'drag-drop-styles';
    // Использование textContent или innerHTML для добавления CSS-правил — это стандартный способ. [3, 4]
    style.textContent = `
        .node-content.drop-target-child {
            box-shadow: 0 0 0 3px var(--accent-color) !important;
            border-color: var(--accent-color) !important;
            transition: box-shadow 0.2s ease, border-color 0.2s ease;
        }
    `;
    document.head.appendChild(style);
}

handleNodeDragStart(e, node, element) {
    // Предотвращаем перетаскивание корневого узла
    if (node === this.treeData) {
        e.preventDefault();
        return;
    }

    this.draggedNode = node;
    this.draggedElement = element;
    element.classList.add('dragging');
    document.body.style.cursor = 'grabbing';
    e.dataTransfer.effectAllowed = 'move';
    e.dataTransfer.setData('text/plain', node.id);
}
handleNodeDragOver(e, targetNode, targetElement) {
    e.preventDefault();
    if (!this.draggedNode || this.draggedNode === targetNode) return;

    // Проверяем, не пытаемся ли мы перетащить узел внутрь его же потомка
    if (this.isDescendant(targetNode, this.draggedNode.id)) {
        this.hideDropIndicator();
        e.dataTransfer.dropEffect = 'none'; // Показываем, что сюда бросать нельзя
        return;
    }

    e.dataTransfer.dropEffect = 'move';
    this.showDropIndicator(e, targetNode, targetElement);
}
handleNodeDrop(e, targetNode, targetElement) {
    e.preventDefault();
    e.stopPropagation();

    if (!this.draggedNode || this.draggedNode === targetNode || this.isDescendant(targetNode, this.draggedNode.id)) {
        this.hideDropIndicator();
        return;
    }

    this.saveToHistory(); // Сохраняем состояние для возможности отмены
    const insertPosition = this.getInsertPosition(e, targetNode, targetElement);
    this.moveNode(this.draggedNode, targetNode, insertPosition);
    this.hideDropIndicator();
}

removeNodeFromSubtree(startNodeOrArray, nodeId) {
    const removeRecursive = (current, parent) => {
        if (current.children) {
            // Фильтруем дочерние элементы, удаляя нужный
            const initialLength = current.children.length;
            current.children = current.children.filter(child => child.id !== nodeId);

            // Если узел был найден и удален, прекращаем поиск
            if (current.children.length < initialLength) {
                return true;
            }

            // Иначе, продолжаем поиск вглубь
            for (const child of current.children) {
                if (removeRecursive(child, current)) {
                    return true;
                }
            }
        }
        return false;
    };

    if (Array.isArray(startNodeOrArray)) {
        this.liquidationDialogState.restructuredSubtree = startNodeOrArray.filter(rootNode => {
            if (rootNode.id === nodeId) return false; // Удаляем из корня
            removeRecursive(rootNode, null); // Ищем в дочерних
            return true;
        });
    } else if (startNodeOrArray) {
        if (startNodeOrArray.id === nodeId) {
            this.liquidationDialogState.restructuredSubtree = null; // Удаляем единственный корневой узел
        } else {
            removeRecursive(startNodeOrArray, null);
        }
    }
}
showDropIndicator(e, targetNode, targetElement) {
    const rect = targetElement.getBoundingClientRect();
    const insertPosition = this.getInsertPosition(e, targetNode, targetElement);

    // Сначала убираем подсветку со всех остальных узлов
    const currentlyHighlighted = document.querySelector('.node-content.drop-target-child');
    if (currentlyHighlighted) {
        currentlyHighlighted.classList.remove('drop-target-child');
    }

    this.dropIndicator.style.display = 'block';
    const targetContent = targetElement.querySelector('.node-content');

    if (insertPosition === 'child') {
        targetContent.classList.add('drop-target-child');
        this.dropIndicator.style.display = 'none'; // Скрываем линию, так как есть рамка
    } else {
        targetContent.classList.remove('drop-target-child'); // Убираем рамку, если она была

        const parentOfTarget = this.findParent(this.treeData, targetNode.id);
        let isHorizontalLayout = false;
        if (parentOfTarget) {
            const parentElement = document.querySelector(`[data-node-id="${parentOfTarget.id}"]`);
            if (parentElement) {
                const childrenContainer = parentElement.querySelector('.children');
                if (childrenContainer) {
                    const style = window.getComputedStyle(childrenContainer);
                    isHorizontalLayout = style.flexDirection === 'row' || style.display === 'grid';
                }
            }
        }

        if (isHorizontalLayout) {
            // Вертикальная линия для горизонтального расположения
            this.dropIndicator.style.width = '3px';
            this.dropIndicator.style.height = rect.height + 'px';
            this.dropIndicator.style.top = rect.top + 'px';
            this.dropIndicator.style.left = (insertPosition === 'before' ? rect.left - 6 : rect.right + 3) + 'px';
        } else {
            // Горизонтальная линия для вертикального расположения
            this.dropIndicator.style.width = rect.width + 'px';
            this.dropIndicator.style.height = '3px';
            this.dropIndicator.style.left = rect.left + 'px';
            this.dropIndicator.style.top = (insertPosition === 'before' ? rect.top - 3 : rect.bottom) + 'px';
        }
    }
}
hideDropIndicator() {
    if (this.dropIndicator) {
        this.dropIndicator.style.display = 'none';
    }
    const highlighted = document.querySelector('.node-content.drop-target-child');
    if (highlighted) {
        highlighted.classList.remove('drop-target-child');
    }
}
getInsertPosition(e, targetNode, targetElement) {
    const rect = targetElement.getBoundingClientRect();

    // Находим контейнер дочерних элементов у *родителя* целевого узла, чтобы понять, как они расположены
    const parentOfTarget = this.findParent(this.treeData, targetNode.id);
    let isHorizontalLayout = false;
    if (parentOfTarget) {
        const parentElement = document.querySelector(`[data-node-id="${parentOfTarget.id}"]`);
        if (parentElement) {
            const childrenContainer = parentElement.querySelector('.children');
            // Проверяем реальный стиль элемента, это надежнее
            if (childrenContainer) {
                 const style = window.getComputedStyle(childrenContainer);
                 isHorizontalLayout = style.flexDirection === 'row' || style.display === 'grid';
            }
        }
    }

    // Зоны для вставки до/после (25% от размера)
    const dropZoneRatio = 0.25;

    if (isHorizontalLayout) {
        // Логика для горизонтального расположения
        const zoneWidth = rect.width * dropZoneRatio;
        if (e.clientX < rect.left + zoneWidth) return 'before';
        if (e.clientX > rect.right - zoneWidth) return 'after';
    } else {
        // Логика для вертикального расположения
        const zoneHeight = rect.height * dropZoneRatio;
        if (e.clientY < rect.top + zoneHeight) return 'before';
        if (e.clientY > rect.bottom - zoneHeight) return 'after';
    }

    // Если курсор в центральной зоне (50%), вставляем как дочерний элемент
    return 'child';
}

moveNode(draggedNode, targetNode, position) {
    this.saveToHistory();
    
    // 1. Находим родителя перетаскиваемого узла
    const oldParent = this.findParent(this.treeData, draggedNode.id);
    
    // 2. Удаляем узел из текущего места
    this.removeNodeFromParent(draggedNode);
    
    // 3. Добавляем в новое место
    if (position === 'child') {
        targetNode.children.push(draggedNode);
        targetNode.isExpanded = true;
    } else {
        const targetParent = this.findParent(this.treeData, targetNode.id);
        if (!targetParent) return;
        
        const targetIndex = targetParent.children.indexOf(targetNode);
        const insertIndex = position === 'before' ? targetIndex : targetIndex + 1;
        targetParent.children.splice(insertIndex, 0, draggedNode);
    }
    
    // 4. Проверяем старый родительский узел
    if (oldParent) {
        this.checkParentNodeState(oldParent);
    }
    
    this.updateTree();
    this.saveData();
    this.showNotification('Узел перемещен');
}
findParent(nodeToSearchIn, targetNodeId) {

    if (!nodeToSearchIn.children) {
        return null;
    }


    for (const child of nodeToSearchIn.children) {
        // Если ID потомка совпадает, значит, текущий узел (nodeToSearchIn) и есть искомый родитель.
        if (child.id === targetNodeId) {
            return nodeToSearchIn;
        }

        const found = this.findParent(child, targetNodeId);


        if (found) {
            return found;
        }
    }

    return null;
}
removeNodeFromParent(node) {
    const parent = this.findParent(this.treeData, node.id);
    if (parent) {
        parent.children = parent.children.filter(child => child !== node);
this.checkParentNodeState(parent); 
    }
}

isDescendant(node, ancestorId) {
    if (node.id === ancestorId) return true;
    
    for (const child of node.children) {
        if (this.isDescendant(child, ancestorId)) {
            return true;
        }
    }
    return false;
}
setupZoom() {
    const treeContainer = this.elements.treeContainer;
    let scale = 0.3;
    const minScale = 0.3;
    const maxScale = 2;
    let isDragging = false;
    let startX, startY;
    let translateX = 0, translateY = 0;
    
    this.scale = scale;
    treeContainer.style.transform = `translate(${translateX}px, ${translateY}px) scale(${scale})`;
    
    treeContainer.addEventListener('wheel', (event) => {
        event.preventDefault();
        
        // Изменяем масштаб ТОЛЬКО если нажат Ctrl И НЕ нажат Shift
        if (event.ctrlKey && !event.shiftKey) {
            const delta = event.deltaY > 0 ? -0.1 : 0.1;
            const newScale = Math.max(minScale, Math.min(maxScale, scale + delta));
            
            const rect = treeContainer.getBoundingClientRect();
            const mouseX = event.clientX - rect.left;
            const mouseY = event.clientY - rect.top;
            
            const contentX = (mouseX - translateX) / scale;
            const contentY = (mouseY - translateY) / scale;
            
            scale = newScale;
            this.scale = scale;
            
            translateX = mouseX - contentX * scale;
            translateY = mouseY - contentY * scale;
    updateTransform();
        } else {

            if (event.shiftKey) {

                translateX -= event.deltaY;
            } else {

                translateY -= event.deltaY;
            }
            updateTransform();
        }
    });

    // Правая кнопка мыши для перемещения
    treeContainer.addEventListener('contextmenu', (event) => {
        event.preventDefault();
    });

    treeContainer.addEventListener('mousedown', (event) => {
        if (event.button === 2) { // Правая кнопка мыши
            isDragging = true;
            startX = event.clientX - translateX;
            startY = event.clientY - translateY;
            treeContainer.style.cursor = 'grabbing';
            document.body.style.userSelect = 'none'; // Отключаем выделение текста при перетаскивании
        }
    });

    document.addEventListener('mousemove', (event) => {
        if (isDragging) {
            translateX = event.clientX - startX;
            translateY = event.clientY - startY;
            updateTransform();
        }
    });

    document.addEventListener('mouseup', (event) => {
        if (event.button === 2) { // Правая кнопка мыши
            isDragging = false;
            treeContainer.style.cursor = 'grab';
            document.body.style.userSelect = ''; // Восстанавливаем выделение текста
        }
    });

    // Установка курсора по умолчанию
    treeContainer.style.cursor = 'grab';

    // Обработка клавиш для навигации
    document.addEventListener('keydown', (e) => {
        const step = 50; // Шаг перемещения при нажатии клавиш
        
        switch(e.key) {
            case 'ArrowUp':
                translateY += step;
                break;
            case 'ArrowDown':
                translateY -= step;
                break;
            case 'ArrowLeft':
                translateX += step;
                break;
            case 'ArrowRight':
                translateX -= step;
                break;
            default:
                return;
        }
        
        updateTransform();
        e.preventDefault();
    });

    function updateTransform() {
        treeContainer.style.transform = `translate(${translateX}px, ${translateY}px) scale(${scale})`;
        if (window.panZoomVars) {
            window.panZoomVars.scale = scale;
            window.panZoomVars.translateX = translateX;
            window.panZoomVars.translateY = translateY;
        }
    }
    // Сброс позиции и масштаба
    this.resetPosition = () => {
        scale = 0.7; // Возвращаем к начальному уменьшенному масштабу
        this.scale = scale;
        translateX = 0;
        translateY = 0;
        updateTransform();
    };
}

async saveData() {
    try {
        // Подготовка данных для сохранения
        const dataToSave = {
            version: '2.8', // ⭐ ВЕРСИЯ ОБНОВЛЕНА
            tree: this.serializeTree(this.treeData),
            images: this.imagesData,
            filesData: this.filesData,
            clusters: Array.from(this.clusters.entries()),
            availableClusters: Array.from(this.availableClusters),
            settings: {
                nodeCounter: this.nodeCounter,
                darkMode: this.darkMode,
                activeCluster: this.activeCluster,
                // ⭐ ИЗМЕНЕНИЕ: Сохраняем состояние фильтра
                uiSettings: this.uiSettings 
            },
            timestamp: Date.now()
        };

        // Сохранение в IndexedDB
        await this.db.saveData('treeData', dataToSave);

        // Визуальная обратная связь
        const saveBtn = this.elements.saveBtn;
        saveBtn.textContent = '✓ Сохранено';
        saveBtn.style.background = 'linear-gradient(145deg, #4CAF50, #66BB6A)';

        setTimeout(() => {
            saveBtn.textContent = '💾 Сохранить';
            saveBtn.style.background = 'linear-gradient(145deg, var(--primary-color), #6B9EBF)';
        }, 2000);

    } catch(error) {
        console.error('Полная ошибка сохранения:', {
            error: error,
            clusters: this.clusters,
            availableClusters: this.availableClusters
        });

        this.showNotification(`Ошибка сохранения: ${error.message}`);
    }
}
  loadFromURL() {
    try {
      const urlParams = new URLSearchParams(window.location.search);
      const dataParam = urlParams.get('data');
      if(dataParam) {
        const jsonString = LZString.decompressFromBase64(dataParam);
        const data = JSON.parse(jsonString);
        this.importData(data);
        return true;
      }
    } catch(error) {
      console.error('Ошибка загрузки из URL:', error);
    }
    return false;
  }
async loadFromLocalStorage() {
    try {
        // Пробуем загрузить из IndexedDB
        const savedData = await this.db.loadData('treeData');

        if (savedData) {
            this.imagesData = savedData.images || {};
            this.nodeCounter = savedData.settings?.nodeCounter || savedData.counter || 1;
            this.treeData = this.restoreTree(savedData.tree) || this.createNewNode('Главный узел');
            this.resetTreeState();

            if (savedData.clusters) {
                this.clusters = new Map(savedData.clusters);
            }
            if (savedData.availableClusters) {
                this.availableClusters = new Set(savedData.availableClusters);
            }

            this.activeCluster = null;

            // ⭐ ИЗМЕНЕНИЕ: Загружаем состояние фильтра
            if (savedData.settings?.uiSettings) {
                this.uiSettings = savedData.settings.uiSettings;
            }

            this.updateClusterSelect();

            if (this.treeData) {
                const walkTree = (node) => {
                    if (node.content.hideIcon === undefined) {
                        node.content.hideIcon = false;
                    }
                    node.children.forEach(walkTree);
                };
                walkTree(this.treeData);
            }

            this.filesData = savedData.filesData || {};

            if (this.treeData) {
                this.treeData.isExpanded = true;
            }

            this.darkMode = savedData.settings?.darkMode || savedData.theme === 'dark';
            document.documentElement.classList.toggle('dark', this.darkMode);

            this.saveToHistory(true, true);
            return;
        }

        // Fallback к localStorage, если в IndexedDB нет данных
        const compressedLocal = localStorage.getItem('treeAppData');
        if (!compressedLocal) {
            this.treeData = this.createNewNode('Главный узел');
            this.treeData.isExpanded = true;
            this.filesData = {};
            this.clusters = new Map();
            this.availableClusters = new Set();
            this.activeCluster = null;

            this.saveToHistory(true, true);
            return;
        }

        let jsonString;
        if (typeof LZString !== 'undefined') {
            jsonString = LZString.decompressFromUTF16(compressedLocal) || compressedLocal;
        } else {
            jsonString = compressedLocal;
        }

        const data = JSON.parse(jsonString);
        this.importData(data);

        await this.saveData();
        this.saveToHistory(true, true);

    } catch(error) {
        console.error('Ошибка загрузки:', error);
        this.treeData = this.createNewNode('Главный узел');
        this.treeData.isExpanded = true;
        this.filesData = {};
        this.clusters = new Map();
        this.availableClusters = new Set();
        this.activeCluster = null;
        this.saveToHistory(true, true);
    }
}
async loadFilesData() {
    try {
        const files = await this.db.getAllFiles();
        files.forEach(file => {
            // Сохраняем только метаданные в памяти
            this.filesData[file.id] = {
                name: file.name,
                type: file.type,
                size: file.size,
                lastModified: file.lastModified
            };
        });
    } catch(error) {
        console.error('Ошибка загрузки файлов:', error);
    }
}
            serializeTree(node) {
                return {
                    id: node.id,
                    needsClusterUpdate: node.needsClusterUpdate || undefined,
                    circularlyReplaced: node.circularlyReplaced || undefined,
                    content: {
                        text: node.content.text,
                        img: node.content.img,
                        hideIcon: node.content.hideIcon || false,
                        isTextOnly: node.content.isTextOnly || false,
                        subBlocks: node.content.subBlocks || [],
                        isHorizontal: node.content.isHorizontal || false,
                        metricBlocks: node.content.metricBlocks || [],
                        isAuthority: node.content.isAuthority || false,
                        absent269: node.content.absent269 || false,
                        isPower269: node.content.isPower269 || false,
                        isOKR: node.content.isOKR || false,
                        isSubordinate: node.content.isSubordinate || false,
                        isForAll: node.content.isForAll || false,
                        isIndicator: node.content.isIndicator || false,
                        isOrganizationalEvent: node.content.isOrganizationalEvent || false,
                        indicators: node.content.isIndicator ? { ...node.content.indicators, result: node.content.indicators.result || '' } : null,
                        files: node.content.files || [],
position: node.content.position || null
                    },
                    children: node.children.map(child => this.serializeTree(child)),
                    isExpanded: node.isExpanded
                };
            }

            restoreTree(data) {
                if (!data) return null;
                const restoreNode = (nodeData) => {
                    const restoredNode = {
                        id: nodeData.id,
                        needsClusterUpdate: nodeData.needsClusterUpdate,
                        circularlyReplaced: nodeData.circularlyReplaced,
                        content: {
                            text: nodeData.content?.text || 'Новый узел',
                            img: nodeData.content?.img || null,
                            subBlocks: nodeData.content?.subBlocks || [],
                            hideIcon: nodeData.content?.hideIcon || false,
                            isTextOnly: nodeData.content?.isTextOnly || false,
                            metricBlocks: nodeData.content?.metricBlocks || [],
                            isHorizontal: nodeData.content?.isHorizontal || false,
                            isOKR: nodeData.content?.isOKR || false,
                            isAuthority: nodeData.content?.isAuthority || false,
                            absent269: nodeData.content?.absent269 || false,
                            isPower269: nodeData.content?.isPower269 || false,
                            isSubordinate: nodeData.content?.isSubordinate || false,
                            isForAll: nodeData.content?.isForAll || false,
                            isIndicator: nodeData.content?.isIndicator || false,
                            isOrganizationalEvent: nodeData.content?.isOrganizationalEvent || false,
                            indicators: nodeData.content?.isIndicator ? {
                                years: nodeData.content.indicators?.years || [2022, 2023, 2024, 2025, 2026, 2027, 2028, 2029, 2030],
                                stages: nodeData.content.indicators?.stages || ["Выделено. руб", "Этап 2", "Этап 3", "Вес. значение"],
                                values: nodeData.content.indicators?.values || Array(9).fill().map(() => Array(4).fill(0)),
                                metrics: nodeData.content.indicators?.metrics || [],
                                result: nodeData.content.indicators?.result || ''} : null,
                            files: nodeData.content?.files || [],
position: nodeData.content?.position || null

                        },
                        children: (nodeData.children || []).map(child => restoreNode(child)),
                        isExpanded: nodeData.isExpanded !== undefined ? nodeData.isExpanded : (nodeData === data)
                    };
                    return restoredNode;
                };
                const root = restoreNode(data);
                if (root.content?.isIndicator && root.content.indicators) {
                    if (root.content.indicators.values && root.content.indicators.values[0]?.length === 3) {
                        root.content.indicators.values = root.content.indicators.values.map(row => [0, ...row]);
                    }
                    if (!root.content.indicators.stages?.includes("Выделено. руб")) {
                        root.content.indicators.stages = ["Выделено. руб", ...(root.content.indicators.stages || ["Этап 2", "Этап 3", "Вес. значение"])];
                    }
                    if (root.content.indicators.result === undefined) {
                        root.content.indicators.result = '';
                    }
                }
                root.isExpanded = true;
                return root;
            }

createNewNode(text, img = null) {
    return {
        id: this.generateId(),
        content: {
            text,
            img,
            subBlocks: [],
            isHorizontal: false,
            absent269: false,
            isSubordinate: false,
            isPower269: false,
            isForAll: false
        },
        children: [],
        isExpanded: true
    };
}


  generateId() {
    return this.nodeCounter++;
  }

  findNode(node, nodeId) {
    if(node.id === nodeId) return node;
    for(const child of node.children) {
      const found = this.findNode(child, nodeId);
      if(found) return found;
    }
    return null;
  }
getNodeDepth(node) {
    let depth = 0;
    let parent = this.findParent(this.treeData, node.id);
    while(parent) {
        depth++;
        parent = this.findParent(this.treeData, parent.id);
    }
    return depth;
}

findParent(root, nodeId, parent = null) {
    if(root.id === nodeId) return parent;
    
    for(const child of root.children) {
        if(child.id === nodeId) return root;
        const found = this.findParent(child, nodeId, root);
        if(found) return found;
    }
    return null;
}
updateTree() {
    const treeContainer = this.elements.treeContainer;
    this.scrollState = {
        scrollLeft: treeContainer.scrollLeft,
        scrollTop: treeContainer.scrollTop,
        transform: treeContainer.style.transform || 'translate(0px, 0px) scale(1)'
    };
    
    // Полностью очищаем контейнер перед обновлением
    treeContainer.innerHTML = '';
    treeContainer.appendChild(this.createNodeElement(this.treeData));
    
    // Восстанавливаем позицию после обновления
    requestAnimationFrame(() => {
        treeContainer.scrollLeft = this.scrollState.scrollLeft;
        treeContainer.scrollTop = this.scrollState.scrollTop;
        treeContainer.style.transform = this.scrollState.transform;
    });
    
    document.querySelectorAll('.node-content.subordinate').forEach(subNode => {
        const childrenContainer = subNode.nextElementSibling;
        if (childrenContainer) {
            childrenContainer.classList.add('compact-children');
        }
    });
}
shouldShowNode(node) {
    // 1. Сначала проверяем кластер (если выбран)
    if (this.activeCluster) {
        const inCluster = this.isInCluster(node) || 
                        this.isParentOfCluster(node) || 
                        this.isChildOfCluster(node);
        
        // Для подчиненных узлов учитываем их masterId
        if (node.content.isSubordinate && node.content.masterId) {
            const masterNode = this.findNode(this.treeData, node.content.masterId);
            const masterInCluster = masterNode && 
                                  (this.isInCluster(masterNode) || 
                                   this.isParentOfCluster(masterNode) || 
                                   this.isChildOfCluster(masterNode));
            
            if (!inCluster && !masterInCluster) return false;
        } else if (!inCluster) {
            return false;
        }
    }
    
    // 2. Затем проверяем поиск (если есть запрос)
    if (this.searchQuery) {
        return this.nodeMatchesSearch(node) || 
               this.isParentOfMatch(node) || 
               this.isDescendantOfMatch(node);
    }
    
    // 3. Если ни кластер, ни поиск не активны - показываем все узлы
    return true;
}
// Новые методы для работы с кластерами
isInCluster(node) {
    return this.clusters.get(node.id) === this.activeCluster;
}

isParentOfCluster(node) {
    if (!this.activeCluster) return false;
    
    // Проверяем всех детей
    for (const child of node.children) {
        if (this.isInCluster(child) || this.isParentOfCluster(child)) {
            return true;
        }
    }
    return false;
}

isChildOfCluster(node) {
    if (!this.activeCluster || node === this.treeData) return false;
    
    const parent = this.findParent(this.treeData, node.id);
    if (!parent) return false;
    
    // Если родитель в кластере, показываем этот узел
    if (this.isInCluster(parent)) {
        return true;
    }
    
    // Для подчиненных узлов проверяем их masterId
    if (node.content.isSubordinate && node.content.masterId) {
        const masterNode = this.findNode(this.treeData, node.content.masterId);
        if (masterNode && this.isInCluster(masterNode)) {
            return true;
        }
    }
    
    // Рекурсивно проверяем выше по дереву
    return this.isChildOfCluster(parent);
}
nodeMatchesSearch(node, query = this.searchQuery, isDeepSearch = false) {
    const currentQuery = query || this.searchQuery;
    if (!currentQuery) return false; // Для основного поиска false, если запроса нет

    const searchTerms = currentQuery.toLowerCase().split(/\s+/).filter(term => term.length > 0);
    if (searchTerms.length === 0) return false;

    let nodeText = (
        node.content.text + ' ' +
        (node.content.subBlocks?.join(' ') || '')
    ).toLowerCase();

    // ✨ Логика для "глубокого" поиска в основном дереве
    if (isDeepSearch) {
        const fileNames = node.content.files?.map(f => this.filesData[f]?.name).join(' ') || '';
        nodeText += ' ' + fileNames.toLowerCase();
        nodeText += ' children:' + node.children.length;
    }

    // Метод `every` гарантирует, что *все* слова из запроса будут найдены в тексте узла. [1, 2]
    return searchTerms.every(term => nodeText.includes(term));
}
isParentOfMatch(node, query = this.searchQuery, isDeepSearch = false) {
    const currentQuery = query || this.searchQuery;
    if (!currentQuery) return false; // Для основного поиска false, если запроса нет

    for (const child of node.children) {
        // Рекурсия — это когда функция вызывает саму себя для решения подзадачи. [3, 4]
        // Здесь мы рекурсивно ищем совпадение в дочерних элементах.
        if (this.nodeMatchesSearch(child, currentQuery, isDeepSearch) || this.isParentOfMatch(child, currentQuery, isDeepSearch)) {
            return true;
        }
    }
    return false;
}
isDescendantOfMatch(node) {
    if (!this.searchQuery || node === this.treeData) return false;
    
    const parent = this.findParent(this.treeData, node.id);
    if (!parent) return false;
    
    if (this.nodeMatchesSearch(parent) && this.shouldShowNode(parent)) {
        return true;
    }
    
    return this.isDescendantOfMatch(parent);
}

containsFuzzyMatch(text, term) {
    if (term.length < 3) return false;
    
    // Ищем частичное совпадение в словах
    const words = text.split(/\s+/);
    return words.some(word => word.includes(term));
}
shouldUseGridLayout(node) {
    const depth = this.getNodeDepth(node);
    const childrenCount = node.children.length;
    
    // 1 уровень - всегда горизонтальное расположение
    if (depth === 0) {
        return false; // horizontal layout
    }
    
    // 2 уровень - горизонтальное, но если >6 узлов - сетка
    if (depth === 1) {
        return childrenCount > 5; // grid if >6 nodes
    }
    
    // 3 уровень - вертикальное расположение
    if (depth === 2) {
        return false; // vertical layout
    }
    
    // 4+ уровни - горизонтальное если >4 узлов, иначе вертикальное
    if (depth >= 3) {
        return childrenCount > 4; // horizontal if >4 nodes, else vertical
    }
    
    return false;
}

createNodeElement(node) {

    if (node === this.treeData) {
        node.isExpanded = true;
    }

    const nodeElement = document.createElement('div');
    
    // Определяем, нужно ли использовать сеточное расположение
    const useGridLayout = this.shouldUseGridLayout(node);
    if (useGridLayout !== node.wasGridLayout) {
    node.wasGridLayout = useGridLayout;
    // Показываем уведомление только при изменении режима
    if (node.children.length > 0) {
        setTimeout(() => this.showLayoutChangeNotification(node, useGridLayout), 100);
    }
}
    nodeElement.className = `node ${node.content.isHorizontal ? 'horizontal' : ''} ${node.isExpanded ? 'expanded' : 'collapsed'} ${useGridLayout ? 'grid-layout' : ''}`;
    
    nodeElement.setAttribute('data-node-id', node.id);
    
    const shouldShow = this.shouldShowNode(node) || this.isParentOfMatch(node);
    if (!shouldShow) {
        nodeElement.style.display = 'none';
        return nodeElement;
    }

    if (this.shouldShowNode(node)) {
        nodeElement.classList.add('search-match');
    }

    const depth = this.getNodeDepth(node);
const isThirdLevel = depth === 2; // 3 уровень (нумерация с 0)
const isSeventhLevel = depth === 5; // 7 уровень (нумерация с 0)
    const levelClass = `level-${(depth % 3) + 1}`;
    const content = document.createElement('div');
    
    if (node.content.isSubordinate) {
        content.classList.add('subordinate');
    }
    
    content.className = `node-content ${node.content.isHorizontal ? 'horizontal' : ''} ${levelClass}`;
if (node.children.length === 0) {
    content.classList.add('no-children');
} else {
    content.classList.remove('no-children');
}

// Эти классы и метки должны добавляться ВЫШЕ условия с детьми,
// чтобы применяться к любым узлам, независимо от наличия детей
if (node.content.absent269) {
    content.classList.add('absent-269');
    content.setAttribute('data-label', 'Нет в 269-П');
}
if (node.content.isPower269) {
    content.classList.add('power-269');
    content.setAttribute('data-label', 'Полномочие из 269-П');
}
if (node.content.isForAll) {
    content.classList.add('for-all-node');
    content.setAttribute('data-label', 'Для всех сотрудников');
}
if (node.content.isSubordinate) {
    content.classList.add('subordinate-node');
    content.setAttribute('data-label', 'Должностные регламенты');
}
if (node.content.isAuthority) {
    content.classList.add('authority-node');
    content.setAttribute('data-label', 'Идентичное полномочие');
}
    if (node.content.isOrganizationalEvent) {
                    content.classList.add('organizational-event-node');
                    content.setAttribute('data-label', 'Оргштатные мероприятия');
                }
if (node.content.isOKR) {
    content.classList.add('okr-node');
    content.setAttribute('data-label', 'OKR (Цели и ключевые результаты)');
}
if (node.content.isIndicator) {
    content.classList.add('indicator-node');
    content.setAttribute('data-label', 'Государственная программа');
}
if (node.content.absent269 && node.children.length > 0) {
    content.classList.add('absent-269');
    content.setAttribute('data-label', 'Нет в 269-П');
    setTimeout(() => nodeEffects.addEffect(content, 'absent269'), 100);
}

if (node.content.isPower269 && node.children.length > 0) {
    content.classList.add('power-269');
    content.setAttribute('data-label', 'Полномочие из 269-П');
    setTimeout(() => nodeEffects.addEffect(content, 'power269'), 100);
}

if (node.content.isForAll && node.children.length > 0) {
    content.classList.add('for-all-node');
    content.setAttribute('data-label', 'Для всех сотрудников');
    setTimeout(() => nodeEffects.addEffect(content, 'forAll'), 100);
}

if (node.content.isSubordinate && node.children.length > 0) {
    content.classList.add('subordinate-node');
    content.setAttribute('data-label', 'Должностные регламенты');
    setTimeout(() => nodeEffects.addEffect(content, 'subordinate'), 100);
}

if (node.content.isAuthority && node.children.length > 0) {
    content.classList.add('authority-node');
    content.setAttribute('data-label', 'Идентичное полномочие');
    setTimeout(() => nodeEffects.addEffect(content, 'authority'), 100);
}

if (node.content.isOKR && node.children.length > 0) {
    content.classList.add('okr-node');
    content.setAttribute('data-label', 'OKR (Цели и ключевые результаты)');
}

if (node.content.isIndicator && node.children.length > 0) {
    content.classList.add('indicator-node');
    content.setAttribute('data-label', 'Государственная программа');
}
if (this.clusters.has(node.id)) {
    const clusterMarker = document.createElement('div');
    clusterMarker.className = 'cluster-marker';
    clusterMarker.innerHTML = '🏷️';
    clusterMarker.title = `Отдел: ${this.clusters.get(node.id)}`;
    content.appendChild(clusterMarker);
}
if (node.children.length > 0) {
    const childrenCount = document.createElement('div');
    childrenCount.className = 'children-count';
    childrenCount.textContent = node.children.length;
    content.appendChild(childrenCount);
}
if (node.children.length > 0) {
    const visibleChildren = node.children.filter(child => this.shouldShowNode(child));
    if (visibleChildren.length > 0) {
        const childrenCount = document.createElement('div');
        childrenCount.className = 'children-count';
        childrenCount.textContent = visibleChildren.length;
        content.appendChild(childrenCount);
        content.setAttribute('data-children-count', visibleChildren.length);
    }
}
    if (node !== this.treeData) {
        content.draggable = true;
        content.addEventListener('dragstart', (e) => this.handleNodeDragStart(e, node, nodeElement));
        content.addEventListener('dragover', (e) => this.handleNodeDragOver(e, node, nodeElement));
        content.addEventListener('drop', (e) => this.handleNodeDrop(e, node, nodeElement));
    }

    const expandIcon = document.createElement('span');


const imgContainer = document.createElement('div');
imgContainer.className = `image-container ${node.content.isHorizontal ? 'horizontal' : ''}`;

if (node.content.img && !node.content.hideIcon) {
  imgContainer.innerHTML = `
    <div class="image-actions">
      <img src="${this.imagesData[node.content.img] || ''}" class="node-img ${node.content.isHorizontal ? 'horizontal' : ''}" onerror="this.style.display='none'" onclick="treeApp.showFullPreview('${node.content.img}')">
      <button class="delete-image-btn ${node.content.isHorizontal ? 'horizontal' : ''}" onclick="event.stopPropagation(); treeApp.removeImage(${node.id})" title="Удалить изображение">×</button>
      <button class="hide-image-btn ${node.content.isHorizontal ? 'horizontal' : ''}" onclick="event.stopPropagation(); treeApp.hideImageIcon(${node.id})" title="Скрыть иконку">👁️</button>
    </div>
  `;
} else if (!node.content.isTextOnly) {
  imgContainer.innerHTML = `
    <div class="upload-image-options">
      <div class="node-img ${node.content.isHorizontal ? 'horizontal' : ''}" onclick="treeApp.uploadImage()">📷</div>
      ${node.content.hideIcon ? `<div class="show-image-btn" onclick="event.stopPropagation(); treeApp.showImageIcon(${node.id})">Показать иконку</div>` : ''}
      <div class="text-only-option" onclick="treeApp.setAsTextOnly(${node.id})">Только текст</div>
    </div>
  `;
} else {
  imgContainer.innerHTML = `
    <div class="text-only-mode">
      <div class="allow-image-btn" onclick="event.stopPropagation(); treeApp.allowImage(${node.id})">Разрешить изображение</div>
    </div>
  `;
}
        const nodeHeader = document.createElement('div');
        nodeHeader.className = `node-header ${node.content.isHorizontal ? 'horizontal' : ''}`;
        
        const nodeTitle = document.createElement('div');
        nodeTitle.className = `node-title ${node.content.isHorizontal ? 'horizontal' : ''}`;
        nodeTitle.textContent = node.content.text;
nodeTitle.addEventListener('click', (e) => {
    e.stopPropagation(); // Предотвращаем всплытие
    // Проверяем, не редактируется ли уже заголовок
    if (!e.target.classList.contains('node-title-input')) {
        this.enableTitleEdit(node);
    }
});

        nodeHeader.appendChild(imgContainer);
        nodeHeader.appendChild(nodeTitle);

        const subBlocksContainer = document.createElement('div');
        subBlocksContainer.className = `sub-blocks ${node.content.isHorizontal ? 'horizontal' : ''}`;
    if (node.content.position) {
        const positionElement = document.createElement('div');
        positionElement.className = `sub-block ${node.content.isHorizontal ? 'horizontal' : ''}`;
        positionElement.innerHTML = `<strong>Должность:</strong> ${node.content.position}`;
        positionElement.style.backgroundColor = 'rgba(255, 165, 0, 0.1)';
        positionElement.style.border = '1px solid #FFA500';
        subBlocksContainer.appendChild(positionElement);
    }
        if(node.content.subBlocks) {
            node.content.subBlocks.forEach((subBlock, index) => {
                const subBlockElement = document.createElement('div');
                subBlockElement.className = `sub-block ${node.content.isHorizontal ? 'horizontal' : ''}`;
                
                const textSpan = document.createElement('span');
                // Проверяем, является ли текст URL
if (this.isValidEmail(subBlock)) {
    const mailLink = document.createElement('a');
    mailLink.href = 'https://email.yanao.ru/'; // Общий почтовый интерфейс
    mailLink.target = '_blank';
    mailLink.rel = 'noopener noreferrer';
    mailLink.textContent = subBlock;
    mailLink.title = 'Открыть веб-интерфейс почты';
    
    // Добавляем иконку перед email
    const mailIcon = document.createElement('span');
    mailIcon.textContent = '✉️ ';
    mailIcon.style.marginRight = '3px';
    mailLink.prepend(mailIcon);
    
    textSpan.appendChild(mailLink);
} else if (this.isValidUrl(subBlock)) {
    const link = document.createElement('a');
    const url = subBlock.startsWith('http') ? subBlock : `https://${subBlock}`;
    link.href = url;
    link.target = '_blank';
    link.rel = 'noopener noreferrer';
    link.textContent = this.extractDomain(subBlock);
    link.title = url;
    textSpan.appendChild(link);
} else {
    textSpan.textContent = subBlock;
}
        const actionsDiv = document.createElement('div');
        actionsDiv.className = "sub-block-actions";
        actionsDiv.innerHTML = `
            <span onclick="treeApp.editSubBlock(treeApp.findNode(treeApp.treeData, ${node.id}), ${index})">✎</span>
            <span onclick="treeApp.removeSubBlock(treeApp.findNode(treeApp.treeData, ${node.id}), ${index})">×</span>
        `;
        
        subBlockElement.appendChild(textSpan);
        subBlockElement.appendChild(actionsDiv);
        
        subBlockElement.addEventListener('dblclick', (e) => {
            e.stopPropagation();
            this.editSubBlock(node, index);
        });
        
        subBlocksContainer.appendChild(subBlockElement);
    });
}
if (node.content.absent269) {
  content.classList.add('absent-269');
  content.setAttribute('data-label', 'Нет в 269-П');
  setTimeout(() => nodeEffects.addEffect(content, 'absent269'), 100);
}

if (node.content.isForAll) {
  content.classList.add('for-all-node');
  content.setAttribute('data-label', 'Для всех сотрудников');
  setTimeout(() => nodeEffects.addEffect(content, 'forAll'), 100);
}
if (node.content.isOKR) {
  content.classList.add('okr-node');
  content.setAttribute('data-label', 'OKR (Цели и ключевые результаты)');
}
if (node.content.isIndicator) {
    content.classList.add('indicator-node');
    content.setAttribute('data-label', 'Государственная программа');
}
if (node.content.isPower269) {
  content.classList.add('power-269');
  content.setAttribute('data-label', 'Полномочие из 269-П');
  setTimeout(() => nodeEffects.addEffect(content, 'power269'), 100);
}

if (node.content.isSubordinate) {
  content.classList.add('subordinate-node');
  content.setAttribute('data-label', 'Должностные регламенты');
  setTimeout(() => nodeEffects.addEffect(content, 'subordinate'), 100);
}

if (node.content.isAuthority) {
  content.classList.add('authority-node');
  content.setAttribute('data-label', 'Идентичное полномочие');
  setTimeout(() => nodeEffects.addEffect(content, 'authority'), 100);
}
    if(node.content.files && node.content.files.length > 0) {
        // Удаляем старые элементы файлов перед добавлением новых
        const existingFileElements = subBlocksContainer.querySelectorAll('.file-block');
        existingFileElements.forEach(el => el.remove());
        
        // Добавляем файлы только один раз
        node.content.files.forEach((fileId, index) => {
            const file = this.filesData[fileId];
            if (!file) {
                console.warn('File not found:', fileId);
                return;
            }
            
            const fileElement = document.createElement('div');
            fileElement.className = `sub-block file-block ${node.content.isHorizontal ? 'horizontal' : ''}`;
            
            const fileIcon = document.createElement('span');
            fileIcon.textContent = this.getFileIcon(file.type);
            fileIcon.style.marginRight = '5px';
            
            const fileSpan = document.createElement('span');
            // Сохраняем оригинальное название файла в атрибуте
            fileSpan.setAttribute('data-original-name', file.name);
            fileSpan.textContent = file.name;
            fileSpan.style.cursor = 'pointer';
            fileSpan.onclick = (e) => {
                e.stopPropagation();
                this.downloadFile(fileId);
            };
            
            const actionsDiv = document.createElement('div');
            actionsDiv.className = "sub-block-actions";
            actionsDiv.innerHTML = `
                <span onclick="event.stopPropagation(); treeApp.downloadFile('${fileId}')" title="Скачать">⬇️</span>
                <span onclick="event.stopPropagation(); treeApp.removeFile(treeApp.findNode(treeApp.treeData, ${node.id}), '${fileId}')" title="Удалить">×</span>
            `;
            
            fileElement.appendChild(fileIcon);
            fileElement.appendChild(fileSpan);
            fileElement.appendChild(actionsDiv);
            
            subBlocksContainer.appendChild(fileElement);
        });
    }
const addMetricBlockBtn = document.createElement('div');
addMetricBlockBtn.className = `add-sub-block ${node.content.isHorizontal ? 'horizontal' : ''}`;
addMetricBlockBtn.textContent = '+ Добавить метрику';
addMetricBlockBtn.addEventListener('click', (e) => {
    e.stopPropagation();
    this.addMetricBlock(node);
});
        const addSubBlockBtn = document.createElement('div');
        addSubBlockBtn.className = `add-sub-block ${node.content.isHorizontal ? 'horizontal' : ''}`;
        addSubBlockBtn.textContent = '+ Добавить подблок';
        addSubBlockBtn.addEventListener('click', (e) => {
            e.stopPropagation();
            this.addSubBlock(node);
        });
if (node.content.metricBlocks) {
    node.content.metricBlocks.forEach((metricBlock, blockIndex) => {
        const metricContainer = document.createElement('div');
        metricContainer.className = `metric-container ${node.content.isHorizontal ? 'horizontal' : ''}`;
        
        const metricHeader = document.createElement('div');
        metricHeader.className = 'metric-header';
        
        const metricTitle = document.createElement('input');
        metricTitle.type = 'text';
        metricTitle.value = metricBlock.title;
        metricTitle.className = 'metric-title';
        metricTitle.addEventListener('change', (e) => {
            metricBlock.title = e.target.value;
            this.saveData();
        });
        metricTitle.addEventListener('click', (e) => {
            e.stopPropagation();
        });
        
        metricHeader.appendChild(metricTitle);
        
        const quartersContainer = document.createElement('div');
        quartersContainer.className = 'quarters-container';
        
        metricBlock.quarters.forEach((quarter, qIndex) => {
            const quarterElement = document.createElement('div');
            quarterElement.className = 'quarter-block';
            
            const quarterLabel = document.createElement('div');
            quarterLabel.className = 'quarter-label';
            quarterLabel.textContent = `Q${qIndex + 1}`;
            
            // План
            const planInput = document.createElement('input');
            planInput.type = 'number';
            planInput.value = quarter.plan;
            planInput.placeholder = 'План';
            planInput.className = 'quarter-value plan-value';
planInput.style.fontSize = '2.5rem !important';
planInput.style.padding = '15px !important';
planInput.style.width = '140px !important';
            planInput.addEventListener('wheel', (e) => e.preventDefault());
            planInput.addEventListener('click', (e) => e.stopPropagation());
            
            // Факт
            const factInput = document.createElement('input');
            factInput.type = 'number';
            factInput.value = quarter.fact;
            factInput.placeholder = 'Факт';
planInput.style.fontSize = '2.5rem !important';
planInput.style.padding = '15px !important';
planInput.style.width = '140px !important';
            factInput.className = 'quarter-value fact-value';
            factInput.addEventListener('wheel', (e) => e.preventDefault());
            factInput.addEventListener('click', (e) => e.stopPropagation());
            
            // Диаграмма Ганта
            const ganttContainer = document.createElement('div');
            ganttContainer.className = 'gantt-container';
            
            const planBar = document.createElement('div');
            planBar.className = 'gantt-bar plan-bar';
            
            const factBar = document.createElement('div');
            factBar.className = 'gantt-progress fact-bar';
            planBar.appendChild(factBar);
            
            ganttContainer.appendChild(planBar);
            
            // Разница и обновление
            const diffElement = document.createElement('div');
            diffElement.className = 'quarter-diff';
diffElement.style.fontSize = '2.5rem !important';
diffElement.style.margin = '10px 0 !important';
            
            const updateDiff = () => {
                const diff = quarter.fact - quarter.plan;
                const percentage = quarter.plan !== 0 ? 
                    Math.round((quarter.fact / quarter.plan) * 100) : 
                    (quarter.fact !== 0 ? 100 : 0);
                
                diffElement.textContent = `${percentage}%`;
                diffElement.style.color = diff >= 0 ? '#4CAF50' : '#F44336';
                
                factBar.style.width = quarter.plan !== 0 ? 
                    Math.min(100, (quarter.fact / quarter.plan) * 100) + '%' : 
                    (quarter.fact !== 0 ? '100%' : '0%');
            };
            
            updateDiff();
            
            planInput.addEventListener('input', (e) => {
                quarter.plan = parseFloat(e.target.value) || 0;
                this.saveData();
                updateDiff();
            });
            
            factInput.addEventListener('input', (e) => {
                quarter.fact = parseFloat(e.target.value) || 0;
                this.saveData();
                updateDiff();
            });
            
            // Добавляем элементы в контейнер квартала
            quarterElement.appendChild(quarterLabel);
            quarterElement.appendChild(planInput);
            quarterElement.appendChild(factInput);
            quarterElement.appendChild(ganttContainer);
            quarterElement.appendChild(diffElement);
            
            quartersContainer.appendChild(quarterElement);
        });
        
        metricContainer.appendChild(metricHeader);
        metricContainer.appendChild(quartersContainer);
        
        const deleteMetricBtn = document.createElement('button');
        deleteMetricBtn.className = 'delete-metric-btn';
        deleteMetricBtn.textContent = '× Удалить';
        deleteMetricBtn.addEventListener('click', (e) => {
            e.stopPropagation();
            if (confirm('Удалить эту метрику?')) {
                this.removeMetricBlock(node, blockIndex);
            }
        });
        
        metricContainer.appendChild(deleteMetricBtn);
        subBlocksContainer.appendChild(metricContainer);
    });
}
if (node.content.isIndicator && node.content.indicators) {
    // Инициализация metrics, если их нет
    if (!node.content.indicators.metrics) {
        node.content.indicators.metrics = [];
    }

    const indicatorsContainer = document.createElement('div');
    indicatorsContainer.className = `indicators-container ${node.content.isHorizontal ? 'horizontal' : ''}`;
    
    // Для горизонтальных узлов делаем контейнер шире
    if (node.content.isHorizontal) {
        indicatorsContainer.style.width = 'auto';
        indicatorsContainer.style.minWidth = '100%';
        indicatorsContainer.style.overflowX = 'visible';
    } else {
        indicatorsContainer.style.width = '100%';
        indicatorsContainer.style.overflowX = 'auto';
    }
    
    // Создаем таблицу показателей
    const table = document.createElement('table');
    table.className = 'compact-indicators-table';
    
    // Настройки таблицы
    if (node.content.isHorizontal) {
        table.style.width = 'auto';
        table.style.minWidth = '100%';
        table.style.tableLayout = 'auto';
    } else {
        table.style.width = '100%';
        table.style.tableLayout = 'fixed';
    }
    
    // Заголовок таблицы
    const thead = document.createElement('thead');
    const headerRow = document.createElement('tr');
    
    // Пустая ячейка для угла
    const cornerCell = document.createElement('th');
    cornerCell.style.minWidth = '180px';
    cornerCell.style.textAlign = 'left';
    cornerCell.style.paddingLeft = '15px';
    headerRow.appendChild(cornerCell);
    
    // Все годы в заголовке
    node.content.indicators.years.forEach(year => {
        const th = document.createElement('th');
        th.textContent = year;
        th.style.minWidth = node.content.isHorizontal ? '120px' : '150px';
        th.style.fontSize = '1.5rem';
        th.style.textAlign = 'center';
        headerRow.appendChild(th);
    });
    
    thead.appendChild(headerRow);
    table.appendChild(thead);
    
    // Тело таблицы
    const tbody = document.createElement('tbody');
    
    // Строки с этапами
    node.content.indicators.stages.forEach((stage, stageIndex) => {
        const row = document.createElement('tr');
        
        // Название этапа
        const stageCell = document.createElement('td');
        stageCell.textContent = stage;
        stageCell.title = stage;
        stageCell.style.fontSize = '2.5rem';
        stageCell.style.whiteSpace = 'nowrap';
        stageCell.style.padding = '12px 15px';
        stageCell.style.minWidth = '180px';
        if (stage === "Вес. значение") {
            stageCell.style.fontWeight = 'bold';
            stageCell.style.color = 'var(--accent-color)';
        }

        row.appendChild(stageCell);
        
        // Значения для каждого года
        node.content.indicators.years.forEach((year, yearIndex) => {
            const cell = document.createElement('td');
            cell.style.padding = '12px 8px';
            cell.style.minWidth = node.content.isHorizontal ? '120px' : '150px';
            
            const input = document.createElement('input');
            input.type = 'text';
            input.inputMode = 'numeric';
            input.className = 'compact-indicator-value';
            input.style.width = '100%';
            input.style.height = '50px';
            input.style.padding = '10px';
            input.style.fontSize = '2.4rem';
            input.style.textAlign = 'center';
            input.style.border = '1px solid var(--secondary-color)';
            input.style.borderRadius = '4px';
            input.style.boxSizing = 'border-box';
            
            // Форматируем начальное значение
            const formatValue = (value) => {
                if (value === 0) return '';
                return value.toString().replace(/\B(?=(\d{3})+(?!\d))/g, " ");
            };
            
            // Устанавливаем начальное отформатированное значение
            input.value = formatValue(node.content.indicators.values[yearIndex][stageIndex] || 0);
            
            // Обработчик ввода
input.addEventListener('input', (e) => {
    // Сохраняем введенное значение как есть
    const value = e.target.value;
    node.content.indicators.values[yearIndex][stageIndex] = value;
    this.saveData();
});

input.addEventListener('input', (e) => {
    // Сохраняем введенное значение как есть
    const value = e.target.value;
    node.content.indicators.values[yearIndex][stageIndex] = value;
    this.saveData();
});
input.addEventListener('keydown', (e) => {
    e.stopPropagation(); // Предотвращаем всплытие событий
});
input.addEventListener('blur', (e) => {
    const value = node.content.indicators.values[yearIndex][stageIndex] || '';
    e.target.value = value;
});
input.addEventListener('focus', (e) => {
    const value = node.content.indicators.values[yearIndex][stageIndex] || '';
    e.target.value = value;
});            
            input.addEventListener('wheel', (e) => e.preventDefault());
            
            cell.appendChild(input);
            row.appendChild(cell);
        });
        
        tbody.appendChild(row);
    });
    
    table.appendChild(tbody);
    indicatorsContainer.appendChild(table);

    // Контейнер для метрик (остается без изменений)
    const metricsContainer = document.createElement('div');
    metricsContainer.className = 'indicator-metrics';
    metricsContainer.style.marginTop = '20px';
    
    // Заголовок
    const metricsTitle = document.createElement('div');
    metricsTitle.className = 'metrics-title';
    metricsTitle.textContent = 'Метрики:';
    metricsTitle.style.fontSize = '1.8rem';
    metricsTitle.style.marginBottom = '10px';
    metricsContainer.appendChild(metricsTitle);
    
    // Список метрик
    const metricsList = document.createElement('div');
    metricsList.className = 'metrics-list';
    
    if (node.content.indicators.metrics.length > 0) {
        node.content.indicators.metrics.forEach((metric, index) => {
const metricElement = document.createElement('div');
metricElement.className = 'metric-item';
metricElement.style.display = 'flex';
metricElement.style.justifyContent = 'space-between';
metricElement.style.alignItems = 'center';
metricElement.style.padding = '10px';
metricElement.style.margin = '5px 0';
metricElement.style.background = 'rgba(93, 138, 168, 0.1)';
metricElement.style.borderRadius = '6px';

const metricText = document.createElement('span');
metricText.textContent = metric;
metricText.style.flex = '1';

// Добавляем обработчик двойного клика для редактирования
metricText.addEventListener('dblclick', (e) => {
    e.stopPropagation();
    const newValue = prompt('Редактировать метрику:', metric);
    if (newValue !== null && newValue.trim() !== metric) {
        node.content.indicators.metrics[index] = newValue.trim();
        this.updateTree();
        this.saveData();
    }
});

const buttonsContainer = document.createElement('div');
buttonsContainer.style.display = 'flex';
buttonsContainer.style.gap = '8px';

// Кнопка редактирования
const editBtn = document.createElement('button');
editBtn.innerHTML = '✎';
editBtn.style.background = 'none';
editBtn.style.border = 'none';
editBtn.style.color = 'var(--primary-color)';
editBtn.style.cursor = 'pointer';
editBtn.style.fontSize = '1.2rem';
editBtn.title = 'Редактировать';
editBtn.addEventListener('click', (e) => {
    e.stopPropagation();
    const newValue = prompt('Редактировать метрику:', metric);
    if (newValue !== null && newValue.trim() !== metric) {
        node.content.indicators.metrics[index] = newValue.trim();
        this.updateTree();
        this.saveData();
    }
});

// Кнопка удаления
const deleteBtn = document.createElement('button');
deleteBtn.innerHTML = '&times;';
deleteBtn.style.background = 'none';
deleteBtn.style.border = 'none';
deleteBtn.style.color = 'var(--accent-color)';
deleteBtn.style.cursor = 'pointer';
deleteBtn.style.fontSize = '1.5rem';
deleteBtn.title = 'Удалить';
deleteBtn.addEventListener('click', (e) => {
    e.stopPropagation();
    if (confirm('Удалить эту метрику?')) {
        node.content.indicators.metrics.splice(index, 1);
        this.updateTree();
        this.saveData();
    }
});

buttonsContainer.appendChild(editBtn);
buttonsContainer.appendChild(deleteBtn);

metricElement.appendChild(metricText);
metricElement.appendChild(buttonsContainer);
metricsList.appendChild(metricElement);
        });
    } else {
        const emptyMessage = document.createElement('div');
        emptyMessage.textContent = 'Нет добавленных метрик';
        emptyMessage.style.color = 'var(--primary-color)';
        emptyMessage.style.fontStyle = 'italic';
        emptyMessage.style.padding = '10px';
        metricsList.appendChild(emptyMessage);
    }
    
    metricsContainer.appendChild(metricsList);
    
    // Кнопка добавления метрики
    const addMetricBtn = document.createElement('button');
    addMetricBtn.className = 'add-metric-btn';
    addMetricBtn.textContent = '+ Добавить метрику';
    addMetricBtn.style.marginTop = '10px';
    addMetricBtn.style.padding = '10px 15px';
    addMetricBtn.style.background = 'var(--primary-color)';
    addMetricBtn.style.color = 'white';
    addMetricBtn.style.border = 'none';
    addMetricBtn.style.borderRadius = '6px';
    addMetricBtn.style.cursor = 'pointer';
    addMetricBtn.style.width = '100%';
    addMetricBtn.addEventListener('click', (e) => {
        e.stopPropagation();
        const newMetric = prompt('Введите метрику:');
        if (newMetric && newMetric.trim()) {
            node.content.indicators.metrics.push(newMetric.trim());
            this.updateTree();
            this.saveData();
        }
    });
    
    metricsContainer.appendChild(addMetricBtn);
    const resultContainer = document.createElement('div');
    resultContainer.className = 'result-block';
    resultContainer.style.marginTop = '20px';
    resultContainer.style.padding = '15px';
    resultContainer.style.background = 'rgba(76, 175, 80, 0.1)';
    resultContainer.style.border = '2px solid #4CAF50';
    resultContainer.style.borderRadius = '8px';
    resultContainer.style.position = 'relative';

    // Инициализация результата, если его нет
    if (!node.content.indicators.result) {
        node.content.indicators.result = '';
    }

    // Иконка галочки
    const checkIcon = document.createElement('div');
    checkIcon.style.position = 'absolute';
    checkIcon.style.left = '-12px';
    checkIcon.style.top = '-12px';
    checkIcon.style.width = '28px';
    checkIcon.style.height = '28px';
    checkIcon.style.background = '#4CAF50';
    checkIcon.style.color = 'white';
    checkIcon.style.borderRadius = '50%';
    checkIcon.style.display = 'flex';
    checkIcon.style.alignItems = 'center';
    checkIcon.style.justifyContent = 'center';
    checkIcon.textContent = '✓';
    resultContainer.appendChild(checkIcon);

    // Заголовок результата
    const resultTitle = document.createElement('div');
    resultTitle.className = 'result-title';
    resultTitle.textContent = 'Результат выполнения:';
    resultTitle.style.fontWeight = 'bold';
    resultTitle.style.marginBottom = '20px';
    resultTitle.style.color = '#2E7D32';
    resultContainer.appendChild(resultTitle);

    // Текст результата
    const resultText = document.createElement('div');
    resultText.className = 'result-text';
    resultText.textContent = node.content.indicators.result || 'Нажмите, чтобы добавить результат';
    resultText.style.whiteSpace = 'pre-wrap';
    resultText.style.lineHeight = '1.5';
    resultText.style.minHeight = '50px';
    resultText.style.cursor = 'pointer';
    resultText.addEventListener('click', (e) => {
        e.stopPropagation();
        const newResult = prompt('Введите результат выполнения:', node.content.indicators.result);
        if (newResult !== null) {
            node.content.indicators.result = newResult;
            this.updateTree();
            this.saveData();
        }
    });
    resultContainer.appendChild(resultText);

    // Добавляем блок результата в контейнер метрик
    metricsContainer.appendChild(resultContainer);

    // Кнопка "Добавить результат" если результат пустой
    if (!node.content.indicators.result) {
        const addResultBtn = document.createElement('button');
        addResultBtn.className = 'add-metric-btn';
        addResultBtn.textContent = '+ Добавить результат';
        addResultBtn.style.marginTop = '20px';
        addResultBtn.style.background = '#4CAF50';
        addResultBtn.addEventListener('click', (e) => {
            e.stopPropagation();
            const newResult = prompt('Введите результат выполнения:');
            if (newResult) {
                node.content.indicators.result = newResult;
                this.updateTree();
                this.saveData();
            }
        });
        metricsContainer.appendChild(addResultBtn);
    }
    indicatorsContainer.appendChild(metricsContainer);
    subBlocksContainer.appendChild(indicatorsContainer);
}
subBlocksContainer.appendChild(addMetricBlockBtn);
        subBlocksContainer.appendChild(addSubBlockBtn);
        
        const nodeTypeSelector = document.createElement('div');
        nodeTypeSelector.className = 'node-type-selector';
        
        const verticalBtn = document.createElement('div');
        verticalBtn.className = `node-type-btn ${!node.content.isHorizontal ? 'active' : ''}`;
        verticalBtn.innerHTML = '↕';
        verticalBtn.title = 'Вертикальный узел';
verticalBtn.addEventListener('click', (e) => {
    e.stopPropagation();
    
    // Сохраняем состояние прокрутки
    const treeContainer = this.elements.treeContainer;
    this.scrollState = {
        scrollLeft: treeContainer.scrollLeft,
        scrollTop: treeContainer.scrollTop
    };
    
    node.content.isHorizontal = false;
    
    // Обновляем только классы элемента
    nodeElement.classList.remove('horizontal');
    nodeElement.querySelector('.node-content').classList.remove('horizontal');
    
    // Восстанавливаем прокрутку
    requestAnimationFrame(() => {
        treeContainer.scrollLeft = this.scrollState.scrollLeft;
        treeContainer.scrollTop = this.scrollState.scrollTop;
    });
    
    this.saveData();
});
        
        const horizontalBtn = document.createElement('div');
        horizontalBtn.className = `node-type-btn ${node.content.isHorizontal ? 'active' : ''}`;
        horizontalBtn.innerHTML = '↔';
        horizontalBtn.title = 'Горизонтальный узел';
        horizontalBtn.addEventListener('click', (e) => {
            e.stopPropagation();
            node.content.isHorizontal = true;
            this.updateTree();
            this.saveData();
        });
        
        nodeTypeSelector.appendChild(verticalBtn);
        nodeTypeSelector.appendChild(horizontalBtn);
const nodeActions = document.createElement('div');
nodeActions.className = 'node-actions';

const addBtn = document.createElement('button');
addBtn.className = 'node-action-btn add-btn';
addBtn.innerHTML = '+';
addBtn.title = 'Добавить дочерний узел';
addBtn.addEventListener('click', (e) => {
    e.stopPropagation();
    this.addChild();
});

const deleteBtn = document.createElement('button');
deleteBtn.className = 'node-action-btn delete-btn';
deleteBtn.innerHTML = '-';
deleteBtn.title = this.selectedNodes.size > 0 ? `Удалить (${this.selectedNodes.size}) узлов` : 'Удалить узел';
deleteBtn.addEventListener('click', (e) => {
    e.stopPropagation();
    this.deleteNode();
});
const promoteDeleteBtn = document.createElement('button');
promoteDeleteBtn.className = 'node-action-btn promote-delete-btn'; // ✨ ИЗМЕНЕНИЕ: Добавлен общий класс и специальный класс для цвета
promoteDeleteBtn.innerHTML = '⏏'; // ✨ ИЗМЕНЕНИЕ: Используем Unicode-символ "Eject" [6, 7]
promoteDeleteBtn.title = 'Удалить узел, подняв дочерние';
promoteDeleteBtn.addEventListener('click', (e) => {
    e.stopPropagation();
    this.deleteNodeAndPromoteChildren();
});
nodeActions.appendChild(addBtn);
nodeActions.appendChild(promoteDeleteBtn);
nodeActions.appendChild(deleteBtn);
content.appendChild(nodeActions);
expandIcon.addEventListener('click', (e) => {
    e.stopPropagation();
    
    // Сохраняем позицию прокрутки перед изменением
    const treeContainer = this.elements.treeContainer;
    this.scrollState = {
        scrollLeft: treeContainer.scrollLeft,
        scrollTop: treeContainer.scrollTop
    };
    
    node.isExpanded = !node.isExpanded;
    
    // Обновляем только иконку и видимость детей

    
    const childrenContainer = nodeElement.querySelector('.children');
    if (childrenContainer) {
        childrenContainer.classList.toggle('collapsed', !node.isExpanded);
    }
    
    // Восстанавливаем позицию прокрутки после изменения
    requestAnimationFrame(() => {
        treeContainer.scrollLeft = this.scrollState.scrollLeft;
        treeContainer.scrollTop = this.scrollState.scrollTop;
    });
    
    this.saveData();
});




        content.appendChild(nodeTypeSelector);
if (this.clusters.has(node.id)) {
    const clusterName = this.clusters.get(node.id);
    const clusterMarker = document.createElement('div');
    clusterMarker.className = 'cluster-marker';
    content.appendChild(clusterMarker);
    
    content.classList.add('in-cluster');
}
        content.appendChild(nodeHeader);
        content.appendChild(subBlocksContainer);
content.addEventListener('click', (e) => {
    // Проверяем, был ли клик на заголовке или его элементах
    const isClickOnTitle = e.target.closest('.node-title, .node-title-input');
    const isClickOnActionBtn = e.target.closest('.node-action-btn');
    
    if (!isClickOnTitle && !isClickOnActionBtn && e.target !== expandIcon && !e.target.closest('.node-type-btn')) {
        this.selectNode(node, nodeElement);
        
        // Всегда оставляем корневой узел открытым
        const isRootNode = node === this.treeData;
        
        // Если нажат Ctrl - не раскрываем/скрываем узел
        if (!isRootNode && !this.ctrlPressed) {
            // Сохраняем текущее состояние прокрутки и трансформации
            const treeContainer = this.elements.treeContainer;
            const currentState = {
                scrollLeft: treeContainer.scrollLeft,
                scrollTop: treeContainer.scrollTop,
                transform: treeContainer.style.transform
            };
            
            // Изменяем состояние узла
            node.isExpanded = !node.isExpanded;
            
            // После обновления дерева восстанавливаем позицию
            setTimeout(() => {
                treeContainer.scrollLeft = currentState.scrollLeft;
                treeContainer.scrollTop = currentState.scrollTop;
                treeContainer.style.transform = currentState.transform;
                
                // Если нужно, обновляем переменные pan/zoom
                if (window.panZoomVars) {
                    const transformMatch = currentState.transform.match(/translate\(([^,]+),\s*([^)]+)\)/);
                    if (transformMatch) {
                        window.panZoomVars.translateX = parseFloat(transformMatch[1]);
                        window.panZoomVars.translateY = parseFloat(transformMatch[2]);
                    }
                }
            }, 10);
        }
        
        this.updateNode(node, nodeElement);
    }
});

const childrenCount = node.children.length;

let childrenContainer;
if (depth === 0) {
    // 1 уровень - горизонтальное расположение
    childrenContainer = document.createElement('div');
    childrenContainer.className = `children ${node.isExpanded ? '' : 'collapsed'}`;
    childrenContainer.style.flexDirection = 'row';
} 
else if (depth === 1) {
    if (childrenCount > 5) {
        // 2 уровень и >6 узлов - сетка 5 колонок
        childrenContainer = document.createElement('div');
        childrenContainer.className = `children grid-children ${node.isExpanded ? '' : 'collapsed'}`;
        childrenContainer.style.gridTemplateColumns = 'repeat(5, 1fr)';
    } else {
        // 2 уровень и ≤6 узлов - горизонтальное
        childrenContainer = document.createElement('div');
        childrenContainer.className = `children ${node.isExpanded ? '' : 'collapsed'}`;
        childrenContainer.style.flexDirection = 'row';
    }
}
else if (depth === 2) {
    // 3 уровень - вертикальное расположение
    childrenContainer = document.createElement('div');
    childrenContainer.className = `children ${node.isExpanded ? '' : 'collapsed'}`;
    childrenContainer.style.flexDirection = 'column';
} 
else {
    // 4+ уровни - горизонтальное если >4 узлов, иначе вертикальное
    childrenContainer = document.createElement('div');
    childrenContainer.className = `children ${node.isExpanded ? '' : 'collapsed'}`;
    childrenContainer.style.flexDirection = childrenCount > 6 ? 'row' : 'column';
}
if(node.isExpanded) {
    node.children
        .filter(child => this.shouldShowNode(child))
        .forEach((child, index) => {
            const childElement = this.createNodeElement(child);
        
        // Для горизонтального расположения (1 уровень и 4+ уровни)
        if (depth === 0 || depth >= 3) {
            const connector = document.createElement('div');
            connector.className = 'horizontal-connector';
            childElement.prepend(connector);
        } 
        // Для сеточного расположения
        else if (childrenContainer.classList.contains('grid-children')) {
            const connector = document.createElement('div');
            connector.className = 'grid-connector';
            childElement.prepend(connector);
        } 
        // Для вертикального расположения
        else {
            const connector = document.createElement('div');
            connector.className = 'connector';
            childElement.prepend(connector);
        }
        
        childrenContainer.appendChild(childElement);
    });
}
    nodeElement.appendChild(content);
    nodeElement.appendChild(childrenContainer);
        if(node.id === this.selectedNodeId) {
            content.classList.add('selected');
            this.selectedNode = { node, element: nodeElement };
        }
if (this.searchQuery && this.shouldShowNode(node)) {
    const highlightText = (text) => {
        if (!this.searchQuery) return text;
        
        const searchTerms = this.searchQuery.toLowerCase().split(/\s+/);
        let result = text;
        
        searchTerms.forEach(term => {
            if (term.length < 2) return;
            
            const regex = new RegExp(`(${term})`, 'gi');
            result = result.replace(regex, '<span class="search-match-highlight">$1</span>');
        });
        
        return result;
    };
    
    // Применяем подсветку к заголовку
    nodeTitle.innerHTML = highlightText(node.content.text);
    
    // Применяем подсветку к подблокам
if (node.content.subBlocks) {
    node.content.subBlocks.forEach((subBlock, index) => {
        const subBlockElement = subBlocksContainer.children[index];
        if (subBlockElement) {
            const textSpan = subBlockElement.querySelector('span');
            if (textSpan) {
                if (this.isValidEmail(subBlock)) {
                    // Для email оставляем как есть, только подсвечиваем текст
                    const link = textSpan.querySelector('a');
                    if (link) {
                        link.innerHTML = highlightText(link.textContent);
                    }
                } else if (this.isValidUrl(subBlock)) {
                    // Для URL оставляем как есть, только подсвечиваем текст
                    const link = textSpan.querySelector('a');
                    if (link) {
                        link.innerHTML = highlightText(link.textContent);
                    }
                } else {
                    textSpan.innerHTML = highlightText(subBlock);
                }
            }
        }
    });
}
    // Применяем подсветку к названиям файлов
    if (node.content.files) {
        node.content.files.forEach((fileId, index) => {
            const fileElement = subBlocksContainer.children[
                (node.content.subBlocks?.length || 0) + index
            ];
            if (fileElement) {
                const fileSpan = fileElement.querySelector('span');
                if (fileSpan) {
                    // Используем оригинальное название из атрибута
                    const originalName = fileSpan.getAttribute('data-original-name') || '';
                    fileSpan.innerHTML = highlightText(originalName);
                }
            }
        });
    }
}
        

        return nodeElement;
    }

enableTitleEdit(node) {
    const titleElement = document.querySelector(`[data-node-id="${node.id}"] .node-title`);
    if (!titleElement) return;
    
    // Сохраняем текущий текст
    const currentText = titleElement.textContent;
    
    // Создаем textarea для редактирования
    const textarea = document.createElement('textarea');
    textarea.className = 'node-title-input';
    textarea.value = currentText;
    
    // Копируем все стили из оригинального элемента
    const computedStyle = window.getComputedStyle(titleElement);
    const styleProps = [
        'fontFamily', 'fontSize', 'fontWeight', 'color', 
        'textAlign', 'lineHeight', 'letterSpacing', 'textTransform',
        'padding', 'margin', 'border', 'background', 'boxSizing',
        'width', 'height', 'minWidth', 'maxWidth'
    ];
    
    styleProps.forEach(prop => {
        textarea.style[prop] = computedStyle[prop];
    });
    
    // Особые стили для textarea
    textarea.style.resize = 'vertical';
    textarea.style.overflowY = 'auto';
    textarea.style.whiteSpace = 'pre-wrap';
    textarea.style.wordWrap = 'break-word';
    
    // Для подчиненных узлов добавляем специальные стили
    if (node.content.isSubordinate) {
        textarea.style.border = '2px dashed var(--secondary-color)';
        textarea.style.background = 'rgba(135, 206, 235, 0.1)';
    }
    
    // Заменяем элемент на textarea
    titleElement.replaceWith(textarea);
    
    // Устанавливаем фокус и курсор в конец текста
    textarea.focus();
    textarea.setSelectionRange(currentText.length, currentText.length);
    
    // Автоподстройка высоты
    const adjustHeight = () => {
        textarea.style.height = 'auto';
        textarea.style.height = Math.min(textarea.scrollHeight, 300) + 'px';
    };
    adjustHeight();
    textarea.addEventListener('input', adjustHeight);
    
    // Обработчики событий
    const finishEditing = () => {
        const newText = textarea.value.trim();
        if (newText && newText !== currentText) {
            this.saveToHistory();
            node.content.text = newText;
            this.updateTree();
            this.saveData();
        } else {
            // Восстанавливаем оригинальный элемент
            textarea.replaceWith(titleElement);
        }
    };
    
    textarea.addEventListener('blur', finishEditing);
    
    textarea.addEventListener('keydown', (e) => {
e.stopPropagation();
        if (e.key === 'Enter' && !e.shiftKey) {
            e.preventDefault();
            finishEditing();
        }
        // Останавливаем всплытие для всех клавиш
        e.stopPropagation();
    });
    
    // Останавливаем всплытие при клике на textarea
    textarea.addEventListener('click', (e) => {
        e.stopPropagation();
    });
}
restoreParentPosition(parentElement, restoreData) {
    try {
        const treeContainer = this.elements.treeContainer;
        
        // Получаем текущую позицию родительского элемента
        const currentRect = parentElement.getBoundingClientRect();
        const containerRect = treeContainer.getBoundingClientRect();
        
        // Вычисляем текущую относительную позицию
        const currentRelativeX = currentRect.left - containerRect.left;
        const currentRelativeY = currentRect.top - containerRect.top;
        
        // Вычисляем разность между сохраненной и текущей позицией
        const deltaX = restoreData.relativeX - currentRelativeX;
        const deltaY = restoreData.relativeY - currentRelativeY;
        
        // Получаем текущий transform контейнера
        const currentTransform = treeContainer.style.transform;
        const currentTranslateMatch = currentTransform.match(/translate\(([^,]+),\s*([^)]+)\)/);
        const currentScaleMatch = currentTransform.match(/scale\(([^)]+)\)/);
        
        const currentTranslateX = currentTranslateMatch ? parseFloat(currentTranslateMatch[1]) : 0;
        const currentTranslateY = currentTranslateMatch ? parseFloat(currentTranslateMatch[2]) : 0;
        const currentScale = currentScaleMatch ? parseFloat(currentScaleMatch[1]) : 1;
        
        // Применяем коррекцию позиции
        const newTranslateX = currentTranslateX + deltaX;
        const newTranslateY = currentTranslateY + deltaY;
        
        // Обновляем переменные pan/zoom системы
        if (window.panZoomVars) {
            window.panZoomVars.translateX = newTranslateX;
            window.panZoomVars.translateY = newTranslateY;
            window.panZoomVars.scale = currentScale;
        }
        
        // Применяем трансформацию с плавной анимацией
        treeContainer.style.transition = 'transform 0.2s ease-out';
        treeContainer.style.transform = `translate(${newTranslateX}px, ${newTranslateY}px) scale(${currentScale})`;
        
        // Убираем transition после анимации
        setTimeout(() => {
            treeContainer.style.transition = '';
        }, 200);
        
        // Подсвечиваем родительский элемент
        const contentElement = parentElement.querySelector('.node-content');
        if (contentElement) {
            contentElement.classList.add('highlight-parent');
            setTimeout(() => {
                contentElement.classList.remove('highlight-parent');
            }, 1000);
        }
        
    } catch (error) {
        console.error('Ошибка при восстановлении позиции родительского узла:', error);
        // Fallback к стандартному центрированию
        this.centerOnElement(parentElement);
    }
}
selectNode(node, element) {
    const contentElement = element.querySelector('.node-content');
    
    // Если нажат Ctrl - режим множественного выбора
    if (this.ctrlPressed) {
        this.multiSelectMode = true;
        
        if (this.selectedNodes.has(node.id)) {
            // Уже выбран - снимаем выделение
            this.selectedNodes.delete(node.id);
            contentElement.classList.remove('selected', 'multi-selected');
        } else {
            // Новый узел - добавляем в множество выбранных
            this.selectedNodes.add(node.id);
        }
        
        // Обновляем основной выбранный узел и счетчик
        this.selectedNode = { node, element };
        this.selectedNodeId = node.id;
        
        // Добавляем класс выделения сразу для текущего узла
        contentElement.classList.add('selected', 'multi-selected');
        
        // Обновляем классы для остальных выбранных узлов (кроме текущего)
        this.selectedNodes.forEach(id => {
            if (id !== node.id) {
                const nodeEl = document.querySelector(`[data-node-id="${id}"] .node-content`);
                if (nodeEl) {
                    nodeEl.classList.add('selected', 'multi-selected');
                }
            }
        });
        
        this.updateSelectionCounter();
        return;
    } 
    // Обычный выбор без Ctrl
    else {
        // Снимаем множественное выделение, если оно было
        if (this.multiSelectMode) {
            this.clearMultiSelection();
        }
        
        // Снимаем выделение с предыдущего выбранного узла
        if (this.selectedNode) {
            const prevContent = this.selectedNode.element.querySelector('.node-content');
            if (prevContent) prevContent.classList.remove('selected', 'multi-selected');
        }
        
        contentElement.classList.add('selected');
        contentElement.classList.remove('multi-selected');
        
        this.selectedNode = { node, element };
        this.selectedNodeId = node.id;
        this.updateSelectionCounter();
    }
}
updateClusterRemoveButton() {
    const removeBtn = this.elements.clusterSelect.parentNode.querySelector('.remove-from-cluster-btn');
    if (removeBtn) {
        const shouldShow = this.selectedNode && this.clusters.has(this.selectedNode.node.id);
        removeBtn.style.display = shouldShow ? 'inline-block' : 'none';
        
        if (shouldShow) {
            const clusterName = this.clusters.get(this.selectedNode.node.id);
            removeBtn.title = `Удалить из отдела "${clusterName}"`;
        }
    }
}
    // ⭐ Очистка множественного выделения
clearMultiSelection() {
    this.selectedNodes.forEach(id => {
        const nodeElement = document.querySelector(`[data-node-id="${id}"]`);
        if (nodeElement) {
            const content = nodeElement.querySelector('.node-content');
            if (content) {
                content.classList.remove('selected', 'multi-selected');
            }
        }
    });
    
    this.selectedNodes.clear();
    this.multiSelectMode = false;
    this.updateSelectionCounter();
    
    // Если есть выбранный узел - оставляем его стандартное выделение
    if (this.selectedNode) {
        const content = this.selectedNode.element.querySelector('.node-content');
        if (content) {
            content.classList.add('selected');
        }
    }
}

    renderVirtualizedTree() {
    // Расчет видимых узлов
    const visibleNodes = this.calculateVisibleNodes();
    
    // Очистка и рендеринг только видимых узлов
    this.elements.treeContainer.innerHTML = '';
    visibleNodes.forEach(node => {
        this.elements.treeContainer.appendChild(this.createNodeElement(node));
    });
}

calculateVisibleNodes() {
    // Логика определения узлов в viewport
    const visibleNodes = [];
    const walkTree = (node) => {
        if (this.isNodeVisible(node)) {
            visibleNodes.push(node);
            if (node.isExpanded) {
                node.children.forEach(walkTree);
            }
        }
    };
    walkTree(this.treeData);
    return visibleNodes;
}
updateSelectionCounter() {
    const count = this.selectedNodes.size;
    console.log('Updating selection counter. Selected nodes count:', count); // Отладка

    const deleteBtns = document.querySelectorAll('.node-action-btn.delete-btn');
    deleteBtns.forEach(btn => {
        if (count > 0) {
            btn.title = `Удалить (${count}) узлов`;
        } else {
            btn.title = 'Удалить узел';
        }
    });

    const addBtns = document.querySelectorAll('.node-action-btn.add-btn');
    addBtns.forEach(btn => {
        if (count > 0) {
            btn.title = `Добавить дочерний узел к (${count}) узлам`;
        } else {
            btn.title = 'Добавить дочерний узел';
        }
    });

    // Обновляем отображение количества выделенных узлов
    const selectedCountElement = document.getElementById('selectedCount');
    if (selectedCountElement) {
        console.log('Found selectedCount element:', selectedCountElement); // Отладка
        if (count > 0) {
            selectedCountElement.textContent = `Выделено: ${count}`;
            selectedCountElement.classList.add('visible');
            console.log('Showing counter with text:', selectedCountElement.textContent); // Отладка
        } else {
            selectedCountElement.classList.remove('visible');
            console.log('Hiding counter'); // Отладка
        }
    } else {
        console.error('selectedCount element not found in DOM'); // Отладка
    }
}
updateNode(node, nodeElement, skipHistory = false) {
    const countElement = nodeElement.querySelector('.children-count');
    if (countElement) {
        countElement.textContent = node.children.length;
    } else if (node.children.length > 0) {
        const newCountElement = document.createElement('div');
        newCountElement.className = 'children-count';
        newCountElement.textContent = node.children.length;
        nodeElement.querySelector('.node-content').appendChild(newCountElement);
    }

    // 1. Сохраняем историю, если не указано обратное
    if (!skipHistory) {
        this.saveToHistory();
    }

    // 2. Сохраняем позицию прокрутки перед обновлением
    this.saveScrollPosition();
    
    // 3. Создаем и заменяем элемент
    const newElement = this.createNodeElement(node);
    nodeElement.replaceWith(newElement);
    
    // 4. Восстанавливаем позицию прокрутки
    this.restoreScrollPosition();
    
    // 5. Обновляем ссылку на выбранный узел, если это он
    if (this.selectedNode && this.selectedNode.node.id === node.id) {
        this.selectedNode.element = newElement;
    }
}
addChild() {
    this.saveToHistory(); // Сохраняем состояние перед изменением
    if (!this.selectedNode && this.selectedNodes.size === 0) {
        alert('Выберите узел(ы)!');
        return;
    }

    let addedCount = 0;

    // Если есть множественное выделение, добавляем узел к каждому выделенному узлу
    if (this.selectedNodes.size > 0) {
        console.log('Adding child to multiple selected nodes:', this.selectedNodes.size);
        this.selectedNodes.forEach(nodeId => {
            const targetNode = this.findNode(this.treeData, nodeId);
            if (targetNode) {
                const newNode = this.createNewNode('Новый узел');
                targetNode.children.push(newNode);
                addedCount++;
                console.log(`Added child to node ${nodeId}`);
            } else {
                console.warn(`Node ${nodeId} not found for adding child`);
            }
        });
    } else {
        // Одиночное добавление к выбранному узлу
        console.log('Adding child to single selected node:', this.selectedNode.node.id);
        const newNode = this.createNewNode('Новый узел');
        this.selectedNode.node.children.push(newNode);
        addedCount = 1;
    }

    // Обнуляем выделение после добавления
    this.selectedNodes.clear();
    this.selectedNode = null;
    this.updateSelectionCounter(); // Обновляем счетчик и заголовки кнопок

    this.updateTree();
    this.saveData();
    this.showNotification(`Добавлено ${addedCount} новых узлов`);
}
showLayoutChangeNotification(node, useGrid) {
    const message = useGrid 
        ? `Узел "${node.content.text}" переключен в сеточный режим (${node.children.length} дочерних узлов)`
        : `Узел "${node.content.text}" в обычном режиме (${node.children.length} дочерних узлов)`;
    
    this.showNotification(message);
}
deleteNode() {
    this.saveToHistory();

    
    const nodeNames = [];
    const logActionAndDelete = (nodesSet) => {
        nodesSet.forEach(id => {
            const node = this.findNode(this.treeData, id);
            if (node) nodeNames.push(`"${node.content.text}"`);
        });

        if (nodeNames.length > 0) {
            this.logAction(`Удален узел(ы): ${nodeNames.join(', ')}`);
        }

        const removeNodeRecursive = (parent, idsToRemove) => {
            parent.children = parent.children.filter(child => {
                if (idsToRemove.has(child.id)) return false;
                removeNodeRecursive(child, idsToRemove);
                return true;
            });
        };
        removeNodeRecursive(this.treeData, nodesSet);
    };
    

    if (this.selectedNodes.size > 0) {
        if (!confirm(`Удалить ${this.selectedNodes.size} выбранных узлов?`)) return;
        logActionAndDelete(new Set(this.selectedNodes));
        this.clearMultiSelection();
        this.selectedNode = null;
        this.selectedNodeId = null;
    } else if (this.selectedNode) {
        if (!confirm('Удалить выбранный узел и все дочерние элементы?')) return;
        logActionAndDelete(new Set([this.selectedNode.node.id]));
        this.selectedNode = null;
        this.selectedNodeId = null;
    } else {
        alert('Выберите узел для удаления!');
        return;
    }

    this.updateTree();
    this.saveData();
    this.updateSelectionCounter();
}
deleteNodeAndPromoteChildren() {
    this.saveToHistory(false, true); 

    const nodesToProcess = this.selectedNodes.size > 0 ? new Set(this.selectedNodes) : new Set([this.selectedNode?.node.id]);
    if (nodesToProcess.size === 0 || (nodesToProcess.size === 1 && !this.selectedNode)) {
        this.showNotification('Выберите узел(ы) для удаления.', 'error');
        return;
    }

    if (!confirm(`Удалить ${nodesToProcess.size} узел(а/ов), но сохранить и поднять их дочерние элементы?`)) {
        return;
    }

    const nodeNames = [];
    let promotedCount = 0;

    nodesToProcess.forEach(nodeId => {
        const nodeToDelete = this.findNode(this.treeData, nodeId);
        if (!nodeToDelete) return;

        nodeNames.push(`"${nodeToDelete.content.text}"`);
        const parent = this.findParent(this.treeData, nodeId);

        if (parent) {
            const index = parent.children.findIndex(child => child.id === nodeId);
            if (index !== -1) {
                
                parent.children.splice(index, 1, ...nodeToDelete.children);
                promotedCount += nodeToDelete.children.length;
            }
        }
    });

    this.logAction(`Узел(ы) удален с повышением дочерних: ${nodeNames.join(', ')}`);
    this.clearMultiSelection();
    this.selectedNode = null;
    this.selectedNodeId = null;
    this.updateTree();
    this.saveData();
    this.showNotification(`Узел(ы) удалены, ${promotedCount} дочерних элементов поднято на уровень выше.`);
}


    removeImage(nodeId) {
        const node = this.findNode(this.treeData, nodeId);
        if(node && node.content.img) {
            node.content.img = null;
            this.cleanUnusedImages();
            this.updateTree();
            this.saveData();
        }
    }

    cleanUnusedImages() {
        const usedImages = new Set();
        const collectImages = (node) => {
            if(node.content.img) usedImages.add(node.content.img);
            node.children.forEach(collectImages);
        };
        collectImages(this.treeData);

        Object.keys(this.imagesData).forEach(key => {
            if(!usedImages.has(key)) {
                delete this.imagesData[key];
            }
        });
    }
async handleFileUpload(file, node) {
    if (!['application/vnd.openxmlformats-officedocument.spreadsheetml.sheet',
            'application/vnd.ms-excel',
            'application/msword',
            'application/vnd.openxmlformats-officedocument.wordprocessingml.document'].includes(file.type)) {
        alert('Пожалуйста, выберите XLSX или Word файл');
        return;
    }

    try {
        const fileId = 'file_' + Date.now() + '_' + Math.random().toString(36).substr(2, 9);
        const fileReader = new FileReader();

        fileReader.onload = (e) => {
            console.log('File loaded:', file.name, 'Size:', e.target.result.length);

            
            const fileData = {
                name: file.name,
                type: file.type,
                data: e.target.result,
                size: file.size,
                lastModified: file.lastModified || Date.now()
            };

            this.filesData[fileId] = fileData;

            
            if (!node.content.files) {
                node.content.files = [];
            }
            node.content.files.push(fileId);

            console.log('Files in node after upload:', node.content.files);
            console.log('Total files in filesData:', Object.keys(this.filesData).length);

            this.updateTree();
            this.saveData();

            
            this.showNotification(`Файл "${file.name}" успешно загружен`);
        };

        fileReader.onerror = (error) => {
            console.error('FileReader error:', error);
            alert('Ошибка чтения файла');
        };

        fileReader.readAsDataURL(file);

    } catch(error) {
        console.error('Error uploading file:', error);
        alert('Ошибка загрузки файла: ' + error.message);
    }
}

    async handleImageUpload(file, node) {
        if(!file.type.startsWith('image/')) {
            alert('Пожалуйста, выберите файл изображения');
            return;
        }

        try {
            const compressedImage = await this.compressImage(file);
            const imageId = 'img_' + Date.now() + '_' + Math.random().toString(36).substr(2, 9);
            
            this.imagesData[imageId] = compressedImage;
            node.content.img = imageId;
            this.updateTree();
            this.saveData();
            
            if(this.selectedNode) {
                this.selectedNode.element.classList.add('glow');
                setTimeout(() => 
                    this.selectedNode.element.classList.remove('glow'), 1000);
            }
        } catch(error) {
            alert('Ошибка обработки изображения: ' + error.message);
            node.content.img = null;
            this.updateTree();
        }
    }

    compressImage(file, quality = 0.6, maxWidth = 800) {
        return new Promise((resolve, reject) => {
            const img = new Image();
            img.src = URL.createObjectURL(file);
            
            img.onload = () => {
                const canvas = document.createElement('canvas');
                const ctx = canvas.getContext('2d');

                let width = img.width;
                let height = img.height;
                if(width > maxWidth) {
                    height = Math.round((height *= maxWidth / width));
                    width = maxWidth;
                }

                canvas.width = width;
                canvas.height = height;
                ctx.drawImage(img, 0, 0, width, height);

                canvas.toBlob(blob => {
                    const reader = new FileReader();
                    reader.onload = () => resolve(reader.result);
                    reader.onerror = reject;
                    reader.readAsDataURL(blob);
                }, 'image/jpeg', quality);
            };
            
            img.onerror = reject;
        });
    }

    showFullPreview(src) {
        this.elements.previewContainer.style.display = 'flex';
        this.elements.fullPreview.src = this.imagesData[src] || src;
        setTimeout(() => {
            this.elements.previewContainer.classList.add('preview-visible');
        }, 10);
    }

    hidePreview() {
        this.elements.previewContainer.classList.remove('preview-visible');
        setTimeout(() => {
            this.elements.previewContainer.style.display = 'none';
        }, 300);
    }

    uploadImage() {
        if(!this.selectedNode) return;
        
        const input = document.createElement('input');
        input.type = 'file';
        input.accept = 'image/*';
        input.onchange = (e) => {
            if(e.target.files[0]) this.handleImageUpload(e.target.files[0], this.selectedNode.node);
        };
        input.click();
    }
  
toggleTheme() {
  this.darkMode = !this.darkMode;
  document.documentElement.classList.toggle('dark', this.darkMode);
  localStorage.setItem('treeAppTheme', this.darkMode ? 'dark' : 'light');
  document.body.classList.add('fade-in');
  
  // Get mouse position or use center of screen
  const x = window.mouseX || window.innerWidth / 2;
  const y = window.mouseY || window.innerHeight / 2;
  
  // Create fireworks effect
  this.createFireworks(x, y);
  
  // Create flash effect
  const overlay = document.getElementById('themeTransitionOverlay');
  overlay.style.setProperty('--x', x + 'px');
  overlay.style.setProperty('--y', y + 'px');
  overlay.classList.add('active');
  
  setTimeout(() => {
    overlay.classList.remove('active');
    document.body.classList.remove('fade-in');
  }, 800);
}
hideImageIcon(nodeId) {
  const node = this.findNode(this.treeData, nodeId);
  if (node) {
    node.content.hideIcon = true;
    this.updateTree();
    this.saveData();
  }
}

hideDepartmentManagement() {
    this.departmentManagement.active = false;
    document.getElementById('departmentManagement').style.display = 'none';
    const styleElement = document.getElementById('department-management-styles');
    if (styleElement) {
        styleElement.remove();
    }

   
    if (this.departmentManagement.keyListeners) {
        document.removeEventListener('keydown', this.departmentManagement.keyListeners.down);
        delete this.departmentManagement.keyListeners;
    }

}
saveDeptHistory() {
    if (!this.departmentManagement.active) return;


    const currentState = {
        clusters: new Map(this.clusters),
        tree: JSON.parse(JSON.stringify(this.treeData))
    };

    this.departmentManagement.history.push(currentState);

    // Если история слишком большая, удаляем самые старые записи.
    if (this.departmentManagement.history.length > this.departmentManagement.maxHistory) {
        this.departmentManagement.history.shift();
    }
}
undoDeptChange() {
    if (this.departmentManagement.history.length === 0) {
        this.showNotification('Нет действий для отмены');
        return;
    }

    // ⭐ ИЗМЕНЕНИЕ: Восстанавливаем и кластеры, и состояние всего дерева.
    const lastState = this.departmentManagement.history.pop();
    this.clusters = new Map(lastState.clusters);
    this.treeData = lastState.tree; // Восстанавливаем дерево с его флагами 'needsClusterUpdate'

    // Перерисовываем окно, обновляем основное дерево и сохраняем изменения
    this.renderDepartmentManagement();
    this.updateTree();
    this.saveData();
    this.showNotification('Последнее действие отменено');
}
showDepartmentManagement() {
    this.injectDepartmentManagementStyles();
    this.departmentManagement.active = true;
    this.departmentManagement.history = [];
 this.departmentManagement.selectedNodesInDialog.clear();
    const modal = document.getElementById('departmentManagement');
    modal.style.display = 'flex';
    this.departmentManagement.activeDeputy = null;

    // ⭐ НОВОЕ: Добавляем подсказку для окна управления отделами
    const header = modal.querySelector('.department-header');
    if (header && !header.querySelector('.help-tooltip-trigger')) {
         this.setupHelpTooltips(header, 'departments');
    }

    const handleKeyDown = (e) => {
        if (this.departmentManagement.active && (e.key.toLowerCase() === 'z' || e.key.toLowerCase() === 'я')) {
            e.preventDefault();
            this.undoDeptChange();
        }
    };

    this.departmentManagement.keyListeners = {
        down: handleKeyDown
    };
    document.addEventListener('keydown', this.departmentManagement.keyListeners.down);

    // Добавляем обработчик для Ctrl+Click в управлении отделами
    const handleCtrlClick = (e) => {
        if (this.departmentManagement.active && e.ctrlKey) {
            // Предотвращаем стандартное поведение браузера
            e.preventDefault();
        }
    };

    document.addEventListener('click', handleCtrlClick);

    this.renderDepartmentManagement();
}

setupHelpTooltips(container, context) {
    // Внедряем стили один раз
    if (!document.getElementById('help-tooltip-styles')) {
        const style = document.createElement('style');
        style.id = 'help-tooltip-styles';
        style.textContent = `
            .help-tooltip-trigger {
                display: inline-flex;
                align-items: center;
                justify-content: center;
                width: 24px;
                height: 24px;
                border-radius: 50%;
                background: var(--secondary-color);
                color: white;
                cursor: pointer;
                font-weight: bold;
                margin-left: 10px;
                user-select: none;
                position: relative;
            }
            .help-tooltip-content {
                display: none;
                position: absolute;
                top: 100%; 
                right: 0;
                margin-top: 8px;
                background: var(--controls-bg);
                border: 1px solid var(--primary-color);
                border-radius: 8px;
                padding: 15px;
                box-shadow: 0 4px 12px rgba(0,0,0,0.15);
                /* ⭐ ИЗМЕНЕНИЕ ЗДЕСЬ: Добавляем !important для гарантии */
                min-width: 450px !important;
                max-width: 600px !important;
                z-index: 10001;
                text-align: left;
                color: var(--text-color);
            }
            .help-tooltip-trigger:hover .help-tooltip-content {
                display: block;
            }
            .help-tooltip-content h4 {
                margin-top: 0;
                color: var(--primary-color);
            }
            .help-tooltip-content ul {
                padding-left: 20px;
                margin: 0;
            }
            .help-tooltip-content li {
                margin-bottom: 8px;
            }
            .help-tooltip-content code {
                background: rgba(93, 138, 168, 0.15);
                padding: 2px 5px;
                border-radius: 4px;
                font-family: monospace;
            }
        `;
        document.head.appendChild(style);
    }

    const trigger = document.createElement('div');
    trigger.className = 'help-tooltip-trigger';
    trigger.textContent = '?';

    const tooltipContent = document.createElement('div');
    tooltipContent.className = 'help-tooltip-content';

    let contentHTML = '';
    if (context === 'main') {
        contentHTML = `
            <h4>Горячие клавиши (Дерево)</h4>
            <ul>
                <li><code>Ctrl + C</code> — Копировать без вырезания/Вырезать узел (на выбор 3 варианта)</li>
                <li><code>Ctrl + V</code> — Вставить узел рядом</li>
                <li><code>Ctrl + F</code> — Вставить как дочерний узел (внутрь выбранного узла)</li>
                <li><code>Ctrl + G</code> — Вставить как родительский узел (скопированный узел становится подчинененным узлом, работает только для одиночного копирования)</li>
                <li><code>Ctrl + R</code> — Заменить узел (сохраняя дочерние, работает только для одиночного копирования)</li>
                <li><code>Ctrl + E</code> — Реструктуризация ветки (переносим необходимые узлы, меняется иерархия узлов)</li>
                <li><code>Ctrl + Z</code> — Отменить последнее действие</li>
                <li><code>Ctrl + Клик</code> — Множественное выделение </li>
                <li><code>Esc</code> — Сбросить выделение / Очистить буфер обмена</li>
            </ul>
        `;
    } else if (context === 'departments') {
        contentHTML = `
            <h4>Горячие клавиши (Отделы)</h4>
            <ul>
                <li><code>Z</code> — Отменить последнее изменение в отделах</li>
                 <li><code>ЛКМ по узлу</code> — Перенести узел</li>
                  <li><code>ПКМ по узлу</code> — Удалить узел</li>
            </ul>
        `;
    }

    tooltipContent.innerHTML = contentHTML;
    trigger.appendChild(tooltipContent);
    container.appendChild(trigger);
}
injectDepartmentManagementStyles() {
    if (document.getElementById('department-management-styles')) {
        return;
    }

    const style = document.createElement('style');
    style.id = 'department-management-styles';
    style.textContent = `
        .dept-view-node-content.needs-update {
            border: 2px solid #ff4444 !important;
            box-shadow: 0 0 8px rgba(255, 68, 68, 0.5);
        }
        .deputy-card {
            cursor: pointer;
            padding: 20px 25px;
            border: 2px solid var(--primary-color);
            border-radius: 12px;
            width: 320px;
            max-width: 320px;
            flex: 0 0 auto;
            text-align: center;
            user-select: none;
            transition: all 0.3s ease;
            background: var(--node-bg);
            box-shadow: 0 4px 8px rgba(0,0,0,0.1);
            font-size: 1.1em;
            font-weight: 500;
            color: var(--text-color);
        }
        .deputy-card:hover {
            transform: translateY(-5px);
            box-shadow: 0 8px 16px rgba(93, 138, 168, 0.2);
            border-color: var(--secondary-color);
        }
        .dept-view-copy-btn {
            cursor: pointer;
            background: none;
            border: none;
            font-size: 1.2em;
            padding: 0 5px;
            line-height: 1;
            transition: transform 0.2s, color 0.2s;
            color: var(--secondary-color);
            opacity: 0.7;
        }
        .dept-view-copy-btn:hover {
            transform: scale(1.2);
            opacity: 1;
        }
        .dept-view-node-content {
            position: relative;
            display: flex;
            align-items: center;
            gap: 8px;
            padding: 6px 8px;
            border-radius: 8px;
            transition: all 0.2s ease-in-out;
            border: 2px solid transparent;
            margin: 2px 0;
        }
        .dept-view-node-content.is-clustered {
            border-color: var(--primary-color);
            background-color: rgba(93, 138, 168, 0.05);
        }
        .dept-view-node-content:hover {
            background-color: rgba(93, 138, 168, 0.1);
        }
        .dept-view-controls {
            position: absolute;
            right: 8px;
            top: 50%;
            transform: translateY(-50%);
            display: flex;
            align-items: center;
            gap: 5px;
            opacity: 0;
            transition: opacity 0.2s ease-in-out;
            background-color: var(--controls-bg);
            padding: 4px;
            border-radius: 6px;
        }
        .dept-view-node-content:hover .dept-view-controls {
            opacity: 1;
        }
        .dept-view-btn {
            cursor: pointer;
            background: none;
            border: none;
            font-size: 1.4em;
            padding: 0;
            line-height: 1;
            transition: transform 0.2s, color 0.2s;
            width: 22px;
            height: 22px;
            display: flex;
            align-items: center;
            justify-content: center;
        }
        .dept-view-btn:hover {
            transform: scale(1.2);
        }
        .dept-view-remove-cluster {
            color: #5D8AA8;
        }
        .dept-view-remove-cluster:hover {
            color: #ff4444;
        }
        .dept-view-add-cluster {
            color: #388E3C;
        }
        .dept-view-add-cluster:hover {
            color: #4CAF50;
        }
        .dept-view-cluster-select {
            font-size: 0.85em;
            padding: 2px 4px;
            border-radius: 4px;
            border: 1px solid var(--primary-color);
            background-color: var(--controls-bg);
            color: var(--text-color);
            max-width: 150px;
        }
        .dept-view-text-container {
            display: flex;
            flex-direction: column;
            align-items: flex-start;
            flex-grow: 1;
            overflow: hidden;
        }
        .dept-view-node-name {
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
            max-width: 100%;
            font-weight: 600;
        }
        .dept-view-cluster-tag {
            font-size: 0.8em;
            padding: 2px 6px;
            background-color: rgba(93, 138, 168, 0.2);
            border-radius: 4px;
            color: var(--primary-color);
            font-weight: 500;
            margin-top: 4px;
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
            max-width: 250px;
        }
        .dept-view-copy-btn {
            color: var(--secondary-color);
            opacity: 0.7;
        }
        .dept-view-copy-btn:hover {
            transform: scale(1.2);
            opacity: 1;
        }
        .dept-view-checkbox:checked {
            background-color: var(--accent-color);
            border-color: var(--accent-color);
        }
        .dept-view-node-content.selected-descendant {
            background-color: rgba(255, 160, 122, 0.2);
        }
    `;
    document.head.appendChild(style);
}
renderDepartmentManagement() {
    const container = document.getElementById('departmentContainer');
    const currentFilterValue = container.querySelector('.department-management-tree-view-filter')?.value || '';

    container.innerHTML = '';
    container.style.display = 'block';
    container.style.overflowY = 'auto';

    const root = this.treeData;

    if (!this.departmentManagement.activeDeputy) {
        let targetNode = null;
        root.children.forEach(level1Node => {
            if (targetNode) return;
            level1Node.children.forEach(level2Node => {
                if (level2Node.content.text === "Иванова Марина Владимировна") {
                    targetNode = level2Node;
                }
            });
        });

        if (!targetNode) {
            container.textContent = 'Узел "Иванова Марина Владимировна" на 2 уровне не найден';
            return;
        }

        const list = document.createElement('div');
        list.classList.add('deputies-list');
        const card = document.createElement('div');
        card.textContent = targetNode.content.text;
        card.classList.add('deputy-card');
        card.addEventListener('click', () => {
            this.departmentManagement.activeDeputy = targetNode.id;
            this.renderDepartmentManagement();
        });
        list.appendChild(card);
        container.appendChild(list);

    } else {
        const headerContainer = document.createElement('div');
        headerContainer.style.cssText = 'display: flex; justify-content: space-between; align-items: center; margin-bottom: 15px; flex-wrap: wrap; gap: 10px;';

        const backBtn = document.createElement('button');
        backBtn.textContent = '← Назад';
        backBtn.style.cssText = 'padding: 6px 12px; border: 1px solid var(--primary-color); border-radius: 6px; cursor: pointer;';
        backBtn.addEventListener('click', () => {
            this.departmentManagement.activeDeputy = null;
            this.renderDepartmentManagement();
        });
        headerContainer.appendChild(backBtn);

        const searchInput = document.createElement('input');
        searchInput.type = 'text';
        searchInput.placeholder = 'Фильтр по узлам...';
        searchInput.className = 'department-management-tree-view-filter';
        searchInput.style.cssText = `
            padding: 6px 10px;
            border: 1px solid var(--primary-color);
            border-radius: 6px;
            flex: 1;
            min-width: 200px;
            max-width: 400px;
        `;
        searchInput.value = currentFilterValue;
        headerContainer.appendChild(searchInput);

        const selectAllBtn = document.createElement('button');
        selectAllBtn.textContent = 'Выделить/Снять все';
        selectAllBtn.style.cssText = `
            padding: 6px 12px;
            border: 1px solid var(--primary-color);
            border-radius: 6px;
            cursor: pointer;
        `;
        selectAllBtn.addEventListener('click', () => {
            const treeView = container.querySelector('.department-management-tree-view');
            const visibleCheckboxes = treeView ? Array.from(treeView.querySelectorAll('.dept-view-checkbox')) : [];
            const allSelected = visibleCheckboxes.length > 0 && visibleCheckboxes.every(cb => cb.checked);
            visibleCheckboxes.forEach(checkbox => {
                checkbox.checked = !allSelected;
            });
        });
        headerContainer.appendChild(selectAllBtn);

        const showNewBtn = document.createElement('button');
        showNewBtn.style.cssText = `
            padding: 6px 12px;
            border: 1px solid var(--primary-color);
            border-radius: 6px;
            cursor: pointer;
            transition: all 0.2s ease;
        `;

        if (this.uiSettings.showNewNodesOnly) {
            showNewBtn.textContent = 'Сбросить фильтр';
            showNewBtn.style.background = 'var(--accent-color)';
            showNewBtn.style.color = 'white';
        } else {
            showNewBtn.textContent = 'Показать новые';
            showNewBtn.style.background = 'transparent';
            showNewBtn.style.color = 'var(--text-color)';
        }

        showNewBtn.addEventListener('click', () => {
            this.uiSettings.showNewNodesOnly = !this.uiSettings.showNewNodesOnly;
            this.saveData();
            this.renderDepartmentManagement();
        });
        headerContainer.appendChild(showNewBtn);

        const collapseBtn = document.createElement('button');
        collapseBtn.textContent = 'Свернуть все';
        collapseBtn.style.cssText = 'padding: 6px 12px; border: 1px solid var(--primary-color); border-radius: 6px; cursor: pointer;';
        collapseBtn.addEventListener('click', () => {
            const selectedNode = this.findNode(root, this.departmentManagement.activeDeputy);
            if (selectedNode) {
                this.collapseAllInDeptManagement(selectedNode);
                this.renderDepartmentManagement();
            }
        });
        headerContainer.appendChild(collapseBtn);

        container.appendChild(headerContainer);

        const selectedNode = this.findNode(root, this.departmentManagement.activeDeputy);
        if (!selectedNode) {
            container.textContent = 'Узел не найден';
            return;
        }

        const header = document.createElement('h2');
        header.textContent = `Структура отделов: ${selectedNode.content.text}`;
        header.style.cssText = 'margin: 15px 0; text-align: center;';
        container.appendChild(header);

        const treeViewContainer = document.createElement('div');
        treeViewContainer.className = 'department-management-tree-view';
        treeViewContainer.style.cssText = 'border: 1px solid var(--primary-color); border-radius: 8px; padding: 15px; background: rgba(93, 138, 168, 0.05);';
        container.appendChild(treeViewContainer);

        const redrawFilteredTree = () => {
            const filterText = searchInput.value.toLowerCase().trim();
            treeViewContainer.innerHTML = '';
            selectedNode.children.forEach(child => {
                this.renderDepartmentNodeRecursive(child, treeViewContainer, 0, filterText);
            });
        };

        searchInput.addEventListener('input', redrawFilteredTree);
        redrawFilteredTree();
    }
}
renderDepartmentNodeRecursive(node, parentElement, level, filterText = '', ancestorMatches = false) {
    const showNewOnly = this.uiSettings.showNewNodesOnly;

    const isNewNode = !this.clusters.has(node.id);

    const hasNewDescendant = (n) => {
        if (!this.clusters.has(n.id)) return true;
        return n.children && n.children.some(hasNewDescendant);
    };

    const matchesNewFilter = !showNewOnly || isNewNode || hasNewDescendant(node);

    const currentNodeMatches = filterText ? this.nodeMatchesSearch(node, filterText, true) : true;
    const hasVisibleChild = filterText ? this.isParentOfMatch(node, filterText, true) : false;

    if ((filterText && !currentNodeMatches && !hasVisibleChild && !ancestorMatches) || !matchesNewFilter) {
        return;
    }

    const nodeElement = document.createElement('div');
    nodeElement.className = 'dept-view-node';
    nodeElement.style.marginLeft = `${level * 20}px`;
    nodeElement.dataset.nodeId = node.id;

    const nodeContent = document.createElement('div');
    nodeContent.className = 'dept-view-node-content';

    if (!this.clusters.has(node.id)) {
        nodeContent.classList.add('needs-update');
    }

    if (this.clusters.has(node.id)) {
        nodeContent.classList.add('is-clustered');
    }

    if (node.needsClusterUpdate && !node.circularlyReplaced) {
        nodeContent.classList.add('needs-update');
    }

    const checkbox = document.createElement('input');
    checkbox.type = 'checkbox';
    checkbox.className = 'dept-view-checkbox';
    checkbox.style.marginRight = '8px';
    checkbox.dataset.nodeId = node.id;

    const isInitiallySelected = this.departmentManagement.selectedNodesInDialog.has(node.id);
    checkbox.checked = isInitiallySelected;
    if (isInitiallySelected) {
        nodeContent.style.backgroundColor = 'var(--primary-color)';
        nodeContent.style.color = 'white';
        nodeContent.style.borderRadius = '5px';
        const nodeName = nodeContent.querySelector('.dept-view-node-name');
        const expandIcon = nodeContent.querySelector('.dept-view-expand');
        const clusterTag = nodeContent.querySelector('.dept-view-cluster-tag');
        if (nodeName) nodeName.style.color = 'white';
        if (expandIcon) expandIcon.style.color = 'white';
        if (clusterTag) clusterTag.style.color = 'white';
    }

    const updateGlobalSelectionSet = (startNode, add, recursive = false) => {
        if (add) {
            this.departmentManagement.selectedNodesInDialog.add(startNode.id);
        } else {
            this.departmentManagement.selectedNodesInDialog.delete(startNode.id);
        }
        if (recursive && startNode.children) {
            startNode.children.forEach(child => updateGlobalSelectionSet(child, add, true));
        }
    };

    checkbox.addEventListener('click', e => {
        e.stopPropagation();
        const isChecked = checkbox.checked;
        const isRecursive = e.ctrlKey;

        this.updateDepartmentNodeSelectionVisuals(node, isChecked, isRecursive);
        updateGlobalSelectionSet(node, isChecked, isRecursive);
    });

    nodeContent.addEventListener('click', (e) => {
        if (e.target !== checkbox && !e.target.closest('.dept-view-controls')) {
            checkbox.checked = !checkbox.checked;
            const clickEvent = new MouseEvent('click', {
                bubbles: true,
                cancelable: true,
                ctrlKey: e.ctrlKey
            });
            checkbox.dispatchEvent(clickEvent);
        }
    });

    nodeContent.appendChild(checkbox);

    const expandIcon = document.createElement('span');
    expandIcon.className = 'dept-view-expand';
    if (node.children && node.children.length > 0) {
        expandIcon.textContent = (filterText || showNewOnly || node.isExpanded) ? '▼' : '▶';
    } else {
        expandIcon.textContent = '•';
        expandIcon.style.cursor = 'default';
    }
    nodeContent.appendChild(expandIcon);

    const textContainer = document.createElement('div');
    textContainer.className = 'dept-view-text-container';
    const nodeText = document.createElement('span');
    nodeText.className = 'dept-view-node-name';
    nodeText.textContent = node.content.text;
    textContainer.appendChild(nodeText);

    const clusterName = this.clusters.get(node.id);

    if (clusterName) {
        const clusterTagContainer = document.createElement('div');
        clusterTagContainer.style.display = 'flex';
        clusterTagContainer.style.alignItems = 'center';
        clusterTagContainer.style.gap = '5px';

        const clusterTag = document.createElement('span');
        clusterTag.className = 'dept-view-cluster-tag';
        clusterTag.textContent = clusterName;
        clusterTagContainer.appendChild(clusterTag);

        // --- ✨ ВОТ ИЗМЕНЕНИЕ: Добавляем кнопку копирования ✨ ---
        const copyBtn = document.createElement('button');
        copyBtn.className = 'dept-view-copy-btn';
        copyBtn.innerHTML = '⎘'; // Unicode-символ для копирования
        copyBtn.title = `Копировать: "${clusterName}"`;
        copyBtn.addEventListener('click', (e) => {
            e.stopPropagation();
            this.copyToClipboard(clusterName);
        });
        clusterTagContainer.appendChild(copyBtn);
        // --- ✨ КОНЕЦ ИЗМЕНЕНИЯ ✨ ---

        textContainer.appendChild(clusterTagContainer);
    }
    nodeContent.appendChild(textContainer);

    const controlsContainer = document.createElement('div');
    controlsContainer.className = 'dept-view-controls';

    const handleClusterAction = (action, ...args) => {
        const modal = document.getElementById('departmentManagement');
        const checkedBoxes = modal.querySelectorAll('.dept-view-checkbox:checked');
        const selectedNodes = new Set();

        if (checkedBoxes.length > 0) {
            checkedBoxes.forEach(cb => {
                selectedNodes.add(parseInt(cb.dataset.nodeId, 10));
            });
        } else {
            selectedNodes.add(node.id);
        }

        if (selectedNodes.size > 0) {
            action(selectedNodes, ...args);
        }
    };

    if (this.clusters.has(node.id)) {
        const select = document.createElement('select');
        select.className = 'dept-view-cluster-select';
        this.availableClusters.forEach(cluster => {
            const option = document.createElement('option');
            option.value = cluster;
            option.textContent = cluster;
            if (cluster === this.clusters.get(node.id)) option.selected = true;
            select.appendChild(option);
        });
        select.addEventListener('click', e => e.stopPropagation());
        select.addEventListener('change', (e) => {
            const newCluster = e.target.value;
            this.saveDeptHistory();
            handleClusterAction((nodes) => {
                nodes.forEach(id => this.addNodeToCluster(id, newCluster));
                this.showNotification(`${nodes.size} узл(а/ов) перемещено в отдел "${newCluster}"`);
                this.renderDepartmentManagement();
            });
        });
        controlsContainer.appendChild(select);

        const removeBtn = document.createElement('button');
        removeBtn.className = 'dept-view-btn dept-view-remove-cluster';
        removeBtn.innerHTML = '✘';
        removeBtn.title = `Удалить из отдела "${this.clusters.get(node.id)}"`;
        removeBtn.addEventListener('click', (e) => {
            e.stopPropagation();
            this.saveDeptHistory();
            handleClusterAction((nodes) => {
                nodes.forEach(id => this.clusters.delete(id));
                this.showNotification(`${nodes.size} узл(а/ов) удалено из отдела`);
                this.renderDepartmentManagement();
            });
        });
        controlsContainer.appendChild(removeBtn);

    } else {
        const addBtn = document.createElement('button');
        addBtn.className = 'dept-view-btn dept-view-add-cluster';
        addBtn.innerHTML = '➕';
        addBtn.title = 'Добавить в новый отдел';
        addBtn.addEventListener('click', (e) => {
            e.stopPropagation();
            const newClusterName = prompt('Введите название нового отдела:');
            if (newClusterName && newClusterName.trim()) {
                this.saveDeptHistory();
                handleClusterAction((nodes) => {
                    nodes.forEach(id => this.addNodeToCluster(id, newClusterName.trim()));
                    this.renderDepartmentManagement();
                });
            }
        });
        controlsContainer.appendChild(addBtn);
    }

    nodeContent.appendChild(controlsContainer);
    nodeElement.appendChild(nodeContent);
    parentElement.appendChild(nodeElement);

    const childrenContainer = document.createElement('div');
    childrenContainer.className = 'dept-view-children';
    if (!node.isExpanded && !showNewOnly) {
        childrenContainer.style.display = 'none';
    }
    nodeElement.appendChild(childrenContainer);

    expandIcon.addEventListener('click', (e) => {
        e.stopPropagation();
        if (node.children && node.children.length > 0) {
            node.isExpanded = !node.isExpanded;
            childrenContainer.style.display = node.isExpanded ? 'block' : 'none';
            expandIcon.textContent = node.isExpanded ? '▼' : '▶';
        }
    });

    if (node.children) {
        node.children.forEach(child => {
            this.renderDepartmentNodeRecursive(child, childrenContainer, level + 1, filterText, ancestorMatches || currentNodeMatches);
        });
    }
}
updateDepartmentNodeSelectionVisuals(node, isSelected, recursive = false) {
    const nodeElement = document.querySelector(`.dept-view-node[data-node-id="${node.id}"]`);
    if (nodeElement) {
        const checkbox = nodeElement.querySelector('.dept-view-checkbox');
        const nodeContent = nodeElement.querySelector('.dept-view-node-content');

        if (checkbox) {
            checkbox.checked = isSelected;
        }

        if (isSelected) {
            nodeContent.style.backgroundColor = 'var(--primary-color)';
            nodeContent.style.color = 'white';
            nodeContent.style.borderRadius = '5px';
            const nodeName = nodeContent.querySelector('.dept-view-node-name');
            const expandIcon = nodeContent.querySelector('.dept-view-expand');
            const clusterTag = nodeContent.querySelector('.dept-view-cluster-tag');

            if (nodeName) nodeName.style.color = 'white';
            if (expandIcon) expandIcon.style.color = 'white';
            if (clusterTag) clusterTag.style.color = 'white';
        } else {
            nodeContent.style.backgroundColor = '';
            nodeContent.style.color = '';
            nodeContent.style.borderRadius = '';
            const nodeName = nodeContent.querySelector('.dept-view-node-name');
            const expandIcon = nodeContent.querySelector('.dept-view-expand');
            const clusterTag = nodeContent.querySelector('.dept-view-cluster-tag');

            if (nodeName) nodeName.style.color = '';
            if (expandIcon) expandIcon.style.color = '';
            if (clusterTag) clusterTag.style.color = '';
        }
    }

    // Рекурсия применяется только если флаг 'recursive' равен true
    if (recursive && node.children) {
        node.children.forEach(child => {
            this.updateDepartmentNodeSelectionVisuals(child, isSelected, true);
        });
    }
}
performMultiTargetRestructure(groups) {
    this.saveToHistory(false, true);

    let totalMoved = 0;
    let totalDeleted = 0;
    groups.forEach(group => {
        group.state.forEach((state) => {
            if (state === 'move') totalMoved++;
            if (state === 'delete') totalDeleted++;
        });
    });

    const logParts = [];
    if (totalMoved > 0) logParts.push(`перемещено ${totalMoved} узлов`);
    if (totalDeleted > 0) logParts.push(`удалено ${totalDeleted} узлов`);
    if (logParts.length > 0) {
        this.logAction(`Реструктуризация: ${logParts.join(', ')}.`);
    }

    const allNodesToModify = new Set();
    const nodesToDelete = new Set();
    const moveOperations = [];
    let errorOccurred = false;

    groups.forEach((group, index) => {
        if (errorOccurred) return;
        const nodesToMoveInGroup = new Set();
        group.state.forEach((state, id) => {
            allNodesToModify.add(id);
            if (state === 'delete') {
                nodesToDelete.add(id);
            } else if (state === 'move') {
                nodesToMoveInGroup.add(id);
            }
        });

        if (nodesToMoveInGroup.size > 0) {
            if (!group.targetId) {
                this.showNotification(`Не выбран целевой узел для Группы №${index + 1}`, 'error');
                errorOccurred = true;
                return;
            }
            moveOperations.push({
                nodes: nodesToMoveInGroup,
                targetId: group.targetId
            });
        }
    });

    if (errorOccurred) return;

    nodesToDelete.forEach(id => allNodesToModify.add(id));

    moveOperations.forEach(op => {
        op.hierarchy = this.buildPreservedHierarchy(op.nodes);
    });

    const newRootChildren = [];
    this.treeData.children.forEach(child => {
        const result = this.restructureAndPruneTree(child, allNodesToModify);
        newRootChildren.push(...result);
    });
    this.treeData.children = newRootChildren;

    moveOperations.forEach(op => {
        const targetNode = this.findNode(this.treeData, op.targetId);
        if (targetNode) {
            if (!targetNode.children) {
                targetNode.children = [];
            }
            targetNode.children.push(...op.hierarchy);
            targetNode.isExpanded = true;

            // --- ИЗМЕНЕНИЕ ЗДЕСЬ ---
            // Получаем кластер целевого узла для текущей операции
            const targetCluster = this.clusters.get(targetNode.id);
            // Рекурсивно применяем его ко всем перемещенным узлам и их детям в этой операции
            this.recursivelyUpdateCluster(op.hierarchy, targetCluster);
            // --- КОНЕЦ ИЗМЕНЕНИЯ ---

        } else {
            console.error(`Критическая ошибка: Целевой узел с ID ${op.targetId} не найден после удаления веток.`);
        }
    });

    this.updateTree();
    this.saveData();
    this.showNotification('Реструктуризация успешно выполнена.');
}
performRestructure(selectedNodesWithState, targetId) {
    const nodesToMoveIds = new Set();
    const nodesToDeleteIds = new Set();
    selectedNodesWithState.forEach((state, id) => {
        if (state === 'move') {
            nodesToMoveIds.add(id);
        } else if (state === 'delete') {
            nodesToDeleteIds.add(id);
        }
    });

    if (nodesToMoveIds.size === 0 && nodesToDeleteIds.size === 0) {
        this.showNotification('Не выбраны узлы для переноса или удаления.', 'error');
        return;
    }
    if (nodesToMoveIds.size > 0 && !targetId) {
        this.showNotification('Не выбран целевой узел для вставки.', 'error');
        return;
    }
    const targetNodeOriginal = this.findNode(this.treeData, targetId);
    if (nodesToMoveIds.size > 0 && !targetNodeOriginal) {
        this.showNotification('Целевой узел не найден.', 'error');
        return;
    }

    this.saveToHistory(false, true);

    // --- ✨ НАЧАЛО ИЗМЕНЕНИЙ: Логирование действия ---
    const logParts = [];
    if (nodesToMoveIds.size > 0) logParts.push(`перемещено ${nodesToMoveIds.size} узлов`);
    if (nodesToDeleteIds.size > 0) logParts.push(`удалено ${nodesToDeleteIds.size} узлов`);
    if (logParts.length > 0) {
        this.logAction(`Реструктуризация: ${logParts.join(', ')}.`);
    }
    // --- ✨ КОНЕЦ ИЗМЕНЕНИЙ ---

    const movedHierarchy = this.buildPreservedHierarchy(nodesToMoveIds);
    const allSelectedIds = new Set([...nodesToMoveIds, ...nodesToDeleteIds]);

    const newRootChildren = [];
    this.treeData.children.forEach(child => {
        const result = this.restructureAndPruneTree(child, allSelectedIds);
        newRootChildren.push(...result);
    });
    this.treeData.children = newRootChildren;

    if (targetNodeOriginal && movedHierarchy.length > 0) {
        const targetNodeInNewTree = this.findNode(this.treeData, targetId);
        if (targetNodeInNewTree) {
            targetNodeInNewTree.children.push(...movedHierarchy);
            targetNodeInNewTree.isExpanded = true;
        } else {
            console.error("Критическая ошибка: целевой узел не найден после перестройки дерева.");
            this.showNotification('Ошибка: целевой узел исчез после удаления веток.', 'error');
            return;
        }
    }

    this.updateTree();
    this.saveData();
    this.showNotification('Реструктуризация успешно выполнена.');
}
hasClusteredDescendants(node) {
    for (const child of node.children) {
        if (this.clusters.has(child.id) || this.hasClusteredDescendants(child)) {
            return true;
        }
    }
    return false;
}
collapseAllInDeptManagement(node) {
    node.isExpanded = false;
    if (node.children) {
        // Рекурсивный вызов для каждого дочернего элемента
        node.children.forEach(child => this.collapseAllInDeptManagement(child));
    }
}
async promptForClusterUpdate(node) {
    const clusterList = Array.from(this.availableClusters).sort().join('\n');
    const newCluster = prompt(
        `Узел "${node.content.text}" был перемещен.\n\nВыберите новый отдел из списка или введите название нового:\n\n${clusterList}`,
        this.clusters.get(node.id) || ''
    );

    if (newCluster !== null && newCluster.trim()) {
        const clusterName = newCluster.trim();
        this.clusters.set(node.id, clusterName);
        if (!this.availableClusters.has(clusterName)) {
            this.availableClusters.add(clusterName);
        }
        delete node.needsClusterUpdate;

        this.showNotification(`Узел "${node.content.text}" перемещен в отдел "${clusterName}"`);
        this.renderDepartmentManagement();
        this.updateTree();
        this.saveData();
    }
}
getShortName(fullName, maxWords = 2) {
  const words = fullName.split(' ');
  if (words.length <= maxWords) return fullName;
  return words.slice(0, maxWords).join(' ') + '...';
}
getGroupsInCluster(clusterName) {
    const groups = new Set();
    this.clusters.forEach((cluster, nodeId) => {
        if (cluster === clusterName) {
            const node = this.findNode(this.treeData, nodeId);
            if (node) {
                groups.add(nodeId);
            }
        }
    });
    return Array.from(groups);
}
createGroupElement(groupId, clusterName) {
  const node = this.findNode(this.treeData, groupId);
  if (!node) return null;

  const groupElement = document.createElement('div');
  groupElement.className = 'department-group';
  groupElement.dataset.id = groupId;
  groupElement.dataset.cluster = clusterName;
  groupElement.draggable = true;

  // Заголовок группы с подсказкой
  const groupHeader = document.createElement('div');
  groupHeader.textContent = this.getShortName(node.content.text, 4);
  groupHeader.title = node.content.text;
  groupElement.appendChild(groupHeader);

  // Элементы группы
  node.children.forEach(child => {
    // Создаём контейнер для элемента и подписи
    const itemContainer = document.createElement('div');
    itemContainer.style.display = 'flex';
    itemContainer.style.flexDirection = 'column';
    itemContainer.style.alignItems = 'center';
    itemContainer.style.marginBottom = '8px'; // Отступ между элементами

    const itemElement = document.createElement('div');
    itemElement.className = 'department-item';
    itemElement.textContent = this.getShortName(child.content.text, 4);
    itemElement.title = child.content.text;
    itemElement.dataset.id = child.id;
    itemElement.dataset.parent = groupId;
    itemElement.draggable = true;

    let typeKey = null;
    if (child.content.isSubordinate) typeKey = 'должностные регламенты';
    else if (child.content.isIndicator) typeKey = 'государственная программа';
    else if (child.content.isOKR) typeKey = 'окр';
    else if (child.content.absent269) typeKey = 'отсутствует в 269-п';
    else if (child.content.isPower269) typeKey = 'полномочие из 269-п';
    else if (child.content.isForAll) typeKey = 'для всех сотрудников';
    else if (child.content.isAuthority) typeKey = 'идентичное полномочие';

    if (typeKey && NODE_TYPE_COLORS[typeKey]) {
      itemElement.style.border = `2px solid ${NODE_TYPE_COLORS[typeKey]}`;
      itemElement.style.borderRadius = '4px';
      itemElement.style.padding = '4px 8px';
      itemElement.style.backgroundColor = '#222'; // тёмный фон
      itemElement.style.color = 'white';
      itemElement.style.textAlign = 'center';
      itemElement.style.minWidth = '120px'; // чтобы подпись не съезжала

      // Создаём подпись под элементом
      const abbr = document.createElement('div');
      abbr.textContent = NODE_TYPE_ABBREVIATIONS[typeKey] || '';
      abbr.style.fontSize = '10px';
      abbr.style.color = 'white';
      abbr.style.marginTop = '4px';
      abbr.style.userSelect = 'none';
      abbr.style.fontWeight = 'bold';
      abbr.style.textAlign = 'center';

      // Добавляем item и подпись в контейнер
      itemContainer.appendChild(itemElement);
      itemContainer.appendChild(abbr);
    } else {
      // Если нет типа, просто добавляем элемент
      itemContainer.appendChild(itemElement);
    }

    // Обработчики перетаскивания
    itemElement.addEventListener('dragstart', (e) => {
      this.departmentManagement.draggedItem = child.id;
      this.departmentManagement.draggedType = 'item';
      this.departmentManagement.sourceCluster = clusterName;
      e.dataTransfer.effectAllowed = 'move';
    });

    groupElement.appendChild(itemContainer);
  });

  // Обработчики перетаскивания для группы
  groupElement.addEventListener('dragstart', (e) => {
    this.departmentManagement.draggedItem = groupId;
    this.departmentManagement.draggedType = 'group';
    this.departmentManagement.sourceCluster = clusterName;
    e.dataTransfer.effectAllowed = 'move';
  });

  return groupElement;
}
showTooltip(element, text) {
  const tooltip = document.getElementById('tooltip-container');
  tooltip.textContent = text;
  tooltip.classList.add('visible');
  
  const rect = element.getBoundingClientRect();
  tooltip.style.left = `${rect.left + window.scrollX}px`;
  tooltip.style.top = `${rect.bottom + window.scrollY + 5}px`;
}

hideTooltip() {
  const tooltip = document.getElementById('tooltip-container');
  tooltip.classList.remove('visible');
}

handleDepartmentDrop(e, targetElement) {
    if (!this.departmentManagement.draggedItem) return;
    
    const targetCluster = targetElement.closest('.department-column').dataset.cluster;
    const targetGroupId = targetElement.dataset.id;
    
    if (this.departmentManagement.draggedType === 'group') {
        // Перемещение группы между кластерами
        this.moveGroupToCluster(
            this.departmentManagement.draggedItem,
            this.departmentManagement.sourceCluster,
            targetCluster
        );
    } else {
        // Перемещение элемента между группами
        this.moveItemToGroup(
            this.departmentManagement.draggedItem,
            targetGroupId,
            targetCluster
        );
    }
    
    this.renderDepartmentManagement();
    this.updateTree();
    this.saveData();
}

moveGroupToCluster(groupId, sourceCluster, targetCluster) {
    if (sourceCluster === targetCluster) return;
    
    // Удаляем из исходного кластера
    this.clusters.delete(groupId);
    
    // Добавляем в целевой кластер
    this.clusters.set(groupId, targetCluster);
    
    // Обновляем availableClusters если нужно
    if (!this.availableClusters.has(targetCluster)) {
        this.availableClusters.add(targetCluster);
    }
    
    // Проверяем, остались ли узлы в исходном кластере
    let nodesInSource = 0;
    this.clusters.forEach(cluster => {
        if (cluster === sourceCluster) nodesInSource++;
    });
    
    if (nodesInSource === 0) {
        this.availableClusters.delete(sourceCluster);
    }
}

moveItemToGroup(itemId, targetGroupId, targetCluster) {
    const itemNode = this.findNode(this.treeData, itemId);
    if (!itemNode) return;
    
    // Находим текущего родителя
    const currentParent = this.findParent(this.treeData, itemId);
    if (!currentParent) return;
    
    // Находим целевую группу
    const targetGroup = this.findNode(this.treeData, targetGroupId);
    if (!targetGroup) return;
    
    // Удаляем из текущего родителя
    currentParent.children = currentParent.children.filter(child => child.id !== itemId);
    
    // Добавляем в целевую группу
    targetGroup.children.push(itemNode);
    
    // Если элемент был в другом кластере, обновляем его принадлежность
    if (this.clusters.has(itemId)) {
        this.clusters.delete(itemId);
    }
    
    // Если элемент становится самостоятельной группой (если у него есть дети)
    if (itemNode.children.length > 0 && !this.clusters.has(itemId)) {
        this.clusters.set(itemId, targetCluster);
        this.availableClusters.add(targetCluster);
    }
}
// Показать иконку изображения
showImageIcon(nodeId) {
  const node = this.findNode(this.treeData, nodeId);
  if (node) {
    node.content.hideIcon = false;
    this.updateTree();
    this.saveData();
  }
}
togglePower269Mark() {
this.saveToHistory();
    if (!this.selectedNode) {
        alert('Выберите узел!');
        return;
    }
    const node = this.selectedNode.node;
    node.content.isPower269 = !node.content.isPower269;
    
    // Снимаем другие отметки при установке этой
if (node.content.isPower269) {
    node.content.absent269 = false;
    node.content.isForAll = false;
    node.content.isSubordinate = false;
    node.content.isAuthority = false;
    node.content.isOKR = false; // Добавлено
    node.content.isIndicator = false; // Добавлено
}
    
    this.updateTree();
    this.saveData();
    this.showNotification(
        node.content.isPower269 
            ? 'Узел помечен как "Полномочие из 269-П"'
            : 'Снята пометка "Полномочие из 269-П"'
    );
}
// Установить узел как только текст (без возможности добавления изображения)
setAsTextOnly(nodeId) {
  const node = this.findNode(this.treeData, nodeId);
  if (node) {
    node.content.isTextOnly = true;
    node.content.img = null;
    this.updateTree();
    this.saveData();
  }
}
showClusterDialog() {
    if (!this.selectedNode) {
        alert('Выберите узел!');
        return;
    }

    const node = this.selectedNode.node;
    const currentCluster = this.clusters.get(node.id);
    
    const clusterName = prompt(
        'Введите название кластера (отдела):', 
        currentCluster || ''
    );
    
    if (clusterName === null) return; // Отмена
    
    if (!clusterName.trim()) {
        if (currentCluster) {
            if (confirm('Удалить узел из кластера?')) {
                this.removeFromCluster();
            }
        }
        return;
    }
    
    this.addNodeToCluster(node.id, clusterName.trim());
}
showMultiClusterDialog() {
    if (this.selectedNodes.size === 0) {
        alert('Выберите узлы для добавления в кластер!');
        return;
    }

    const clusterName = prompt('Введите название кластера для выбранных узлов:');
    if (clusterName === null || !clusterName.trim()) return;

    const trimmedName = clusterName.trim();

    // --- This is the new "transactional" approach ---
    this.saveToHistory(false, true); // 1. Save state ONCE before the loop.

    const addedNodeNames = [];
    this.selectedNodes.forEach(nodeId => {
        const node = this.findNode(this.treeData, nodeId);
        if (node) {
            // Core logic: just update the data map
            this.clusters.set(nodeId, trimmedName);
            this.availableClusters.add(trimmedName);
            addedNodeNames.push(`"${node.content.text}"`); // Collect names for the log
        }
    });

    // 2. Log the entire operation ONCE after the loop.
    this.logAction(`Добавлено узлов (${this.selectedNodes.size}) в отдел "${trimmedName}": ${addedNodeNames.join(', ')}`);

    // 3. Update UI and save data ONCE.
    this.updateClusterSelect();
    this.updateTree();
    this.renderDepartmentManagement();
    this.saveData();

    this.showNotification(`Добавлено ${this.selectedNodes.size} узлов в кластер "${trimmedName}"`);

    this.clearMultiSelection();
    this.ctrlPressed = false;
    this.multiSelectMode = false;
}
addNodeToCluster(nodeId, clusterName) {
    this.saveToHistory(false, true); // Принудительно сохраняем для отмены
    const node = this.findNode(this.treeData, nodeId);

    const previouslyActiveCluster = this.activeCluster;

    if (node) {
        const oldCluster = this.clusters.get(nodeId);
        if (oldCluster) {
            this.logAction(`Узел "${node.content.text}" перемещен из "${oldCluster}" в отдел "${clusterName}"`);
        } else {
            this.logAction(`Узел "${node.content.text}" добавлен в отдел "${clusterName}"`);
        }
        delete node.needsClusterUpdate;
    }

    this.clusters.set(nodeId, clusterName);
    this.availableClusters.add(clusterName);

    this.activeCluster = previouslyActiveCluster;

    this.updateClusterSelect();
    this.updateTree();
    this.renderDepartmentManagement();
    this.saveData();

    this.showNotification(`Узел добавлен в отдел "${clusterName}"`);
}
setupClusterControls() {
    
    this.elements.clusterSelect.style.display = 'none';
    const container = this.elements.clusterSelect.parentNode;
    
   
    const customSelect = this.createCustomSelectContainer();
    container.insertBefore(customSelect, this.elements.clusterSelect);
    customSelect.appendChild(this.elements.clusterSelect);
    
   
    const { selectHeader, selectedValue } = this.createSelectHeader();
    customSelect.insertBefore(selectHeader, this.elements.clusterSelect);
    
    
    const { dropdown, optionsContainer, searchInput } = this.createDropdown();
    customSelect.appendChild(dropdown);
    
    
    const updateOptions = () => {
        optionsContainer.innerHTML = '';
        
        // Добавляем опцию "Вся структура"
        this.addAllOptionOption(optionsContainer, selectedValue, dropdown);
        
        // Добавляем опции кластеров
        this.addClusterOptions(optionsContainer, selectedValue, dropdown);
    };
    
    // Обработчики событий
    this.setupSelectHeaderEvents(selectHeader, dropdown, updateOptions, searchInput);
    this.setupSearchInputEvents(searchInput, optionsContainer);
    this.setupDocumentClickHandler(customSelect, dropdown);
    
    // Добавляем дополнительные кнопки управления
    this.addControlButtons(container);
    
    // Инициализация
    this.updateClusterSelect = () => {
        selectedValue.textContent = this.activeCluster || 'Вся структура';
        this.elements.clusterSelect.value = this.activeCluster || '';
        this.updateClusterRemoveButtons();
    };
    
    this.updateClusterSelect();
}


createCustomSelectContainer() {
    const customSelect = document.createElement('div');
    customSelect.className = 'custom-cluster-select';
    customSelect.style.position = 'relative';
    customSelect.style.display = 'inline-block';
    return customSelect;
}
createSelectHeader() {
    const selectHeader = document.createElement('div');
    selectHeader.className = 'select-header';
    selectHeader.style.padding = '8px 12px';
    selectHeader.style.border = '1px solid var(--primary-color)';
    selectHeader.style.borderRadius = '8px';
    selectHeader.style.cursor = 'pointer';
    selectHeader.style.display = 'flex';
    selectHeader.style.justifyContent = 'space-between';
    selectHeader.style.alignItems = 'center';
    selectHeader.style.minWidth = '250px';

    const selectedValue = document.createElement('span');
    selectedValue.textContent = 'Вся структура';
    selectHeader.appendChild(selectedValue);

    const buttonsContainer = document.createElement('div');
    buttonsContainer.style.display = 'flex';
    buttonsContainer.style.alignItems = 'center';
    buttonsContainer.style.gap = '8px';

    // --- ✨ ИЗМЕНЕНИЕ: Добавлена кнопка копирования для выбранного элемента ✨ ---
    const copyBtn = document.createElement('button');
    copyBtn.innerHTML = '⎘'; // Unicode-символ копирования
    copyBtn.title = 'Копировать название отдела';
    copyBtn.className = 'select-option-btn';
    copyBtn.addEventListener('click', (e) => {
        e.stopPropagation(); // Предотвращаем открытие/закрытие списка
        const textToCopy = selectedValue.textContent;
        if (textToCopy && textToCopy !== 'Вся структура') {
            this.copyToClipboard(textToCopy);
        }
    });
    buttonsContainer.appendChild(copyBtn);
    // --- ✨ КОНЕЦ ИЗМЕНЕНИЯ ✨ ---

    const arrowIcon = document.createElement('span');
    arrowIcon.textContent = '▼';
    arrowIcon.style.marginLeft = '5px';
    buttonsContainer.appendChild(arrowIcon);

    selectHeader.appendChild(buttonsContainer);

    return { selectHeader, selectedValue };
}
createDropdown() {
    const dropdown = document.createElement('div');
    dropdown.className = 'select-dropdown';
    dropdown.style.display = 'none';
    dropdown.style.position = 'absolute';
    dropdown.style.top = '100%';
    dropdown.style.left = '0';
    dropdown.style.right = '0';
    dropdown.style.maxHeight = '300px';
    dropdown.style.overflowY = 'auto';
    dropdown.style.background = 'var(--controls-bg)';
    dropdown.style.border = '1px solid var(--primary-color)';
    dropdown.style.borderRadius = '0 0 8px 8px';
    dropdown.style.zIndex = '1000';
    
    const searchInput = document.createElement('input');
    searchInput.type = 'text';
    searchInput.placeholder = 'Поиск отдела...';
    searchInput.style.width = '98%';   // или 'calc(100% - 32px)' для большего отступа
    searchInput.style.minWidth = '320px';
    searchInput.style.margin = '8px';
    searchInput.style.padding = '6px 8px';
    searchInput.style.border = '1px solid var(--primary-color)';
    searchInput.style.borderRadius = '4px';
    dropdown.appendChild(searchInput);
    
    const optionsContainer = document.createElement('div');
    dropdown.appendChild(optionsContainer);
    
    return { dropdown, optionsContainer, searchInput };
}
addAllOptionOption(optionsContainer, selectedValue, dropdown) {
    const allOption = document.createElement('div');
    allOption.className = 'select-option';
    allOption.style.padding = '8px';
    allOption.style.cursor = 'pointer';
    allOption.style.display = 'flex';
    allOption.style.justifyContent = 'space-between';
    allOption.style.alignItems = 'center';
    
    const optionText = document.createElement('span');
    optionText.textContent = 'Вся структура';
    allOption.appendChild(optionText);
    
    const copyBtn = document.createElement('span');
    copyBtn.textContent = ' ⎘';
    copyBtn.style.color = 'var(--accent-color)';
    copyBtn.style.cursor = 'pointer';
    copyBtn.title = 'Копировать название';
    copyBtn.addEventListener('click', (e) => {
        e.stopPropagation();
        this.copyToClipboard('Вся структура');
    });
    allOption.appendChild(copyBtn);
    
    allOption.addEventListener('click', () => {
        this.elements.clusterSelect.value = '';
        selectedValue.textContent = 'Вся структура';
        this.activeCluster = null;
        dropdown.style.display = 'none';
        this.updateTree();
        this.saveData();
    });
    
    optionsContainer.appendChild(allOption);
}
addClusterOptions(optionsContainer, selectedValue, dropdown) {
    Array.from(this.availableClusters).sort().forEach(cluster => {
        const option = document.createElement('div');
        option.className = 'select-option';
        option.style.padding = '8px 12px';
        option.style.cursor = 'pointer';
        option.style.display = 'flex';
        option.style.justifyContent = 'space-between';
        option.style.alignItems = 'center';

        const optionText = document.createElement('span');
        optionText.textContent = cluster;
        option.appendChild(optionText);

        const buttonsContainer = document.createElement('div');
        buttonsContainer.style.display = 'flex';
        buttonsContainer.style.gap = '10px';

        // --- ✨ ИЗМЕНЕНИЕ: Добавлена кнопка копирования для каждого элемента списка ✨ ---
        const copyBtn = document.createElement('button');
        copyBtn.innerHTML = '⎘'; // Unicode-символ копирования
        copyBtn.title = 'Копировать название';
        copyBtn.className = 'select-option-btn';
        copyBtn.addEventListener('click', (e) => {
            e.stopPropagation(); // Важно, чтобы клик по кнопке не выбирал элемент
            this.copyToClipboard(cluster);
        });
        buttonsContainer.appendChild(copyBtn);
        // --- ✨ КОНЕЦ ИЗМЕНЕНИЯ ✨ ---

        const editBtn = document.createElement('span');
        editBtn.textContent = '✎';
        editBtn.title = 'Редактировать название';
        editBtn.style.color = 'var(--primary-color)';
        editBtn.addEventListener('click', (e) => {
            e.stopPropagation();
            this.editClusterName(cluster);
        });
        buttonsContainer.appendChild(editBtn);

        const deleteBtn = document.createElement('span');
        deleteBtn.textContent = '×';
        deleteBtn.title = 'Удалить кластер';
        deleteBtn.style.color = 'var(--accent-color)';
        deleteBtn.addEventListener('click', (e) => {
            e.stopPropagation();
            if (confirm(` [5](https://vertexaisearch.cloud.google.com/grounding-api-redirect/AUZIYQHJqjvVQFhuP1KoF1jizkimiH0QlB-hJDWoJErQXGYn405ORdboHl59asNd87BfC99oKg1Pk-uN06x12Cz7eEGYxURjMAM5KLM3VZzmVmhrBp9NKZY2jtjwqJxU_sbJgbSfjPGVKw==) [6](https://vertexaisearch.cloud.google.com/grounding-api-redirect/AUZIYQFPHP7jZyQP2-bbUa3WMFvKPJmzVFYq-dhzE8TiOpufS80-cjxjqxse6lObzQQT-GYW_Np_d_hKEMSU0RV9fXwYh74WJLWIhJhVs6Rqeb3dxlV2DuCaC20rEO5BkGyL94BnjbPRb67HiCkl8jEkq4oZiFYj4wuPaXcWAisxmj72_8t0rd-Xj1TOcJf6LRYEL6rl_yckJBYYsa9sOlMsiVm8EZRLG6hMk7HR2jqHBC8w3oM=)Удалить кластер "${cluster}"?`)) {
                this.removeCluster(cluster);
                dropdown.style.display = 'none';
            }
        });
        buttonsContainer.appendChild(deleteBtn);

        option.appendChild(buttonsContainer);

        option.addEventListener('click', (e) => {
            if (e.target === option || e.target === optionText) {
                this.elements.clusterSelect.value = cluster;
                selectedValue.textContent = cluster;
                this.activeCluster = cluster;
                dropdown.style.display = 'none';
                this.updateTree();
                this.saveData();
            }
        });

        optionsContainer.appendChild(option);
    });
}
setupSelectHeaderEvents(selectHeader, dropdown, updateOptions, searchInput) {
    selectHeader.addEventListener('click', (e) => {
        e.stopPropagation();
        if (dropdown.style.display === 'block') {
            dropdown.style.display = 'none';
        } else {
            updateOptions();
            dropdown.style.display = 'block';
            searchInput.focus();
        }
    });
}

setupSearchInputEvents(searchInput, optionsContainer) {
    searchInput.addEventListener('input', (e) => {
        const searchTerm = e.target.value.toLowerCase();
        const options = optionsContainer.querySelectorAll('.select-option');
        
        options.forEach(option => {
            const text = option.querySelector('span:first-child').textContent.toLowerCase();
            option.style.display = text.includes(searchTerm) ? 'flex' : 'none';
        });
    });
}

setupDocumentClickHandler(customSelect, dropdown) {
    document.addEventListener('click', (e) => {
        if (!customSelect.contains(e.target)) {
            dropdown.style.display = 'none';
        }
    });
}

addControlButtons(container) {
    
    // Кнопка удаления из кластера
    if (!container.querySelector('.remove-from-cluster-btn')) {
        const removeBtn = document.createElement('button');
        removeBtn.className = 'remove-from-cluster-btn';
        removeBtn.textContent = 'Удалить из отдела';
        removeBtn.title = 'Удалить выбранный узел из текущего кластера';
        removeBtn.style.marginLeft = '8px';
        removeBtn.style.padding = '5px 8px';
removeBtn.style.fontSize = '0.7em'; 
        removeBtn.style.borderRadius = '6px';
        removeBtn.style.background = 'linear-gradient(145deg, #ff4444, #d32f2f)';
        removeBtn.style.color = 'white';
        removeBtn.style.border = 'none';
        removeBtn.style.cursor = 'pointer';
        removeBtn.style.display = 'inline-block';
        
        removeBtn.addEventListener('click', () => {
            if (this.selectedNode) {
                this.removeFromCluster();
            } else {
                alert('Выберите узел для удаления из кластера!');
            }
        });
        
        container.insertBefore(removeBtn, this.elements.addToClusterBtn.nextSibling);
    }
}
copyToClipboard(text) {
    navigator.clipboard.writeText(text)
        .then(() => {
            this.showNotification(`Скопировано: "${text}"`);
        })
        .catch(err => {
            console.error('Ошибка копирования в буфер обмена:', err);
            this.showNotification('Не удалось скопировать текст');
        });
}
updateClusterRemoveButtons() {
    const removeBtn = this.elements.clusterSelect.parentNode.querySelector('.remove-from-cluster-btn');
    
    if (removeBtn) {
        const nodeInCluster = this.selectedNode && this.clusters.has(this.selectedNode.node.id);
        
        // Всегда показываем кнопку, но делаем её серой, если нечего удалять
        removeBtn.style.display = 'inline-block';
        removeBtn.disabled = !nodeInCluster;
        removeBtn.style.opacity = nodeInCluster ? '1' : '0.5';
        
        if (nodeInCluster) {
            const clusterName = this.clusters.get(this.selectedNode.node.id);
            removeBtn.title = `Удалить узел из кластера "${clusterName}"`;
        } else {
            removeBtn.title = 'Выберите узел, принадлежащий кластеру';
        }
    }
}
updateClusterSelect() {
    try {
        const select = this.elements.clusterSelect;
        if (!select) {
            console.error('Cluster select element not found');
            return;
        }

        const currentValue = select.value;
        const currentSearch = this.elements.searchInput?.value || '';

        const options = ['<option value="">Вся структура</option>'];

        Array.from(this.availableClusters)
            .sort((a, b) => a.localeCompare(b))
            .forEach(cluster => {
                options.push(`<option value="${cluster}">${cluster}</option>`);
            });

        select.innerHTML = options.join('');

        if (this.activeCluster && this.availableClusters.has(this.activeCluster)) {
            select.value = this.activeCluster;
        } else if (currentValue && this.availableClusters.has(currentValue)) {
            select.value = currentValue;
        }

        if (this.elements.searchInput && currentSearch) {
            this.elements.searchInput.value = currentSearch;
            this.handleSearchInput(currentSearch);
        }

        // Обновляем кнопку удаления в выпадающем списке
        this.updateClusterRemoveButton();

        // **Обновляем кнопки рядом с выбранным кластером**
        const customSelect = this.elements.clusterSelect.parentNode.querySelector('.custom-cluster-select');
        if (customSelect) {
            const buttons = customSelect.querySelectorAll('button');
            const selectedName = select.value || '';
            buttons.forEach(btn => {
                btn.disabled = !selectedName || selectedName === '';
                btn.style.opacity = btn.disabled ? '0.5' : '1';
                btn.title = btn.disabled ? 'Выберите кластер' : btn.title;
            });
        }

    } catch (error) {
        console.error('Error updating cluster select:', error);
    }
}
removeCluster(clusterName) {
    if (!clusterName || !this.availableClusters.has(clusterName)) {
        alert('Кластер не найден!');
        return;
    }
    
    if (!confirm(`Вы уверены, что хотите полностью удалить кластер "${clusterName}"? Все узлы будут удалены из этого кластера.`)) {
        return;
    }
    
    // Удаляем все узлы из этого кластера
    const nodesToRemove = [];
    this.clusters.forEach((value, key) => {
        if (value === clusterName) {
            nodesToRemove.push(key);
        }
    });
    
    nodesToRemove.forEach(key => {
        this.clusters.delete(key);
    });
    
    // Удаляем кластер из доступных
    this.availableClusters.delete(clusterName);
    
    // Если удалённый кластер был активным, сбрасываем выбор
    if (this.activeCluster === clusterName) {
        this.activeCluster = null;
        this.elements.clusterSelect.value = '';
    }
    
    this.updateClusterSelect();
    this.updateTree();
    this.saveData();
    this.showNotification(`Кластер "${clusterName}" полностью удален`);
}
removeFromCluster() {
    this.saveToHistory(false, true); // Force-save the state BEFORE any changes, creating one undo point.

    const nodesToRemove = this.selectedNodes.size > 0 ? new Set(this.selectedNodes) : new Set([this.selectedNode?.node.id]);

    if (nodesToRemove.size === 0 || (nodesToRemove.size === 1 && !this.selectedNode)) {
        this.showNotification('Выберите узел(ы) для удаления из отдела.', 'error');
        return;
    }

    const removedNodesInfo = [];
    let clusterWasDeleted = false;

    // 1. Loop to gather info and perform the core logic
    nodesToRemove.forEach(nodeId => {
        if (this.clusters.has(nodeId)) {
            const node = this.findNode(this.treeData, nodeId);
            const clusterName = this.clusters.get(nodeId);
            if (node) {
                // We collect info for our single log entry
                removedNodesInfo.push({ name: node.content.text, cluster: clusterName });
            }
            this.clusters.delete(nodeId);
        }
    });

    if (removedNodesInfo.length === 0) {
        this.showNotification('Выбранные узлы не принадлежат ни одному отделу.');
        return;
    }

    // 2. Create ONE log entry for the entire operation
    const logMessage = `Удалено узлов из отдела (${removedNodesInfo.length}): ${removedNodesInfo.map(n => `"${n.name}" из "${n.cluster}"`).join(', ')}`;
    this.logAction(logMessage);

    // 3. Perform UI updates and save data ONCE at the end
    const affectedClusters = new Set(removedNodesInfo.map(n => n.cluster));
    affectedClusters.forEach(clusterName => {
        let nodesLeftInCluster = 0;
        this.clusters.forEach(value => {
            if (value === clusterName) nodesLeftInCluster++;
        });

        if (nodesLeftInCluster === 0) {
            this.availableClusters.delete(clusterName);
            if (this.activeCluster === clusterName) {
                this.activeCluster = null;
            }
            clusterWasDeleted = true;
        }
    });

    this.updateClusterSelect();
    this.updateTree();
    this.saveData();
    this.showNotification(`Удалено ${removedNodesInfo.length} узл(а/ов) из отдела.`);
    this.clearMultiSelection();
}
editClusterName(oldName) {
    const newName = prompt('Введите новое название кластера:', oldName);
    if (!newName || newName.trim() === oldName || !newName.trim()) {
        return; // Отмена или имя не изменилось
    }
    
    // Проверяем, что новое имя уникально
    if (this.availableClusters.has(newName)) {
        alert('Кластер с таким названием уже существует!');
        return;
    }
    
    // Обновляем все узлы, принадлежащие этому кластеру
    this.clusters.forEach((value, key) => {
        if (value === oldName) {
            this.clusters.set(key, newName);
        }
    });
    
    // Обновляем список доступных кластеров
    this.availableClusters.delete(oldName);
    this.availableClusters.add(newName);
    
    // Если редактировался активный кластер, обновляем его
    if (this.activeCluster === oldName) {
        this.activeCluster = newName;
    }
    
    // Обновляем UI
    this.updateClusterSelect();
    this.updateTree();
    this.saveData();
    
    this.showNotification(`Кластер переименован с "${oldName}" на "${newName}"`);
}
// Разрешить добавление изображения к узлу
allowImage(nodeId) {
  const node = this.findNode(this.treeData, nodeId);
  if (node) {
    node.content.isTextOnly = false;
    this.updateTree();
    this.saveData();
  }
}
addMetricBlock(node) {
this.saveToHistory(false, true);
    if (!node.content.metricBlocks) {
        node.content.metricBlocks = [];
    }
    
    const newBlock = {
        id: 'metric_' + Date.now(),
        title: 'Новая метрика',
        quarters: [
            { plan: 100, fact: 0 },
            { plan: 100, fact: 0 },
            { plan: 100, fact: 0 },
            { plan: 100, fact: 0 }
        ]
    };
    
    node.content.metricBlocks.push(newBlock);
    this.updateTree();
    this.saveData();
}
removeMetricBlock(node, blockIndex) {
    if (!node.content.metricBlocks || !node.content.metricBlocks[blockIndex]) return;
    
    // Удаляем метрику
    node.content.metricBlocks.splice(blockIndex, 1);
    
    this.updateTree();
    this.saveData();
    this.showNotification('Метрика удалена');
}
createFireworks(x, y) {
  const fireworksContainer = document.createElement('div');
  fireworksContainer.className = 'firework';
  document.body.appendChild(fireworksContainer);
  

  const colors = this.darkMode ? 
    ['#7BA7CC', '#5D8AA8', '#FF8C66', '#E0E8F0', '#45B7D1'] : 
    ['#5D8AA8', '#87CEEB', '#FFA07A', '#2F4F4F', '#FF6B6B'];
  
  for (let i = 0; i < 50; i++) {
    const particle = document.createElement('div');
    particle.className = 'firework-particle';

    const angle = Math.random() * Math.PI * 2;
    const distance = 50 + Math.random() * 150;
    const tx = Math.cos(angle) * distance;
    const ty = Math.sin(angle) * distance;
  
    const color = colors[Math.floor(Math.random() * colors.length)];
    
    particle.style.left = x + 'px';
    particle.style.top = y + 'px';
    particle.style.setProperty('--tx', tx + 'px');
    particle.style.setProperty('--ty', ty + 'px');
    particle.style.color = color;
    particle.style.animationDuration = (0.5 + Math.random() * 0.5) + 's';
    
    fireworksContainer.appendChild(particle);
  }
  
  setTimeout(() => {
    fireworksContainer.remove();
  }, 1500);
}
isValidEmail(text) {
    // Более строгая проверка email
    return /^[a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\.[a-zA-Z]{2,}$/.test(text) && 
           !/\s/.test(text) && // Не содержит пробелов
           !/^https?:\/\//i.test(text); // Не начинается с http:// или https://
}
isValidUrl(string) {
    try {
        // Проверяем, содержит ли строка пробелы - если да, это не URL
        if (/\s/.test(string)) return false;
        
        // Проверяем, начинается ли строка с http:// или https://
        if (/^https?:\/\//i.test(string)) {
            new URL(string);
            return true;
        }
        
        // Проверяем домены без протокола (например, example.com)
        if (/^[a-z0-9-]+(\.[a-z0-9-]+)+(\/.*)?$/i.test(string)) {
            new URL(`https://${string}`);
            return true;
        }
        
        return false;
    } catch (_) {
        return false;
    }
}

    // Извлекает домен из URL для отображения
    extractDomain(url) {
        try {
            const domain = new URL(url).hostname.replace('www.', '');
            return domain.length > 20 ? domain.substring(0, 17) + '...' : domain;
        } catch (_) {
            return url.length > 20 ? url.substring(0, 17) + '...' : url;
        }
    }

saveToHistory(isInitialState = false, forceSave = false) {
    // Определяем, какие операции требуют сохранения в истории
    const allowedOperations = [
        'addChild',
        'deleteNode',
        'copySelectedNode',
        'pasteNode',
        'moveNode',
        'toggle269Mark',
        'toggleForAll',
        'toggleSubordinateMark',
        'toggleOKRMark',
        'toggleIndicatorMark',
        'toggleAuthorityMark',
        'togglePower269Mark',
        'showAdvancedRestructureDialog',
        'removeFromCluster', 
        'addNodeToCluster'   
    ];

    // Получаем стек вызовов
    const stackTrace = new Error().stack;

    // Проверяем, вызвано ли из разрешенного метода
    const shouldSave = forceSave || isInitialState || allowedOperations.some(op => stackTrace.includes(op));

    if (!shouldSave) return;

    if (isInitialState) {
        this.history = [this.getCurrentState()];
        this.historyIndex = 0;
        return;
    }

    const currentState = this.getCurrentState();
    const lastState = this.history[this.historyIndex];

    if (this.historyIndex < this.history.length - 1) {
        this.history = this.history.slice(0, this.historyIndex + 1);
    }

    this.history.push(currentState);
    this.historyIndex++;

    if (this.history.length > 50) {
        this.history.shift();
        this.historyIndex--;
    }
}
getCurrentState() {
    return {
        tree: JSON.parse(JSON.stringify(this.treeData)),
        nodeCounter: this.nodeCounter,
        filesData: JSON.parse(JSON.stringify(this.filesData)),
        imagesData: JSON.parse(JSON.stringify(this.imagesData)),
        clusters: Array.from(this.clusters.entries()),
        availableClusters: Array.from(this.availableClusters),
        activeCluster: this.activeCluster,
        version: '2.7'  
    };
}

undo() {
    if (this.historyIndex <= 0) {
        this.showNotification('Нет действий для отмены');
        return;
    }

    
    const lastActionEntry = this.actionLog.find(entry => !entry.action.startsWith('Отменено:'));
    const lastActionText = lastActionEntry ? lastActionEntry.action : 'Действие';

   
    this.logAction(`Отменено: ${lastActionText}`);

    this.historyIndex--;
    this.restoreFromHistory();

    this.showNotification(`Действие отменено (шаг ${this.historyIndex + 1}/${this.history.length})`);
    this.saveData();
}
redo() {
    if (this.historyIndex >= this.history.length - 1) {
        this.showNotification('Нет действий для повтора');
        return;
    }
    
    const currentState = this.history[this.historyIndex];
    const nextState = this.history[this.historyIndex + 1];
    
    const significantChange = 
        JSON.stringify(currentState.tree) !== JSON.stringify(nextState.tree) ||
        currentState.nodeCounter !== nextState.nodeCounter;
    
    this.historyIndex++;
    this.restoreFromHistory();
    
    if (significantChange) {
        this.showNotification(`Действие повторено (шаг ${this.historyIndex + 1}/${this.history.length})`);
    }
    
    this.saveData(); 
}
restoreFromHistory() {
    if (this.history.length === 0 || 
        this.historyIndex < 0 || 
        this.historyIndex >= this.history.length) {
        console.error('Invalid history state');
        return;
    }
    
    const state = this.history[this.historyIndex];
    
 
    this.treeData = this.restoreTree(state.tree);
    this.nodeCounter = state.nodeCounter;
    this.filesData = state.filesData || {};
    this.imagesData = state.imagesData || {};
    this.clusters = new Map(state.clusters || []);
    this.availableClusters = new Set(state.availableClusters || []);
    this.activeCluster = state.activeCluster || null;
    
 
    this.updateClusterSelect();
    this.updateTree();
}
    loadThemePreference() {
        const savedTheme = localStorage.getItem('treeAppTheme');
        this.darkMode = savedTheme === 'dark';
        document.documentElement.classList.toggle('dark', this.darkMode);
    }
    logAction(actionText) {
        const newLogEntry = { action: actionText, timestamp: new Date().toISOString() };
        this.actionLog.unshift(newLogEntry);
        if (this.actionLog.length > this.maxLogEntries) { this.actionLog.pop(); }
        try {
  
            localStorage.setItem('treeActionLog', JSON.stringify(this.actionLog));
        }
        catch (e) { console.error("Не удалось сохранить историю действий:", e); }
    }

    loadActionLog() {
        try {
            const savedLog = localStorage.getItem('treeActionLog');
            if (savedLog) { this.actionLog = JSON.parse(savedLog); }
        } catch (e) {
            console.error("Не удалось загрузить историю действий:", e);
            this.actionLog = [];
        }
    }

    injectHistoryLogStyles() {
        if (document.getElementById('history-log-styles')) { return; }
        const style = document.createElement('style');
        style.id = 'history-log-styles';

        style.textContent = `
            .history-log-icon { position: fixed; bottom: 80px; right: 20px; width: 40px; height: 40px; background: var(--controls-bg); border-radius: 50%; box-shadow: 0 2px 8px rgba(0,0,0,0.2); cursor: pointer; z-index: 1001; display: flex; align-items: center; justify-content: center; font-size: 24px; transition: all 0.3s ease; }
            .history-log-icon:hover { transform: scale(1.1) rotate(15deg); box-shadow: 0 4px 12px rgba(0,0,0,0.3); }
            .history-dialog-backdrop { position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: rgba(0, 0, 0, 0.6); display: none; justify-content: center; align-items: center; z-index: 10002; backdrop-filter: blur(5px); }
            .history-dialog { background: var(--controls-bg); padding: 25px; border-radius: 12px; box-shadow: 0 5px 20px rgba(0,0,0,0.25); width: 90%; max-width: 500px; border: 1px solid var(--primary-color); animation: dialog-appear 0.3s ease-out; }
            @keyframes dialog-appear { from { opacity: 0; transform: scale(0.9); } to { opacity: 1; transform: scale(1); } }
            .history-dialog h3 { margin-top: 0; color: var(--primary-color); text-align: center; }
            .history-list { list-style: none; padding: 0; margin: 20px 0; max-height: 60vh; overflow-y: auto; }
            .history-item { background: rgba(93, 138, 168, 0.05); padding: 12px; border-bottom: 1px solid rgba(93, 138, 168, 0.1); display: flex; justify-content: space-between; align-items: center; font-size: 0.95em; }
            .history-item:last-child { border-bottom: none; }
            .history-item .action { font-weight: 500; }
            .history-item .timestamp { font-size: 0.8em; color: var(--accent-color); white-space: nowrap; margin-left: 15px; }
            .history-dialog-close { display: block; margin: 15px auto 0; padding: 8px 20px; background: var(--primary-color); color: white; border: none; border-radius: 6px; cursor: pointer; }
        `;
        document.head.appendChild(style);
    }

    setupHistoryLogUI() {
        this.injectHistoryLogStyles();
        const icon = document.getElementById('historyLogIcon');
        const backdrop = document.getElementById('historyDialogBackdrop');
        const closeBtn = document.getElementById('historyDialogClose');
        if (icon && backdrop && closeBtn) {
            icon.addEventListener('click', () => this.showHistoryDialog());
            closeBtn.addEventListener('click', () => backdrop.style.display = 'none');
            backdrop.addEventListener('click', (e) => { if (e.target === backdrop) { backdrop.style.display = 'none'; } });
        }
    }

    showHistoryDialog() {
        const list = document.getElementById('historyList');
        const backdrop = document.getElementById('historyDialogBackdrop');
        if (!list || !backdrop) return;
        list.innerHTML = '';
        if (this.actionLog.length === 0) {
            list.innerHTML = '<li class="history-item">История изменений пуста.</li>';
        } else {
            this.actionLog.forEach(entry => {
                const item = document.createElement('li');
                item.className = 'history-item';
                const actionSpan = document.createElement('span');
                actionSpan.className = 'action';
                actionSpan.textContent = entry.action;
                const timeSpan = document.createElement('span');
                timeSpan.className = 'timestamp';
                timeSpan.textContent = new Date(entry.timestamp).toLocaleString('ru-RU');
                item.appendChild(actionSpan);
                item.appendChild(timeSpan);
                list.appendChild(item);
            });
        }
        backdrop.style.display = 'flex';
    }
    

} 
const NODE_TYPE_COLORS = {
  'должностные регламенты': '#191970',          
  'государственная программа': '#00BFFF',      
  'окр': '#FFA500',                            
  'отсутствует в 269-п': '#FF4444',             
  'полномочие из 269-п': '#9E9E9E',             
  'для всех сотрудников': '#4CAF50',            
  'идентичное полномочие': '#D2B48C'           
};
const NODE_TYPE_ABBREVIATIONS = {
  'должностные регламенты': 'д.р.',
  'государственная программа': 'г.п.',
  'окр': 'окр',
  'отсутствует в 269-п': 'отс. 269-п',
  'полномочие из 269-п': 'полн. 269-п',
  'для всех сотрудников': 'для всех',
  'идентичное полномочие': 'ид. полн.'
};
window.treeApp = new TreeManager();
</script> 
<div id="tooltip-container" class="tooltip" style="display: none;"></div>
</body> 
</html> 
